unit DataCollector;
{$WARN SYMBOL_PLATFORM OFF}
interface

uses
  Windows, Classes, Controls, SysUtils, stdctrls, DMClient, AuchTypes, printers,
  Astringfunctions,{$IFDEF Video} Forms, Messages, OleCtrls, TSCRECLib_TLB,{$ENDIF}
  AMiscFunctions, variants, registry, inifiles, dialogs, LGLobals;

type

//  TShortCutEvent = procedure (var Msg: TWMKey; var Handled: Boolean) of object;

  TDataCollector = class(TObject)
  private
    detailedTotal: boolean;
    DetailedArray: TDetailedBalarray;
//    NewDeptID : integer;
//    procedure DateRangesAfterPost(DataSet: TDataSet);
//    procedure DataModuleDestroy(Sender: TObject);
//    procedure QuotesAfterPost(DataSet: TDataSet);
    function OkToExclude(deptid : integer): Boolean;
    //    NewQuoteID : Integer;
    { Private declarations }
  public
    { Public declarations }
    Planloaded : Boolean;
    PlanExploaded: Boolean;
    Monitoringloaded : Boolean;
    MonitoringExploaded: Boolean;
    psdate : TDateTime; // planning start date
    pedate : TDateTime; // planning end date
    DetailedOptions : TDetailedBalArray;
    procedure getPlanningData;
    procedure getReportData;
    procedure ClearReportDataList;
    procedure reloadPastBalances;
    procedure PutPastBalances;
    procedure getPlanningExpData(AdjustOtherExpenses : Boolean);
    procedure getMonitoringExpData;
    procedure setPlanningData;
    procedure RefreshPlanningData;
    procedure setPlanningExpData;
    procedure setMonitoringExpData;
    procedure ClearPlanDataList;
    procedure ClearPlanExpDataList;
    procedure ClearMonitorExpDataList;
    procedure getMonitoringData;
    procedure setMonitoringData;
    procedure clearMonitoringDataList;
    procedure GetQuotes(StartDate, EndDate: TDateTime);
    procedure clearQuoteList;
//    procedure SetInvoiceFilter(IType : Integer; StartDate, EndDate : TDateTime);
    procedure getPastBalances(var balances : Array of currency; Accountno : Integer);
    procedure GetConsolidatedList(Consolidated : Boolean);
    procedure ClearConsolidatedList;
    procedure CalculateReportData;
    procedure CalculateMonitorKeyReportData(Mwages: TreportDataRecPtr; SummaryType : integer; perstart, Sdate, edate: TDateTime);
    procedure CalculateMonitorDPLReportData(SummaryType : integer; perstart, Sdate, edate: TDateTime);
    procedure CalculateKeys(TotalNoColumns, DetailedReportingPeriod: integer);
    function getBalances(var Balances : array of currency; Accountno : integer; UsePlanData: Boolean): Boolean;
    function setBalances(var Balances : array of currency; Accountno : integer; UsePlanData: Boolean): Boolean;
    procedure GetWages(ReportWages: TReportDataRecPtr);
    Function getAccountTitle(Title : Pchar; Accountno : integer): boolean;
    function getAccountSubTitle(SubTitle: Pchar; Accountno : Integer): boolean;
    function setPastBalance(balance : Pcurrency; Accountno : Integer): Boolean;
    function clearPastBalance(balance : Pcurrency; Accountno : Integer): Boolean;
    function getRateBalances(var Balances : array of currency; MonitorDate : TDateTime): Boolean;
    function updateArray(var barray: array of currency; PeriodStart, StartDate, EndDate: double;
                     new: currency; roundto: Extended): boolean;
    function getTotalBalance(const balances: array of currency; periodstart, startdate, enddate : Double): currency;
//    function SetDBPassword(pwd: string): Boolean;
    procedure CopyNewPlanData(SrcStart, SrcEnd, DstStart : TDateTime; SrcPlan, ClearData : Boolean; Range : TRangeType);
    procedure sortQuotes(SortType: TQuoteSortType);
    procedure getTrackingkeyData(Sumcum : Boolean; StartDate, EndDate, perstart: TDate; SummaryType: integer);
    procedure GetMonitoringAccountArray(NotGraph: Boolean);
    procedure getDetailedPLData(Sumcum : Boolean; StartDate, EndDate, perstart: TDate; SummaryType: integer);
    procedure GetDetailedOptions;
    procedure SetDetailedOptions;
    function GetUserOption(OptName: String; Otype : TUOType): Variant;
    function SetUserOption(OptName: String; Otype : TUOType; Ovalue : Variant): Boolean;
  end;

  TCashFlowEngine = class(Tobject)
  private
    psdate, pedate : TDateTime;
    PeriodType : Integer;
    CashFlowDataList : TList;
    procedure getCashFlowData;
    procedure setCashFlowData;
    procedure clearCashFlowDataList;
    function GetCashFlowAccountIndex(accountNo : Integer): Integer;
    function totalBalanceArray(const balances: array of currency): currency;
    function roundCurrency(var value: currency; const noDP: smallint): currency;
  public
    CashFlowloaded : Boolean;
    PeriodCount : integer;
    BankDataRec : TCashFlowRecPtr;
    ARDataRec : TCashFlowRecPtr;
    StockDataRec : TCashFlowRecPtr;
    CMFDataRec : TCashFlowRecPtr;
    MSDataRec : TCashFlowRecPtr;
    OCADataRec : TCashFlowRecPtr;
    TCADataRec : TCashFlowRecPtr;
    NDADataRec : TCashFlowRecPtr;
    DADataRec : TCashFlowRecPtr;
    IADataRec : TCashFlowRecPtr;
    BankODDataRec : TCashFlowRecPtr;
    APDataRec : TCashFlowRecPtr;
    AEDataRec : TCashFlowRecPtr;
    TAXPAYDataRec : TCashFlowRecPtr;
    INCTAXDataRec : TCashFlowRecPtr;
    DIVDataRec : TCashFlowRecPtr;
    OCLDataRec : TCashFlowRecPtr;
    LOANSDataRec : TCashFlowRecPtr;
    EQUITYDataRec : TCashFlowRecPtr;
    SalesRec : TCashFlowRecPtr;
    StockSoldRec : TCashFlowRecPtr;
    SubcontractorsRec : TCashFlowRecPtr;
    TAXSalesRec : TCashFlowRecPtr;
    GrossSalesRec : TCashFlowRecPtr;
    ARCashReceiptsRec : TCashFlowRecPtr;
    ARAdjustmentsRec : TCashFlowRecPtr;
    StockDeliveriesRec : TCashFlowRecPtr;
    TaxStockRec : TCashFlowRecPtr;
    GrossStockDelRec : TCashFlowRecPtr;
    StockAdjustmentsRec : TCashFlowRecPtr;
    TaxSubcontractorsRec : TCashFlowRecPtr;
    GrossSubContractorsRec : TCashFlowRecPtr;
    CashManagementDepsRec : TCashFlowRecPtr;
    CashmanagementWdrlsRec : TCashFlowRecPtr;
    MarketSecPurchasesRec : TCashFlowRecPtr;
    MarketSecSalesRec : TCashFlowRecPtr;
    OtherAssetsPurchRec : TCashFlowRecPtr;
    OtherAssetsSalesRec : TCashFlowRecPtr;
    NonDepnAssetsPurchRec : TCashFlowRecPtr;
    NonDepnAssetsSalesRec : TCashFlowRecPtr;
    DepnAssetsPurchRec : TCashFlowRecPtr;
    DepnAssetsSalesRec : TCashFlowRecPtr;
    IntangAssetsPurchRec : TCashFlowRecPtr;
    IntangAssetsSalesRec : TCashFlowRecPtr;
    ExpensesViaAPRec : TCashFlowRecPtr;
    TaxExpensesAPrec : TcashFlowRecPtr;
    GrossExpviaAPRec : TcashFlowRecPtr;
    TotalInvoiceAPRec : TcashFlowRecPtr;
    CashPaymentsAPRec : TCashFlowrecPtr;
    APAdjustmentsRec : TCashFlowRecPtr;
    NetTaxPayableRec : TCashFlowRecPtr;
    NetTaxRefundRec : TCashFlowRecPtr;
    ExpensesAERec : TCashFlowRecPtr;
    TaxExpensesAERec : TCashFlowRecPtr;
    GrossExpensesAccruedRec : TCashFlowRecPtr;
    CashPaymentsAERec : TCashFlowRecPtr;
    AEAdjustmentsRec : TCashFlowRecPtr;
    TotalTaxCollectedRec : TCashFlowRecPtr;
    TotalTaxPaidRec : TCashFlowRecPtr;
    TaxAdjustmentsRec : TCashFlowRecPtr;
    DividendDeclaredRec : TCashFlowRecPtr;
    DividendPaidRec : TCashFlowRecPtr;
    OtherLiabIncurredRec : TCashFlowRecPtr;
    OtherLiabPaidRec : TCashFlowRecPtr;
    LoansIncurredRec : TCashFlowRecPtr;
    LoansRepaidRec : TCashFlowRecPtr;
    EquityInjectedRec : TCashFlowRecPtr;
    EquityWithdrawnRec : TCashFlowRecPtr;
    AR_DaysRec : TCashFlowRecPtr;
    Stock_DaysRec : TCashFlowRecPtr;
    AP_DaysRec : TCashFlowRecPtr;
    AE_DaysRec : TCashFlowRecPtr;
    Constructor Create(StartDate, EndDate: TDateTime; PeriodType: integer); virtual;
    Destructor Destroy; override;
    Procedure CalculateAll;
//    Procedure CalculateThisPeriod(PeriodNum : integer);
    procedure calculateBSDays(monthFrom, MonthTo, moveAvg: integer; CFType : TCashFlowType);
    procedure defineBSDays(cfType : TCashFlowType);
    procedure calculateBSBalance(month, moveAvg: integer; cfType : TCashFlowType);
    procedure calculateStockturn(monthFrom, MonthTo, moveAvg: integer);
    procedure defineStockturn(moveAvg: integer);
    procedure calculateStockBalances(month, moveAvg: integer);
    procedure getPlanBalanceonDateEx(Baldate: TDateTime; AccountNo: integer; var Balance: Currency; Var PreviousDayNonZero: Boolean);
    function SetPlanBalanceonDateEx(Baldate: TDateTime; AccountNo: integer; Balance: Currency): Boolean;
    procedure SetBSBalance(BSrec : TCashFlowRecPtr);
    procedure UpdateBSBalance(BSrec : TCashFlowRecPtr; newBalance : Currency; ForceUpdate : Boolean);
    procedure BuildBSSummary(BSrec : TCashFlowRecPtr);
    procedure CreateDeptExpenseAccountRecords;
    procedure ProcessExpenses;
  end;

var
  DataCollect: TDataCollector;
  CASHFE : TCashFlowEngine;
  PlanDataList : TList;
  PlanExpDataList: TList;
  ReportDataList : TList;
  ConsolidList: TList;
  QuoteList : TList;
  MonitoringDataList : TList;
  MonitoringExpDataList : TList;
  Prototype : string;
  VersionInfo : String;
  Slashchar : char;
  SummaryPeriodIndexArray : array[0 .. NUM_WEEKS + 1] of Integer;
  MonitoringAccountarray : array[0..MONITORINGACCOUNTLIST - 1] of integer;
  DetailedExpensesPast : Boolean;
  TestPtr : Pointer;
{$IFDEF Video}
  CamtasiaRecorder1 : TCamtasiaRecorder;
  TakeCount : Integer;
{$ENDIF}

function getListPastBalance(ListIndex: integer): currency;
procedure setListPastBalance(ListIndex: integer; balance : currency);
function getListPlanBalance(ListIndex: integer): currency;
procedure setListPlanBalance(Listindex: integer; balance : currency; UpdateArray : Boolean);
function getaccountlistindex(accountno: integer): integer;
function getMonitoringSaleslistindex(accountno: integer): integer;
function getMonitoringSalesInputindex(accountno: integer): integer;
function getKeyaccountlistindex(accountno: integer): integer;
function getexpaccountlistindex(accountno: integer): integer;
function GetReportAccountIndex(accountNo : Integer): Integer;
procedure sortExpenseList(UseLPlanData : Boolean);
function createSummaryIndex(SummaryType: Integer; StartDate, Enddate: TDateTime): Integer;
procedure UpdateBalances(var Barray: array of currency; new: currency);
procedure AdjustBalances(var Barray, totalexp: array of currency; new: currency);
procedure UpdateFromSummaryBalances(var Barray, totalExp: array of currency; new: currency; fromperiod, toperiod, AccountNo: integer);
function getWIBalance(WIset, WIAccount : integer): currency;
procedure setWIBalance(WIset, WIAccount : integer; balance : Currency);
function FindPrinterIndex(NewPrinter : string): integer;
function BuildSummary(AccountNo: Integer; UsePlanDates: Boolean; Detail: TDetailedBalArray; var Summary: TSummaryBalArray): Currency;
function GetFileModDate(Filename: String): TDateTime;
function CheckFileName(basefolder, filename: String): string;
function ReportFileInuse(Filename: String): Boolean;
procedure ShowConcatMessage(Flname: String);

const
  SummaryPlan : array[0..SUMMARYPLANLIST  - 1] of
   integer = (SALES, COGS, GROSSPROFIT, TOTALEXPENSES,
              NETOPERATINGPROFIT, OTHERINCOME,
              NETPROFIT, POTENTIAL, BILLED, SUBCONTRACTORS,
              ACCOUNT_REC, CASH_AT_BANK, STOCK, ACCOUNT_PAY, FTEPROD, FTEOTHER, WHATIF,
              SALESUNIT, GPUNIT, GPPC, PRODUCTIVITY, HRSPERDAY);  // DETAILEDOPT

  DetailedPlan : array[0..DETAILEDPLANLIST - 1] of
   integer = (SALES, GROSSPROFIT, TOTALEXPENSES, NETOPERATINGPROFIT,  NETPROFIT,
   // these are editable
             OTHERINCOME, POTENTIAL, BILLED, SALESUNIT, GPUNIT, GPPC, PRODUCTIVITY);

  DetailPlanGraph : array[0..DETAILPLANGRAPHLIST - 1] of
   integer = (SALES, GROSSPROFIT, TOTALEXPENSES, NETOPERATINGPROFIT,
             OTHERINCOME, NETPROFIT, POTENTIAL, BILLED, SALESUNIT, GPUNIT,
             GPPC, PRODUCTIVITY);

  WorkBackAccounts : array[0..WORKBACKLIST - 1] of
   integer = (SALES, GROSSPROFIT, WBMATERIALS, WBSUBCON, WBMATERIALMU, WBSUBCONMU,
             WBLABOURMU, WBLABOURRATE);

  KeyReportAccounts : array[0..22] of
   integer = (SALES, GROSSPROFIT, GPPC, TOTALEXPENSES, TOTALEXPPC,
              NETPROFIT, NPPC, POTENTIAL, BILLED, PRODUCTIVITY, HRSPERDAY, FTEPROD,
              SALESUNIT, GPUNIT, TOTALEXPUNIT, NPUNIT, SALESWAGE, GPWAGE, NPWAGE,
              FTEOTHER, SALESFTE, GPFTE, NPFTE);

  KeyTargets : array[0..DETAILEDTARGETLIST - 1] of
   integer = (SALES, GROSSPROFIT, GPPC, TOTALEXPENSES, NETOPERATINGPROFIT, OTHERINCOME, NETPROFIT,
              POTENTIAL, BILLED, PRODUCTIVITY, HRSPERDAY, SALESUNIT, GPUNIT);

  MonitoringSalesAccounts : array[0..MONITORSALESLIST - 1] of
   integer = (SALES, COGS, SUBCONTRACTORS, GROSSPROFIT, OTHERINCOME,
           POTENTIAL, BILLED, SALESUNIT, GPUNIT, GPPC, PRODUCTIVITY);    // DETAILEDOPT

  MonitoringSalesInput : array[0..MONITORSALESLIST - 1] of
    integer = (SALES, COGS, GROSSPROFIT, GPPC, POTENTIAL, BILLED, GPUNIT, SUBCONTRACTORS,
            OTHERINCOME, SALESUNIT, PRODUCTIVITY);  // DETAILEDOPT

  CashFlowMain : array[0.. CASHFLOWLIST - 1] of
    integer = (CASH_AT_BANK, ACCOUNT_REC, STOCK, CASH_MAN_FUND,
              MARKETSEC, OTHER_CURRENT_ASSETS, TOTAL_CURRENT_ASSETS, NON_DEP_ASSETS,
              DEP_ASSETS, INTANG_ASSETS, BANK_OVERDRAFT, ACCOUNT_PAY, ACCRUED_EXPENSES,
              TAX_PAYABLE, INC_TAX_PAYABLE, DIVIDENDS_PAYABLE, OTHER_CURRENT_LIAB,
              LOANS, EQUITY, SALES, STOCK_SOLD, SUBCONTRACTORS, TAX_ON_SALES, // STOCK SOLD is SALES - GP - SUBCONTRACTORS
              TOTAL_GROSS_SALES, CASH_RECEIPTS_AR, AR_ADJUSTMENTS,
              STOCK_DELIVERIES, TAX_ON_STOCK_DELIVERIES, ST_ADJUSTMENTS,
              GROSS_STOCK_PURCHASES, TAX_ON_SUBCONTRACTORS, GROSS_SUBCONTRACTORS,
              CASH_MAN_DEPOSITS, CASH_MAN_WITHDRAWALS, MARKET_SEC_PURCHASES, MARKET_SEC_SALES,
              OTHER_ASSETS_PURCHASES, OTHER_ASSETS_SALES, NON_DEP_ASSET_PURCHASES,
              NON_DEP_ASSET_SALES, DEP_ASSET_PURCHASES, DEP_ASSET_SALES,
              INTANG_ASSET_PURCHASES, INTANG_ASSET_SALES, TOTAL_AP_INVOICES,
              CASH_PAYMENTS_AP, NET_EXPENSES_VIA_AP, TAX_EXPENSES_VIA_AP, GROSS_EXPENSES_VIA_AP, AP_ADJUSTMENTS,
              NET_EXPENSES_ACCRUED, TAX_EXPENSES_ACCRUED, GROSS_EXPENSES_ACCRUED, CASH_PAYMENTS_AE, AE_ADJUSTMENTS, TOTAL_TAX_COLLECTED, TOTAL_TAX_PAID,
              TAX_ADJUSTMENTS, INC_TAX_INCURRED, INC_TAX_PAID, DIV_DECLARED, DIV_PAID,
              OTHER_LIAB_INCURRED, OTHER_LIAB_PAID, LOANS_INCURRED, LOANS_REPAID,
              EQUITY_INJECTED, EQUITY_WITHDRAWN, AR_DAYS, STOCK_DAYS, AP_DAYS, AE_DAYS);
const
  NoPrompt = 1;
  UseFileName = 2;
  Concatenate = 4;
  DisableCompression = 8;
  EmbedFonts = 16;
  OverwriteFile = $0000;
  ConfirmOverWrite = $1000;
  AppendFile = $2000;
  AddDateTime = $3000;
  AddIDNumber = $4000;

implementation

{ ---------------------------------------------------------------------------- }
{ -- Balance array's manipuations routines                                     }
{ ---------------------------------------------------------------------------- }
{
  Routine to manipulate an array of currencys so that the total equals that
  passed. Takes into account the current balance of each elment and uses this
  to calculate the new balances as a percentage of the overall total.

  barray: The array of currencys to manipulate
  astart: The first element in the array to use
  aend:   The last element in the array to use
  new:    The new total the astart to aend element must total too

  Roundto:
  This string can be of zero length in which case maximum
  procision is retained, else it should be one of the following:-
  0         for rounding to the nearest whole currency figure;
  0.0       for rounding to the first decimal place or;
  0.00      etc for further precision.

  11/10/1999 Implementation failed to roundto correctly. We need
                 an extended which multiplies then divides each element of the array
                 to correctly get the right result.
                 0 means no rounding,
                 1 means move the decimal place to the right , round and move to the left, etc.

  If the current sum or the array is zero, it will divide the New value evenly
  and rounded dynamically if roundto is not zero length.
  If the new value is zero, the array will be initialized.
  In all other cases, the sum of the array will equal the new value by
  apportioning the new value based on the relative values of each element.
  ---------------------------------------------------------------------------- }
function TDataCollector.updateArray(var barray: array of currency; PeriodStart, StartDate, EndDate: double;
                     new: currency; roundto: Extended): boolean;
var
  temp, temp1, temp2, temp3, temp4, temp5: extended;
  astart, aend, cn: integer;
//  temprnd: extended;
begin
  astart := trunc(StartDate) - trunc(PeriodStart);
  aend := trunc(EndDate) - trunc(PeriodStart);
  temp1 := new;
  temp := 0;
  for cn := astart to aend do
    temp := temp + barray[cn];
  if new = 0
  then begin
    for cn := astart to aend do
      barray[cn] := 0;
  end
  else if temp = 0
    then begin
    temp3 := 0;
    temp4 := 0;
    temp2 := aend - (astart - 1);
    if temp2 > 0 then
      temp1 := temp1 / temp2;
    for cn := astart to aend
    do begin
      barray[cn] := temp1;
      if roundto > 0 then
        barray[cn] := round(roundto * 10 * barray[cn]) / (roundto * 10)
      else
        barray[cn] := round(barray[cn]);
      temp3 := temp3 + barray[cn];
      temp4 := temp4 + temp1;
      temp5 := temp4 - temp3;
      if temp5 > 1
      then begin
        barray[cn] := barray[cn] + 1;
        temp3 := temp3 + 1;
      end;
      if temp5 < -1
      then begin
        barray[cn] := barray[cn] - 1;
        temp3 := temp3 - 1;
      end;
      if cn = aend then barray[cn] := barray[cn] + new - temp3;
    end;
  end
  else begin
    temp4 := new;
    for cn := astart to aend
    do begin
      if (cn >= astart) AND (cn <= aend)
      then begin
        temp3 := barray[cn];
        if (temp4 <> 0) and (temp <> 0) then
          barray[cn] := barray[cn] * temp4 / temp;
        if roundto > 0 then
          barray[cn] := round(roundto * 10 * barray[cn]) / (roundto * 10)
        else
          barray[cn] := round(barray[cn]);
        temp4 := temp4 - barray[cn];
        temp := temp - temp3;

        if cn = aend
        then begin
          if roundto > 0 then
            temp4 := round(roundto * 10 * temp4) / (roundto * 10)
          else
            temp4 := round(temp4);
          barray[cn] := barray[cn] + temp4;
        end;
      end;
    end;
  end;
  result := True;
end;

{ ---------------------------------------------------------------------------- }
{ -- gettotalbalance - Returns the total of all values with the range in the passed array   }
{ ---------------------------------------------------------------------------- }
function TDataCollector.getTotalBalance(const balances: array of currency; periodstart, startdate, enddate : double): currency;
var
  astart, aend, balIndex: integer;
begin
  result := 0;
  astart := trunc(Periodstart) - trunc(Startdate);
  aend := trunc(Enddate) - trunc(startDate);
  for balIndex := astart to aend
  do begin
    result := result  + balances[balIndex];
    if detailedTotal then
      DetailedArray[balindex] := DetailedArray[Balindex] + balances[balindex];
  end;
end;

procedure TDataCollector.GetConsolidatedList(Consolidated : Boolean);
var
  DeptRec : TDepartRecPtr;
  varg : Variant;
  procedure LoadDept;
    begin
    DeptRec.DeptId := DataModuleClient.DeptRefDept_ID.value;
    DeptRec.Name := DataModuleClient.DeptRefRevenue_Group_Name.value;
    DeptRec.CurrencySymbol := DataModuleClient.DeptRefCurrency.Value;
    DeptRec.ReportCode1 := DataModuleClient.DeptRefReport_Code1.value;
    DeptRec.ReportCode2 := DataModuleClient.DeptRefReport_Code2.value;
    DeptRec.UnitDescS := DataModuleClient.DeptRefSingular_UnitDesc.value;
    DeptRec.UnitDescP := DataModuleClient.DeptRefPlural_UnitDesc.value;
  end;

begin
  if Assigned(ConsolidList) then
    ClearConsolidatedList;
  if not Assigned(ConsolidList) then
    ConsolidList := TList.Create;
  if Not Consolidated
    then begin
    varg := DataModuleClient.DepartmentsDept_ID.value;
    DataModuleClient.DeptRef.Locate('Dept_ID',Varg, []);
    new(DeptRec);
    LoadDept;
    ConsolidList.add(DeptRec);
  end
  else begin
    DataModuleClient.DeptRef.First;
    while DataModuleClient.DeptRef.eof = false do
      begin
  //  Check to see if this department is to be excluded
      new(DeptRec);
      LoadDept;
      ConsolidList.add(DeptRec);
      DataModuleClient.DeptRef.next;
    end;    // while
  end;
end;

procedure TDataCollector.ClearConsolidatedList;
var
  index: integer;
  Consolist : TDepartRecPtr;
begin
  if Assigned(ConsolidList)
    then begin
    for index := 0 to ConsolidList.Count - 1
      do begin
      Consolist := TDepartRecPtr(ConsolidList.Items[index]);
      dispose(Consolist);
      end;
    ConsolidList.clear;
//    ConsolidList.free;
  end;
end;

procedure TCashFlowEngine.getPlanBalanceonDateEx(Baldate: TDateTime; AccountNo: integer; var Balance: Currency; Var PreviousDayNonZero: Boolean);
Var
  I: Integer;
  tempstream : TmemoryStream;
  Tempbalances : TDetailedBalArray;
  varg : Variant;
  found : Boolean;
  d, m, y : Word;
  daystostart : integer;
  DeptRec : TdepartRecPtr;
begin
  Balance := 0;
  PreviousDayNonZero := False;
  tempstream := TmemoryStream.Create;
  tempstream.setsize(sizeof(Currency) * NUM_DAYSINYEAR);
  decodeDate(Baldate, y, m, d);
  varg := VarArraycreate([0,3], VarVariant);
  DeptRec := TDepartRecPtr(ConsolidList.items[0]);
  varg[0] := DeptRec.DeptId;
  varg[1] := AccountNo;
  varg[2] := Y;
  FillChar(tempstream.memory^, tempstream.size, #0);
  FillChar(TempBalances, sizeof(TDetailedBalArray), #0);
  tempstream.Seek(0, soFromBeginning);
  found := DataModuleClient.PlanData.Locate('Dept_ID;Account_Number;D_Year',varg,[]);
  if found then
    DataModuleClient.PlanDataD_Bals.SavetoStream(tempstream);
  tempstream.Seek(0, soFromBeginning);
  I := DaysinYear(Baldate) * Sizeof(Currency);
  if (tempstream.read(TempBalances, I) > 0) then
    begin
    daystostart := DaysfromYearStart(BalDate);
    if Daystostart > 0 then
      begin
      if tempbalances[Daystostart - 1] <> 0 then
        PreviousDayNonZero := True;
      end
    else
      begin
      balance := 0;
      getPlanBalanceonDateEx((Baldate - 1), AccountNo, Balance, PreviousDayNonZero);
      if Balance <> 0 then
        PreviousDayNonZero := True
      else
        PreviousDayNonZero := False;
      end;
    Balance := tempBalances[DaystoStart];
    end;
  tempstream.Free;
end;

function TCashFlowEngine.SetPlanBalanceonDateEx(Baldate: TDateTime; AccountNo: integer; Balance: Currency): Boolean;
Var
  I : integer;
  tempstream : TmemoryStream;
  Tempbalances : TDetailedBalArray;
  Found : boolean;
  varg : variant;
//  recdate : double;
  d, m, y : Word;
  daystostart : integer;
begin
  Result := False;
  tempstream := TmemoryStream.create;
  tempstream.setsize(sizeof(Currency) * NUM_DAYSINYEAR);
  FillChar(tempstream.memory^, tempstream.size, #0);
  FillChar(TempBalances, sizeof(TDetailedBalArray), #0);
  // see if we have any balances for the year
  decodeDate(psdate, y, m, d);
  varg := VarArraycreate([0,3], VarVariant);
  varg[0] := DataModuleClient.DepartmentsDept_ID.value;
  varg[1] := AccountNo;
  varg[2] := y;
  found := DataModuleClient.PlanData.Locate('Dept_ID;Account_Number;D_Year',varg,[]);
  if not found then
    begin
    DataModuleClient.PlanData.Insert;
    DataModuleClient.PlanDataDept_ID.value := DataModuleClient.DepartmentsDept_ID.value;
    DataModuleClient.PlanDataAccount_Number.Value := AccountNo;
    DataModuleClient.PlanDataD_Year.value := Y;
    DataModuleClient.PlanDataD_TYPE.Value := 1;
    end
  else
    begin
    DataModuleClient.PlanData.Edit;
    tempstream.Seek(0,  soFromBeginning);
    DataModuleClient.PlanDataD_Bals.SavetoStream(tempstream);
    end;
  // get the balances to Tempbalances
  I := DaysInyear(Baldate);
  tempstream.Seek(0,  soFromBeginning);
  if (tempstream.read(tempBalances, Sizeof(currency) * I) > 0) then
    begin
    daystostart := DaysfromYearStart(BalDate);
    // set the new balance
    tempbalances[daystostart] := Balance;
    // send back to stream
    tempstream.seek(0, soFromBeginning);
    tempstream.Write(tempbalances, Sizeof(currency) * I);
    end;
  DataModuleClient.PlanDataD_Bals.LoadFromStream(tempstream);
  DataModuleClient.PlanData.Post;
  tempstream.Free;
end;

procedure TDataCollector.getPlanningData;
var
  J: Integer;
  cn : integer;
  PlanDataRec : TPlanDataRecPtr;
  Lastdate : TDateTime;
begin
  if Assigned(PlanDataList) then
    begin
    if PlanDataList.Count > 0 then
      ClearPlanDataList;
    end;
  if not Assigned(PlanDataList) then
    PlanDataList := Tlist.create;
  DetailedTotal := false;
  // What period is selected
  DataModuleClient.DateRef.first;
  // If Consolidated we must sort these dates by Period End Date and
  // increment J only when the Period end date changes.
  if (ConsolidList.count > 1) then
    begin
    DataModuleClient.DateRef.Active := False;
    DataModuleClient.DateRef.IndexName := 'ENDDATEIDX';
    DataModuleClient.Dateref.Filter := '';
    DataModuleClient.Dateref.Filtered := False;
    DataModuleClient.DateRef.Active := True;
    end
  else
    begin
    DataModuleClient.DateRef.Active := False;
    DataModuleClient.Dateref.Filter := 'Dept_ID = ' + inttostr(DataModuleClient.DepartmentsDEPT_ID.value);
    DataModuleClient.Dateref.Filtered := True;
    DataModuleClient.DateRef.Active := True;
   end;
  J := 0;
  Lastdate := 0;
  while DataModuleClient.DateRef.eof = False do
    begin
    if (LastDate <> DataModuleClient.DateRefEndDate.value) or (ConsolidList.count = 1) then
      inc(j);
    LastDate := DataModuleClient.DateRefEndDate.value;
    DataModuleClient.DateRef.edit;
    DataModuleClient.DateRefD_Index.value := j;
    DataModuleClient.DateRef.post;
    DataModuleClient.DateRef.Next;
    end;    // while
  if (ConsolidList.count > 1) then
    DataModuleClient.DateRef.IndexName := 'RDB$PRIMARY7';
  DataModuleClient.DateRangers.Refresh;

  for cn := 0 to integer(Trunc(sizeof(SummaryPlan)/sizeof(integer)) - 1) do
    begin
    new(PlanDatarec);
    FillChar(PlanDatarec^, sizeof(TPlanDataRecType), #0);
    // Get Account Titles
    PlanDatarec.Accountno := SummaryPlan[cn];
    if PlanDataRec.AccountNo < 10000 then
      begin
      if not getAccountTitle(@PlanDatarec^.AccountTitle, SummaryPlan[cn]) then
        strPcopy(PlanDatarec.AccountTitle, '');
      if not getAccountSubTitle(@PlanDatarec^.AccountSubTitle, SummaryPlan[cn]) then
        strPcopy(PlanDatarec.AccountSubTitle, '');
      // Get Past Balance
//      if PlanDatarec.Accountno = TOTALOTHEREXPENSES then
//        Ltotal := 0;
      getPastBalances(PlanDataRec.PastBalances, SummaryPlan[cn]);
//        PlanDataRec^.PastResult := 0;
      // Set psdate and pedate and get Plan Balances
      psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
      pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
      if not getBalances(PlanDataRec.PlanDetail, SummaryPlan[cn], True) then
        PlanDataRec.PlanTotal := 0
      else
        move(PlanDataRec.PlanDetail, PlanDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
      if (PlanDataRec.Accountno <> WHATIF) and (PlanDataRec.Accountno <> DETAILEDOPT) then
        begin
        PlanDataRec.PlanTotal := GetTotalBalance(
          PlanDataRec^.PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
        if (PlanDataRec.Accountno = FTEOTHER) or (PlanDataRec.Accountno = FTEPROD) then
          PlanDataRec.PlanTotal := PlanDataRec.PlanTotal / (Trunc(pedate - psdate) + 1);
        end;
      end;
    PlanDataList.Add(PlanDataRec);
    end;
  PlanLoaded := True;
end;

procedure TDataCollector.getMonitoringData;
var
//  SelectedDate: TDateTime;
//  J: Integer;
  cn : integer;
//  LTotal : currency;
  PlanDataRec : TPlanDataRecPtr;
begin
  if Assigned(MonitoringDataList) then
    begin
    if MonitoringDataList.Count > 0 then
      ClearMonitoringDataList;
    end;
  if not Assigned(MonitoringDataList) then
    MonitoringDataList := Tlist.create;
  DetailedTotal := false;
  for cn := 0 to integer(Trunc(sizeof(MonitoringSalesAccounts)/sizeof(integer)) - 1) do
    begin
    new(PlanDatarec);
    FillChar(PlanDatarec^, sizeof(TPlanDataRecType), #0);
    // Get Account Titles
    PlanDatarec.Accountno := MonitoringSalesAccounts[cn];
    if PlanDataRec.AccountNo < 10000 then
      begin
      if not getAccountTitle(@PlanDatarec^.AccountTitle, MonitoringSalesAccounts[cn]) then
        strPcopy(PlanDatarec.AccountTitle, '');
      if not getAccountSubTitle(@PlanDatarec^.AccountSubTitle, MonitoringSalesAccounts[cn]) then
        strPcopy(PlanDatarec.AccountSubTitle, '');
      // Get Past Balance
//      if PlanDatarec.Accountno = TOTALOTHEREXPENSES then
//        Ltotal := 0;
//      getPastBalances(PlanDataRec.PastBalances, SummaryPlan[cn]);
//        PlanDataRec^.PastResult := 0;
      // Set psdate and pedate and get Plan Balances
      psdate := DataModuleClient.DepartmentsCurrentMonitoringStart.value;
      pedate := DataModuleClient.DepartmentsCurrentMonitoringEnd.value;
      if not getBalances(PlanDataRec.PlanDetail, MonitoringSalesAccounts[cn], False) then
        PlanDataRec.PlanTotal := 0
      else
        move(PlanDataRec.PlanDetail, PlanDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
      PlanDataRec.PlanTotal := GetTotalBalance(
          PlanDataRec^.PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
      if (PlanDataRec.Accountno = FTEOTHER) or (PlanDataRec.Accountno = FTEPROD) then
        PlanDataRec.PlanTotal := PlanDataRec.PlanTotal / (Trunc(pedate - psdate) + 1);
      end;
    MonitoringDataList.Add(PlanDataRec);
    end;
  MonitoringLoaded := True;
end;

procedure TDataCollector.getReportData;
var
//  SelectedDate: TDateTime;
  J: Integer;
  cn : integer;
//  LTotal : currency;
  ReportDataRec : TReportDataRecPtr;
  PlanDetail: TDetailedBalArray;
  LastDate : TDateTime;
begin
  if Assigned(ReportDataList)
    then begin
    if ReportDataList.Count > 0 then
      ClearReportDataList;
  end;
  if not Assigned(ReportDataList) then
    ReportDataList := Tlist.create;
  DetailedTotal := false;

  // What period is selected
  DataModuleClient.DateRef.first;
  if (ConsolidList.count > 1) then
    DataModuleClient.DateRef.IndexName := 'ENDDATEIDX';
  J := 0;
  Lastdate := 0;
  while DataModuleClient.DateRef.eof = False do
  begin
    if (LastDate <> DataModuleClient.DateRefEndDate.value) or (ConsolidList.count = 1) then
      inc(j);
    LastDate := DataModuleClient.DateRefEndDate.value;
    DataModuleClient.DateRef.edit;
    DataModuleClient.DateRefD_Index.value := j;
    DataModuleClient.DateRef.post;
    DataModuleClient.DateRef.Next;
  end;    // while
  if (ConsolidList.count > 1) then
    DataModuleClient.DateRef.IndexName := 'RDB$PRIMARY7';
  DataModuleClient.DateRangers.Refresh;
  for cn := 0 to integer(Trunc(sizeof(KeyReportAccounts)/sizeof(integer)) - 1)
    do begin
    new(ReportDatarec);
    FillChar(ReportDatarec^, sizeof(TReportDataRecType), #0);
    // Get Account Titles
    ReportDatarec.Accountno := KeyReportAccounts[cn];
    ReportDataRec.Annualise := True;
    ReportDataRec.FormatImage := REPORTROUNDCURRENCY;
    ReportDataRec.Symbol := '';
    if ReportDataRec.AccountNo < 10000
      then begin
      if not getAccountTitle(@ReportDatarec^.AccountTitle, KeyReportAccounts[cn]) then
        strPcopy(ReportDatarec.AccountTitle, '');
//      if not getAccountSubTitle(@ReportDatarec^.AccountSubTitle, KeyReportAccountsPlan[cn]) then
//        strPcopy(ReportDatarec.AccountSubTitle, '');
      // Get Past Balance
      getPastBalances(ReportDataRec.PastBalances, KeyReportAccounts[cn]);
      // Set psdate and pedate and get Plan Balances
      psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
      pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
      FillChar(PlanDetail, Sizeof(TDetailedBalArray), #0);
      if not getBalances(PlanDetail, KeyReportAccounts[cn], True) then
        ReportDataRec.PlanTotal := 0
      else begin
        ReportDataRec.PlanTotal := GetTotalBalance(
          PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
        if (ReportDataRec.Accountno = FTEOTHER) or (ReportDataRec.Accountno = FTEPROD) then
          ReportDataRec.PlanTotal := ReportDataRec.PlanTotal / (Trunc(pedate - psdate) + 1);
      end;
    end;
    ReportDataList.Add(ReportDataRec);
  end;
  CalculateReportData;
end;

procedure TCashFlowEngine.getCashFlowData;
var
  J: Integer;
  cn : integer;
  CashflowDataRec : TCashFlowRecPtr;
  PlanDetail: TDetailedBalArray;
  LastDate : TDateTime;
  HasPriorBalance : Boolean;
begin
  if Assigned(CashFlowDataList) then
    begin
    if CashFlowDataList.Count > 0 then
      ClearCashFlowDataList;
    end;
  if not Assigned(CashFlowDataList) then
    CashFlowDataList := Tlist.create;
//  DetailedTotal := false;

  // What period is selected
  DataModuleClient.DateRef.first;
  if (ConsolidList.count > 1) then
    DataModuleClient.DateRef.IndexName := 'ENDDATEIDX';
  J := 0;
  Lastdate := 0;
  while DataModuleClient.DateRef.eof = False do
  begin
    if (LastDate <> DataModuleClient.DateRefEndDate.value) or (ConsolidList.count = 1) then
      inc(j);
    LastDate := DataModuleClient.DateRefEndDate.value;
    DataModuleClient.DateRef.edit;
    DataModuleClient.DateRefD_Index.value := j;
    DataModuleClient.DateRef.post;
    DataModuleClient.DateRef.Next;
  end;    // while
  if (ConsolidList.count > 1) then
    DataModuleClient.DateRef.IndexName := 'RDB$PRIMARY7';
  DataModuleClient.DateRangers.Refresh;
  for cn := 0 to integer(Trunc(sizeof(CashFlowMain)/sizeof(integer)) - 1) do
    begin
    new(CashFlowDatarec);
    FillChar(CashFlowDatarec^, sizeof(TCashFlowRecType), #0);
    // Get Account Titles
    CashFlowDatarec.Accountno := CashFlowMain[cn];
    CashFlowDataRec.FormatImage := REPORTROUNDCURRENCY;
//    ReportDataRec.Symbol := '';
    psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
    pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
    // These are the balance sheet accounts
    // so we get any opening balance which is the day before the current plan dat
    if CashFlowDataRec.AccountNo <= EQUITY then
      begin
      getPlanBalanceonDateEx((psdate - 1), CashFlowDataRec.AccountNo, CashflowDataRec.OpeningBalance, HasPriorBalance);
      CashFlowDataRec.DiskBalance := CashflowDataRec.OpeningBalance;
      if HasPriorBalance then
        CashflowDataRec.InitialBalance := False
      else
        CashflowDataRec.InitialBalance := True;
      end;
      if not DataCollect.getAccountTitle(@CashFlowDatarec^.AccountTitle, CashFlowMain[cn]) then
        strPcopy(CashFlowDatarec.AccountTitle, '');
      FillChar(PlanDetail, Sizeof(TDetailedBalArray), #0);
      if not DataCollect.getBalances(PlanDetail, CashFlowMain[cn], True) then
        CashFlowDataRec.PlanTotal := 0
      else
        begin
        CashFlowDataRec.PlanTotal := DataCollect.GetTotalBalance(
          PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
        move(CashFlowDataRec.PlanDetail, CashFlowDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
        end;
    CashFlowDataList.Add(CashFlowDataRec);
    end;
//  CalculateReportData;
end;

procedure TDataCollector.getTrackingkeyData(Sumcum : Boolean; StartDate, EndDate, perstart: TDate; SummaryType: integer);
var
  DetailEnd: Integer;
//  NoofPeriods: Integer;
  I: Integer;
//  SelectedDate: TDateTime;
  J: Integer;
  cn : integer;
//  LTotal : currency;
  ReportDataRec : TReportDataRecPtr;
  WagesRec : TReportDataRecPtr;
//  PlanDetail: TDetailedBalArray;
  SubTitle : array[0..120] of char;
begin
  if Assigned(ReportDataList)
    then begin
    if ReportDataList.Count > 0 then
      ClearReportDataList;
  end;
  if not Assigned(ReportDataList) then
    ReportDataList := Tlist.create;
  DetailedTotal := false;

  for cn := 0 to integer(Trunc(sizeof(KeyReportAccounts)/sizeof(integer)) - 1)
    do begin
    new(ReportDatarec);
    FillChar(ReportDatarec^, sizeof(TReportDataRecType), #0);
    // Get Account Titles
    ReportDatarec.Accountno := KeyReportAccounts[cn];
    ReportDataRec.Annualise := False;
    ReportDataRec.FormatImage := REPORTROUNDCURRENCY;
    ReportDataRec.Accumulate := False;
    if reportDataRec.accountNo = SALES then
      ReportDataRec.Symbol := '';

    ReportDataRec.Symbol := '';
    if ReportDataRec.AccountNo < 10000
      then begin
      ReportDataRec.accumulate := Sumcum;
      if (ReportDataRec.Accountno = FTEProd) or (ReportDataRec.Accountno = FTEOTHER) then
        ReportDataRec.accumulate := False;
      if not getAccountTitle(@ReportDatarec^.AccountTitle, KeyReportAccounts[cn]) then
        strPcopy(ReportDatarec.AccountTitle, '');
//      if not getAccountSubTitle(@ReportDatarec^.AccountSubTitle, KeyReportAccountsPlan[cn]) then
//        strPcopy(ReportDatarec.AccountSubTitle, '');
      // Get Past Balance
//      getPastBalances(ReportDataRec.PastBalances, KeyReportAccounts[cn]);
      // Set psdate and pedate and get Plan Balances
      psdate := DataModuleClient.DepartmentsCurrentMonitoringStart.value;
      pedate := DataModuleClient.DepartmentsCurrentMonitoringEnd.value;
// get actual data
      if not getBalances(ReportDataRec^.MonDetail, KeyReportAccounts[cn], False)
        then begin
        ReportDataRec.TrackBalances[trytdactual] := 0;
        ReportDataRec.TrackBalances[trperactual] := 0;
      end
      else begin
        ReportDataRec.TrackBalances[trytdactual] := GetTotalBalance(
          ReportDataRec^.MonDetail,
          double(StartDate),
          double(StartDate),
          double(EndDate));
        if (ReportDataRec.Accountno = FTEOTHER) or (ReportDataRec.Accountno = FTEPROD) then
          ReportDataRec.TrackBalances[trytdactual] := ReportDataRec.TrackBalances[trytdactual] / (Trunc(EndDate - StartDate) + 1);

        ReportDataRec.TrackBalances[trperactual] := GetTotalBalance(
          ReportDataRec^.MonDetail,
          double(perstart),
          double(StartDate),
          double(EndDate));
        if (ReportDataRec.Accountno = FTEOTHER) or (ReportDataRec.Accountno = FTEPROD) then
          ReportDataRec.TrackBalances[trperactual] := ReportDataRec.TrackBalances[trperactual] / (Trunc(EndDate - perstart) + 1);
      end;

// get Plan data
      if not getBalances(ReportDataRec^.PlanDetail, KeyReportAccounts[cn], True)
        then begin
        ReportDataRec.TrackBalances[trytdPlan] := 0;
        ReportDataRec.TrackBalances[trperPlan] := 0;
      end
      else begin
        ReportDataRec.TrackBalances[trytdPlan] := GetTotalBalance(
          ReportDataRec^.PlanDetail,
          double(StartDate),
          double(StartDate),
          double(EndDate));
        if (ReportDataRec.Accountno = FTEOTHER) or (ReportDataRec.Accountno = FTEPROD) then
          ReportDataRec.TrackBalances[trytdPlan] := ReportDataRec.TrackBalances[trytdPlan] / (Trunc(EndDate - StartDate) + 1);
        ReportDataRec.TrackBalances[trperPlan] := GetTotalBalance(
          ReportDataRec^.PlanDetail,
          double(perstart),
          double(StartDate),
          double(EndDate));
        if (ReportDataRec.Accountno = FTEOTHER) or (ReportDataRec.Accountno = FTEPROD) then
          ReportDataRec.TrackBalances[trperPlan] := ReportDataRec.TrackBalances[trperplan] / (Trunc(EndDate - perstart) + 1);
      end;
    end;
    ReportDataList.Add(ReportDataRec);
  end;
  New(WagesRec);
  // get Wages balances
  for I := 21 to 99 do    // Iterate
    begin
    if getAccountSubTitle(SubTitle, I) and (Subtitle[0] = 'W')
      then begin
      FillChar(Wagesrec^, sizeof(TReportDataRecType), #0);
      WagesRec.Accumulate := sumcum;
      // Get Account Titles
      if not getBalances(WagesRec^.MonDetail, I, False)
        then begin
        WagesRec.TrackBalances[trytdactual] := 0;
        WagesRec.TrackBalances[trperactual] := 0;
      end
      else begin
        WagesRec.TrackBalances[trytdactual] := GetTotalBalance(
          WagesRec^.MonDetail,
          double(StartDate),
          double(StartDate),
          double(EndDate));
        WagesRec.TrackBalances[trperactual] := GetTotalBalance(
          WagesRec^.MonDetail,
          double(perstart),
          double(StartDate),
          double(EndDate));
      end;

// get Plan data
      if not getBalances(WagesRec^.PlanDetail, I, True)
        then begin
        WagesRec.TrackBalances[trytdPlan] := 0;
        WagesRec.TrackBalances[trperPlan] := 0;
      end
      else begin
        WagesRec.TrackBalances[trytdPlan] := GetTotalBalance(
          WagesRec^.PlanDetail,
          double(StartDate),
          double(StartDate),
          double(EndDate));
        WagesRec.TrackBalances[trperPlan] := GetTotalBalance(
          WagesRec^.PlanDetail,
          double(perstart),
          double(StartDate),
          double(EndDate));
      end;
    end;
  end;
  // BuildSummary Data for Plan and Monitoring
  for I := 0 to ReportDataList.Count do    // Iterate
    begin
    if I < ReportDataList.count then
      ReportDataRec := ReportDataList.items[i]
    else
      ReportDataRec := WagesRec;
    BuildSummary(ReportDataRec.accountNo, False, ReportDataRec.PlanDetail, ReportDataRec^.PlanSummary);
    BuildSummary(ReportDataRec.accountNo, False, ReportDataRec.MonDetail, ReportDataRec^.MonSummary);
    if sumcum and ReportDataRec.Accumulate
      then begin
      if SummaryType = 0
        then begin
        DetailEnd := Trunc(DataModuleClient.DepartmentsCurrentMonitoringEnd.value
                - DataModuleClient.DepartmentsCurrentMonitoringStart.value) + 1;
        for J := 1 to DetailEnd do    // Iterate
          begin
          ReportDataRec.PlanDetail[J] := ReportDataRec.PlanDetail[J] + ReportDataRec.PlanDetail[J - 1];
          ReportDataRec.MonDetail[J] := ReportDataRec.MonDetail[J] + ReportDataRec.MonDetail[J - 1];
          end;    // for
      end
      else begin
        if Summarytype < 7 then
          Detailend := 1
        else
          Detailend := 0;
        while (SummaryPeriodIndexArray[Detailend] <> 0) and (Detailend < (NUM_WEEKS - 1)) do inc(Detailend);
        for J := 1 to DetailEnd do    // Iterate
          begin
          ReportDataRec.PlanSummary[J] := ReportDataRec.PlanSummary[J] + ReportDataRec.PlanSummary[J - 1];
          ReportDataRec.MonSummary[J] := ReportDataRec.MonSummary[J] + ReportDataRec.MonSummary[J - 1];
          end;    // for
      end;
    end;
  end;    // for
  CalculateMonitorKeyReportData(wagesRec, SummaryType, perstart, StartDate, EndDate);
  Dispose(WagesRec);
end;

procedure TDataCollector.getDetailedPLData(SumCUM : Boolean; StartDate, EndDate, perstart: TDate; SummaryType: integer);
var
  DetailEnd: Integer;
//  NoofPeriods: Integer;
  I: Integer;
  J: Integer;
  cn : integer;
  ReportDataRec : TReportDataRecPtr;
  ReportGP : TReportDataRecPtr;
  ReportTotalExp : TReportDataRecPtr;
  ReportNP : TReportDataRecPtr;
//  PlanDetail: TDetailedBalArray;
//  SubTitle : array[0..120] of char;
begin
  if Assigned(ReportDataList)
    then begin
    if ReportDataList.Count > 0 then
      ClearReportDataList;
  end;
  if not Assigned(ReportDataList) then
    ReportDataList := Tlist.create;
  DetailedTotal := false;
  Cn:= 0;
  while MonitoringAccountArray[cn] <> 0 do
    begin
    new(ReportDatarec);
    FillChar(ReportDatarec^, sizeof(TReportDataRecType), #0);
    // Get Account Titles
    ReportDatarec.Accountno := MonitoringAccountArray[cn];
    ReportDataRec.Annualise := False;
    ReportDataRec.FormatImage := REPORTROUNDCURRENCY;
    if reportDataRec.accountNo = SALES then
      ReportDataRec.Symbol := '';

    ReportDataRec.Symbol := '';
    if ReportDataRec.AccountNo < 10000
      then begin
      ReportDataRec.accumulate := Sumcum;
      if not getAccountTitle(@ReportDatarec^.AccountTitle, MonitoringAccountArray[cn]) then
        strPcopy(ReportDatarec.AccountTitle, '');
      psdate := DataModuleClient.DepartmentsCurrentMonitoringStart.Value;
      pedate := DataModuleClient.DepartmentsCurrentMonitoringEnd.Value;
// get actual data
      if not getBalances(ReportDataRec^.MonDetail, MonitoringAccountArray[cn], False)
        then begin
        ReportDataRec.TrackBalances[trytdactual] := 0;
        ReportDataRec.TrackBalances[trperactual] := 0;
      end
      else begin
        ReportDataRec.TrackBalances[trytdactual] := GetTotalBalance(
          ReportDataRec^.MonDetail,
          double(StartDate),
          double(StartDate),
          double(EndDate));

        ReportDataRec.TrackBalances[trperactual] := GetTotalBalance(
          ReportDataRec^.MonDetail,
          double(perstart),
          double(StartDate),
          double(EndDate));
      end;
// get Plan data
      if not getBalances(ReportDataRec^.PlanDetail, MonitoringAccountArray[cn], True)
        then begin
        ReportDataRec.TrackBalances[trytdPlan] := 0;
        ReportDataRec.TrackBalances[trperPlan] := 0;
      end
      else begin
        ReportDataRec.TrackBalances[trytdPlan] := GetTotalBalance(
          ReportDataRec^.PlanDetail,
          double(StartDate),
          double(StartDate),
          double(EndDate));
        ReportDataRec.TrackBalances[trperPlan] := GetTotalBalance(
          ReportDataRec^.PlanDetail,
          double(perstart),
          double(StartDate),
          double(EndDate));
      end;
    end;
    ReportDataList.Add(ReportDataRec);
    inc(cn);
  end;
  ReportGP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(GROSSPROFIT)]);
  ReportTotalExp := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(TOTALEXPENSES)]);
  ReportNP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(NETPROFIT)]);
  for I := 0 to trunc(EndDate - Startdate) do    // Iterate
    begin
    ReportNP.MonDetail[i] := ReportGP.monDetail[i] - ReportTotalExp.monDetail[i];
  end;    // for
  for I := 0 to ReportDataList.Count - 1 do    // Iterate
    begin
    ReportDataRec := ReportDataList.items[i];
    BuildSummary(ReportDataRec.accountNo, False, ReportDataRec.PlanDetail, ReportDataRec^.PlanSummary);
    BuildSummary(ReportDataRec.accountNo, False, ReportDataRec.MonDetail, ReportDataRec^.MonSummary);
    if sumcum and ReportDataRec.Accumulate
      then begin
      if SummaryType = 0
        then begin
        DetailEnd := Trunc(DataModuleClient.DepartmentsCurrentMonitoringEnd.value
                - DataModuleClient.DepartmentsCurrentMonitoringStart.value) + 1;
        for J := 1 to DetailEnd do    // Iterate
          begin
          ReportDataRec.PlanDetail[J] := ReportDataRec.PlanDetail[J] + ReportDataRec.PlanDetail[J - 1];
          ReportDataRec.MonDetail[J] := ReportDataRec.MonDetail[J] + ReportDataRec.MonDetail[J - 1];
          end;    // for
      end
      else begin
        if Summarytype < 7 then
          Detailend := 1
        else
          Detailend := 0;
        while (SummaryPeriodIndexArray[Detailend] <> 0) and (Detailend < (NUM_WEEKS - 1)) do inc(Detailend);
        for J := 1 to DetailEnd do    // Iterate
          begin
          ReportDataRec.PlanSummary[J] := ReportDataRec.PlanSummary[J] + ReportDataRec.PlanSummary[J - 1];
          ReportDataRec.MonSummary[J] := ReportDataRec.MonSummary[J] + ReportDataRec.MonSummary[J - 1];
          end;    // for
      end;
    end;
  end;    // for
  CalculateMonitorDPLReportData(SummaryType, perstart, StartDate, EndDate);
end;

function GetReportAccountIndex(accountNo : Integer): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to ReportDataList.Count - 1 do    // Iterate
    begin
    if TReportDataRecPtr(ReportDataList.Items[I]).Accountno = AccountNo then
      Result := I;
  end;    // for
end;

function TCashFlowEngine.GetCashFlowAccountIndex(accountNo : Integer): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to CashFlowDataList.Count - 1 do    // Iterate
    begin
    if TCashFlowRecPtr(CashFlowDataList.Items[I]).Accountno = AccountNo then
      Result := I;
  end;    // for
end;

procedure TDataCollector.CalculateKeys(TotalNoColumns, DetailedReportingPeriod: integer);
var
  I, J: Integer;
  SalesRec : TPlanDataRecPtr;
  GPRec : TPlanDataRecPtr;
  PotentialRec : TPlanDataRecPtr;
  BilledRec : TPlanDataRecPtr;
  HoursPerDayRec : TPlanDataRecPtr;
  DataRec : TPlanDataRecPtr;
  SingleUnit : String;
  PluralUnit : String;
begin
  if ConsolidList.Count <= 1
    then begin
    SingleUnit := DataModuleClient.DepartmentsSingular_unitDesc.Value;
    PluralUnit := DataModuleClient.DepartmentsPlural_unitDesc.value;
  end
  else begin
    SingleUnit := 'Unit';
    PluralUnit := 'Units';
  end;
  SalesRec := TPlanDataRecPtr(PlanDataList.Items[getaccountlistindex(SALES)]);
  GPRec := TPlanDataRecPtr(PlanDataList.Items[getaccountlistindex(GROSSPROFIT)]);
  PotentialRec := TPlanDataRecPtr(PlanDataList.Items[getaccountlistindex(POTENTIAL)]);
  BilledRec := TPlanDataRecPtr(PlanDataList.Items[getaccountlistindex(BILLED)]);
  HoursPerDayRec := TPlanDataRecPtr(PlanDataList.Items[getaccountlistindex(HRSPERDAY)]);
  for I := 0 to integer(Trunc(sizeof(KeyTargets)/sizeof(integer)) - 1) do    // Iterate
    begin
    DataRec := TPlanDataRecPtr(PlanDataList.Items[getaccountlistindex(KeyTargets[I])]);
    case KeyTargets[I] of    //
      GPPC: begin
            DataRec.FormatImage := REPORTTENSCURRENCY;
            StrPCopy(DataRec.AccountTitle, GPPCTITLE);
            if SalesRec.PlanTotal <> 0 then
              DataRec.PlanTotal := GPRec.PlanTotal * 100 / SalesRec.PlanTotal
            else
              DataRec.PlanTotal := 0;

            for J := 0 to TotalNoColumns - 2 do    // Iterate Don't do the Total Column
              begin
              if DetailedReportingPeriod = 0
                then begin
                if SalesRec.PlanDetail[J] <> 0 then
                  DataRec.PlanDetail[J] := GPRec.PlanDetail[J] * 100 / SalesRec.PlanDetail[J]
                else
                  DataRec.PlanDetail[J] := 0;
              end
              else begin
                if SalesRec.PlanSummary[J] <> 0 then
                  DataRec.PlanSummary[J] := GPRec.PlanSummary[J] * 100 / SalesRec.PlanSummary[J]
                else
                  DataRec.PlanSummary[J] := 0;
              end;
            end;
          end;
      PRODUCTIVITY: begin
            DataRec.FormatImage := REPORTTENSCURRENCY;
            StrPCopy(DataRec.AccountTitle, PRODUCTIVITYTITLE);
            if PotentialRec.PlanTotal <> 0 then
              DataRec.PlanTotal := BilledRec.PlanTotal * 100 / PotentialRec.PlanTotal
            else
              DataRec.PlanTotal := 0;

            for J := 0 to TotalNoColumns - 2 do    // Iterate Don't do the Total Column
              begin
              if DetailedReportingPeriod = 0
                then begin
                if PotentialRec.PlanDetail[J] <> 0 then
                  DataRec.PlanDetail[J] := BilledRec.PlanDetail[J] * 100 / PotentialRec.PlanDetail[J]
                else
                  DataRec.PlanDetail[J] := 0;
              end
              else begin
                if PotentialRec.PlanSummary[J] <> 0 then
                  DataRec.PlanSummary[J] := BilledRec.PlanSummary[J] * 100 / PotentialRec.PlanSummary[J]
                else
                  DataRec.PlanSummary[J] := 0;
              end;
            end;
            if SingleUnit = 'Hour'
              then begin
              StrPCopy(HoursPerDayRec.AccountTitle, HOURSPERDAYTITLE);
              HoursPerDayRec.FormatImage := 'Mins';
              HoursPerDayRec.Nonzero := True;
              HoursPerDayRec.PlanTotal := 480 * DataRec.PlanTotal / 6000;
              for J := 0 to TotalNoColumns - 2 do    // Iterate Don't do the Total Column
                begin
                if DetailedReportingPeriod = 0 then
                  HoursPerDayRec.PlanDetail[J] := 480 * DataRec.PlanDetail[J] / 6000
                else
                  HoursPerDayRec.PlanSummary[J] := 480 * DataRec.PlanSummary[J] / 6000;
              end;
            end;
          end;
      SALESUNIT: begin
            DataRec.FormatImage := REPORTCENTSCURRENCY;
            StrPCopy(DataRec.AccountTitle, SALESUNITTITLE + SingleUnit);
            if BilledRec.PlanTotal <> 0 then
              DataRec.PlanTotal := SalesRec.PlanTotal / BilledRec.PlanTotal
            else
              DataRec.PlanTotal := 0;

            for J := 0 to TotalNoColumns - 2 do    // Iterate Don't do the Total Column
              begin
              if DetailedReportingPeriod = 0
                then begin
                if BilledRec.PlanDetail[J] <> 0 then
                  DataRec.PlanDetail[J] := SalesRec.PlanDetail[J] / BilledRec.PlanDetail[J]
                else
                  DataRec.PlanDetail[J] := 0;
              end
              else begin
                if BilledRec.PlanSummary[J] <> 0 then
                  DataRec.PlanSummary[J] := SalesRec.PlanSummary[J] / BilledRec.PlanSummary[J]
                else
                  DataRec.PlanSummary[J] := 0;
              end;
            end;
          end;
      GPUNIT: begin
            DataRec.FormatImage := REPORTCENTSCURRENCY;
            StrPCopy(DataRec.AccountTitle, GPUNITTITLE + SingleUnit);
            if BilledRec.PlanTotal <> 0 then
              DataRec.PlanTotal := GPRec.PlanTotal / BilledRec.PlanTotal
            else
              DataRec.PlanTotal := 0;

            for J := 0 to TotalNoColumns - 2 do    // Iterate Don't do the Total Column
              begin
              if DetailedReportingPeriod = 0
                then begin
                if BilledRec.PlanDetail[J] <> 0 then
                  DataRec.PlanDetail[J] := GPRec.PlanDetail[J] / BilledRec.PlanDetail[J]
                else
                  DataRec.PlanDetail[J] := 0;
              end
              else begin
                if BilledRec.PlanSummary[J] <> 0 then
                  DataRec.PlanSummary[J] := GPRec.PlanSummary[J] / BilledRec.PlanSummary[J]
                else
                  DataRec.PlanSummary[J] := 0;
              end;
            end;
          end;
      POTENTIAL:  begin
                  DataRec.FormatImage := REPORTTENSCURRENCY;
                  StrPCopy(DataRec.AccountTitle, 'Potential Saleable ' + PluralUnit);
          end;
      BILLED:     begin
                  DataRec.FormatImage := REPORTTENSCURRENCY;
                  StrPCopy(DataRec.AccountTitle, 'Billed or Targeted ' + PluralUnit);
          end;
      HRSPERDAY: ;
      else begin
        DataRec.FormatImage := REPORTROUNDCURRENCY;
      end;
    end;    // case
  end;    // for
end;

procedure TDataCollector.CalculateReportData;
var
  J: Integer;
  I: Integer;
  ReportSales : TReportDataRecPtr;
  ReportGP : TReportDataRecPtr;
  ReportTotalExp : TReportDataRecPtr;
  ReportNP : TReportDataRecPtr;
  ReportPotential : TReportDataRecPtr;
  ReportBilled : TReportDataRecPtr;
  ReportFTEProd : TReportDataRecPtr;
  ReportFTEOther : TReportDataRecPtr;
  ReportHoursPerDay : TReportDataRecPtr;
  ReportData : TReportDataRecPtr;
  ReportWages : TReportDataRecPtr;
  SingleUnit : String;
  PluralUnit : String;
begin
  ReportSales := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(SALES)]);
  ReportGP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(GROSSPROFIT)]);
  ReportTotalExp := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(TOTALEXPENSES)]);
  ReportNP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(NETPROFIT)]);
  ReportPotential := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(POTENTIAL)]);
  ReportBilled := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(BILLED)]);
  ReportFTEProd := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(FTEPROD)]);
  ReportFTEOther := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(FTEOTHER)]);
  ReportHoursPerDay := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(HRSPERDAY)]);
  StrPCopy(ReportFteOther.AccountTitle, TOTALFTETITLE);
  ReportFTEOther.Annualise := False;
  ReportFTEOther.FormatImage := REPORTTENSCURRENCY;
  ReportFTEOther.Symbol := '';
  ReportFTEProd.Annualise := False;
  ReportFTEProd.FormatImage := REPORTTENSCURRENCY;
  ReportFTEProd.Symbol := '';

  // If Consoldated use 'Unit' as description
  if ConsolidList.Count <= 1
    then begin
    SingleUnit := DataModuleClient.DepartmentsSingular_unitDesc.Value;
    PluralUnit := DataModuleClient.DepartmentsPlural_unitDesc.value;
  end
  else begin
    SingleUnit := 'Unit';
    PluralUnit := 'Units';
  end;

  // Get Wages Total
  New(ReportWages);
  GetWages(ReportWages);
  for I := 0 to ReportDataList.Count - 1 do    // Iterate
    begin
    ReportData := TReportDataRecPtr(ReportDataList.Items[I]);
    if ReportData.AccountNo = POTENTIAL then
      StrPCopy(ReportData.AccountTitle, 'Potential ' + PluralUnit);
    if ReportData.AccountNo = BILLED then
      StrPCopy(ReportData.AccountTitle, 'Billed or Targeted ' + PluralUnit);

    if (ReportData.Accountno >= 10000) and (ReportData.Accountno <> TOTALFTE)
      then begin
      case ReportData.Accountno of    //
        SALESUNIT:
                  begin
                    StrPCopy(ReportData.AccountTitle, SALESUNITTITLE + SingleUnit);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    if ReportBilled.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportSales.PlanTotal / ReportBilled.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportBilled.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportSales.PastBalances[J] / ReportBilled.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        GPUNIT:
                  begin
                    StrPCopy(ReportData.AccountTitle, GPUNITTITLE + SingleUnit);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    if ReportBilled.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportGP.PlanTotal / ReportBilled.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportBilled.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportGP.PastBalances[J] / ReportBilled.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        GPPC:
                  begin
                    StrPCopy(ReportData.AccountTitle, GPPCTITLE);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    ReportData.Symbol := '%';
                    if ReportSales.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportGP.PlanTotal * 100 / ReportSales.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportSales.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportGP.PastBalances[J] * 100 / ReportSales.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        PRODUCTIVITY:
                  begin
                    StrPCopy(ReportData.AccountTitle, PRODUCTIVITYTITLE);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTTENSCURRENCY;
                    ReportData.Symbol := '%';
                    if ReportPotential.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportBilled.PlanTotal * 100 / ReportPotential.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportPotential.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportBilled.PastBalances[J] * 100 / ReportPotential.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                    if SingleUnit = 'Hour'
                      then begin
                      StrPCopy(ReportHoursPerDay.AccountTitle, HOURSPERDAYTITLE);
                      ReportHoursPerDay.Symbol := 'Mins';
                      ReportHoursPerDay.Annualise := False;
                      ReportHoursPerDay.FormatImage := REPORTTENSCURRENCY;
                      ReportHoursPerDay.PlanTotal := 480 * ReportData.PlanTotal / 6000;
                      for J := 0 to 4 do    // Iterate
                        ReportHoursPerDay.PastBalances[J] := 480 * ReportData.PastBalances[J] / 6000;
                    end;
                  end;
        TOTALEXPPC:
                  begin
                    StrPCopy(ReportData.AccountTitle, TOTALEXPPCTITLE);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    ReportData.Symbol := '%';
                    if ReportSales.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportTotalExp.PlanTotal * 100 / ReportSales.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportSales.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportTotalExp.PastBalances[J] * 100 / ReportSales.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        NPPC:
                  begin
                    StrPCopy(ReportData.AccountTitle, NPPCTITLE);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    ReportData.Symbol := '%';
                    if ReportSales.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportNP.PlanTotal * 100 / ReportSales.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportSales.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportNP.PastBalances[J] * 100 / ReportSales.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        TOTALEXPUNIT:
                  begin
                    StrPCopy(ReportData.AccountTitle, TOTALEXPUNITTITLE + SingleUnit);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    if ReportBilled.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportTotalExp.PlanTotal / ReportBilled.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportBilled.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportTotalExp.PastBalances[J] / ReportBilled.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        NPUNIT:
                  begin
                    StrPCopy(ReportData.AccountTitle, NPUNITTITLE + SingleUnit);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    if ReportBilled.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportNP.PlanTotal / ReportBilled.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportBilled.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportNP.PastBalances[J] / ReportBilled.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        SALESWAGE:
                  begin
                    StrPCopy(ReportData.AccountTitle, SALESWAGETITLE);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    if ReportWages.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportSales.PlanTotal / ReportWages.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportWages.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportSales.PastBalances[J] / ReportWages.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        GPWAGE:
                  begin
                    StrPCopy(ReportData.AccountTitle, GPWAGETITLE);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    if ReportWages.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportGP.PlanTotal / ReportWages.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportWages.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportGP.PastBalances[J] / ReportWages.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        NPWAGE:
                  begin
                    StrPCopy(ReportData.AccountTitle, NPWAGETITLE);
                    ReportData.Annualise := False;
                    ReportData.FormatImage := REPORTCENTSCURRENCY;
                    if ReportWages.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportNP.PlanTotal / ReportWages.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportWages.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportNP.PastBalances[J] / ReportWages.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        SALESFTE:
                  begin
                    StrPCopy(ReportData.AccountTitle, SALESFTETITLE);
                    ReportData.Annualise := True;
                    if ReportFTEOther.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportSales.PlanTotal / ReportFTEOther.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportFTEOther.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportSales.PastBalances[J] / ReportFTEOther.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        GPFTE:
                  begin
                    StrPCopy(ReportData.AccountTitle, GPFTETITLE);
                    ReportData.Annualise := True;
                    if ReportFTEOther.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportGP.PlanTotal / ReportFTEOther.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportFTEOther.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportGP.PastBalances[J] / ReportFTEOther.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
        NPFTE:
                  begin
                    StrPCopy(ReportData.AccountTitle, NPFTETITLE);
                    ReportData.Annualise := True;
                    if ReportFTEOther.PlanTotal <> 0 then
                      ReportData.PlanTotal := ReportNP.PlanTotal / ReportFTEOther.PlanTotal
                    else
                      ReportData.PlanTotal := 0;
                    for J := 0 to 4 do    // Iterate
                      begin
                      if ReportFTEOther.PastBalances[J] <> 0 then
                        ReportData.PastBalances[J] := ReportNP.PastBalances[J] / ReportFTEOther.PastBalances[J]
                      else
                        ReportData.PastBalances[J] := 0;
                    end;    // for
                  end;
      end;    // case
    end;
  end;    // for
  Dispose(ReportWages);
end;

procedure TDataCollector.CalculateMonitorKeyReportData(Mwages: TreportDataRecPtr; SummaryType : integer; perstart, Sdate, edate: TDateTime);
var
  I, k: Integer;
  ReportSales : TReportDataRecPtr;
  ReportGP : TReportDataRecPtr;
  ReportTotalExp : TReportDataRecPtr;
  ReportNP : TReportDataRecPtr;
  ReportPotential : TReportDataRecPtr;
  ReportBilled : TReportDataRecPtr;
  ReportFTEProd : TReportDataRecPtr;
  ReportFTEOther : TReportDataRecPtr;
  ReportHoursPerDay : TReportDataRecPtr;
  ReportData : TReportDataRecPtr;
  SingleUnit : String;
  PluralUnit : String;
  TrackBal : TTrackingBals;
//  Perioddays{, ytddays }: integer;
  DetailEnd, SummaryEnd : integer;
begin
  ReportSales := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(SALES)]);
  ReportGP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(GROSSPROFIT)]);
  ReportTotalExp := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(TOTALEXPENSES)]);
  ReportNP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(NETPROFIT)]);
  ReportPotential := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(POTENTIAL)]);
  ReportBilled := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(BILLED)]);
  ReportFTEProd := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(FTEPROD)]);
  ReportFTEOther := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(FTEOTHER)]);
  ReportHoursPerDay := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(HRSPERDAY)]);
  StrPCopy(ReportFteOther.AccountTitle, TOTALFTETITLE);
  ReportFTEOther.Annualise := False;
  ReportFTEOther.FormatImage := REPORTTENSCURRENCY;
  ReportFTEOther.Symbol := '';
  ReportFTEProd.Annualise := False;
  ReportFTEProd.FormatImage := REPORTTENSCURRENCY;
  ReportFTEProd.Symbol := '';

  // If Consoldated use 'Unit' as description
  if ConsolidList.Count <= 1
    then begin
    SingleUnit := DataModuleClient.DepartmentsSingular_unitDesc.Value;
    PluralUnit := DataModuleClient.DepartmentsPlural_unitDesc.value;
  end
  else begin
    SingleUnit := 'Unit';
    PluralUnit := 'Units';
  end;
  if ReportFTEProd.TrackBalances[trperactual] = 0 then
    ReportFTEProd.TrackBalances[trperactual] := ReportFTEProd.TrackBalances[trperPlan];
  if ReportFTEProd.TrackBalances[trytdactual] = 0 then
    ReportFTEProd.TrackBalances[trytdactual] := ReportFTEProd.TrackBalances[trytdPlan];
  if ReportFTEOther.TrackBalances[trperactual] = 0 then
    ReportFTEOther.TrackBalances[trperactual] := ReportFTEOther.TrackBalances[trperPlan];
  if ReportFTEOther.TrackBalances[trytdactual] = 0 then
    ReportFTEOther.TrackBalances[trytdactual] := ReportFTEOther.TrackBalances[trytdPlan];
  ReportNP.TrackBalances[trperactual] := ReportGP.TrackBalances[trperactual] - ReportTotalExp.TrackBalances[trperactual];
  ReportNP.TrackBalances[trytdactual] := ReportGP.TrackBalances[trytdactual] - ReportTotalExp.TrackBalances[trytdactual];
  DetailEnd := -1;
  SummaryEnd := -1;
  if SummaryType = 0 then
    DetailEnd := Trunc(DataModuleClient.DepartmentsCurrentMonitoringEnd.value
                - DataModuleClient.DepartmentsCurrentMonitoringStart.value) + 1
  else begin
    if Summarytype < 7 then
      I := 1
    else
      I := 0;
    while (SummaryPeriodIndexArray[I] <> 0) and (I < (NUM_WEEKS - 1)) do inc(I);
    SummaryEnd := I;
  end;
  if DetailEnd > 0
    then begin
    for k := 0 to DetailEnd - 1 do    // Iterate
      begin
      if ReportFTEProd.MonDetail[k] = 0 then
        ReportFTEProd.MonDetail[k] := ReportFTEProd.PlanDetail[k];
      if ReportFTEOther.MonDetail[k] = 0 then
        ReportFTEOther.MonDetail[k] := ReportFTEOther.PlanDetail[k];
      ReportNP.MonDetail[k] := ReportGP.monDetail[k] - ReportTotalExp.monDetail[K];
    end;
  end
  else begin
    for k := 0 to SummaryEnd - 1 do    // Iterate
      begin
      if ReportFTEProd.MonSummary[k] = 0 then
        ReportFTEProd.MonSummary[k] := ReportFTEProd.PlanSummary[k];
      if ReportFTEOther.MonSummary[k] = 0 then
        ReportFTEOther.MonSummary[k] := ReportFTEOther.PlanSummary[k];
      ReportNP.MonSummary[k] := ReportGP.monSummary[k] - ReportTotalExp.monSummary[K];
    end;
  end;
{  perioddays := Trunc(edate - perstart) + 1;
  ytddays := trunc(edate - sdate) + 1;
  if perioddays > 365 then
    perioddays := 365;
  if ytddays > 365 then
    ytddays := 365;
}
  for I := 0 to ReportDataList.Count - 1 do    // Iterate
    begin
    ReportData := TReportDataRecPtr(ReportDataList.Items[I]);
    if ReportData.AccountNo = POTENTIAL then
      StrPCopy(ReportData.AccountTitle, 'Potential ' + PluralUnit);
    if ReportData.AccountNo = BILLED then
      StrPCopy(ReportData.AccountTitle, 'Billed or Targeted ' + PluralUnit);
    if (ReportData.Accountno >= 10000) and (ReportData.Accountno <> TOTALFTE)
      then begin
      case ReportData.Accountno of    //
        SALESUNIT:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, SALESUNITTITLE + SingleUnit);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                    end;
                    if ReportBilled.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportSales.TrackBalances[Trackbal] / ReportBilled.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportSales.PlanDetail[k] / ReportBilled.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportBilled.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportSales.MonDetail[k] / ReportBilled.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportSales.PlanSummary[k] / ReportBilled.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportBilled.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportSales.MonSummary[k] / ReportBilled.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        GPUNIT:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, GPUNITTITLE + SingleUnit);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                    end;
                    if ReportBilled.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportGP.TrackBalances[Trackbal] / ReportBilled.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportGP.PlanDetail[k] / ReportBilled.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportBilled.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportGP.MonDetail[k] / ReportBilled.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportGP.PlanSummary[k] / ReportBilled.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportBilled.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportGP.MonSummary[k] / ReportBilled.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        GPPC:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, GPPCTITLE);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                      ReportData.Symbol := '%';
                    end;
                    if ReportSales.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportGP.TrackBalances[Trackbal] * 100 / ReportSales.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportSales.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportGP.PlanDetail[k] * 100 / ReportSales.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportSales.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportGP.MonDetail[k] * 100 / ReportSales.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportSales.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportGP.PlanSummary[k] * 100 / ReportSales.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportSales.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportGP.MonSummary[k] * 100 / ReportSales.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        PRODUCTIVITY:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, PRODUCTIVITYTITLE);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTTENSCURRENCY;
                      ReportData.Symbol := '%';
                    end;
                    if ReportPotential.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportBilled.TrackBalances[Trackbal] * 100 / ReportPotential.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                    if (SingleUnit = 'Hour')
                      then begin
                      StrPCopy(ReportHoursPerDay.AccountTitle, HOURSPERDAYTITLE);
                      ReportHoursPerDay.Symbol := 'Mins';
                      ReportHoursPerDay.Annualise := False;
                      ReportHoursPerDay.FormatImage := REPORTTENSCURRENCY;
                      ReportHoursPerDay.TrackBalances[Trackbal] := 480 * ReportData.TrackBalances[Trackbal] / 6000;
                    end;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportPotential.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportBilled.PlanDetail[k] * 100 / ReportPotential.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if (SingleUnit = 'Hour') then
                        ReportHoursPerDay.PlanDetail[k] := 480 * ReportData.PlanDetail[k] / 6000;
                      if ReportPotential.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportBilled.MonDetail[k] * 100 / ReportPotential.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                      if (SingleUnit = 'Hour') then
                        ReportHoursPerDay.MonDetail[k] := 480 * ReportData.MonDetail[k] / 6000;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportPotential.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportBilled.PlanSummary[k] * 100 / ReportPotential.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if (SingleUnit = 'Hour') then
                        ReportHoursPerDay.PlanSummary[k] := 480 * ReportData.PlanSummary[k] / 6000;
                      if ReportPotential.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportBilled.MonSummary[k] * 100 / ReportPotential.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                      if (SingleUnit = 'Hour') then
                        ReportHoursPerDay.MonSummary[k] := 480 * ReportData.MonSummary[k] / 6000;
                    end;
                  end;
                end;
        TOTALEXPPC:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, TOTALEXPPCTITLE);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                      ReportData.Symbol := '%';
                    end;
                    if ReportSales.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportTotalExp.TrackBalances[Trackbal] * 100 / ReportSales.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportSales.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportTotalExp.PlanDetail[k] * 100 / ReportSales.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportSales.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportTotalExp.MonDetail[k] * 100 / ReportSales.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportSales.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportTotalExp.PlanSummary[k] * 100 / ReportSales.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportSales.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportTotalExp.MonSummary[k] * 100 / ReportSales.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        NPPC:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, NPPCTITLE);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                      ReportData.Symbol := '%';
                    end;
                    if ReportSales.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportNP.TrackBalances[Trackbal] * 100 / ReportSales.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportSales.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportNP.PlanDetail[k] * 100 / ReportSales.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportSales.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportNP.MonDetail[k] * 100 / ReportSales.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportSales.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportNP.PlanSummary[k] * 100 / ReportSales.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportSales.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportNP.MonSummary[k] * 100 / ReportSales.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        TOTALEXPUNIT:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, TOTALEXPUNITTITLE + SingleUnit);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                    end;
                    if ReportBilled.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportTotalExp.TrackBalances[Trackbal] / ReportBilled.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportTotalExp.PlanDetail[k] / ReportBilled.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportBilled.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportTotalExp.MonDetail[k] / ReportBilled.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportTotalExp.PlanSummary[k] / ReportBilled.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportBilled.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportTotalExp.MonSummary[k] / ReportBilled.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        NPUNIT:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, NPUNITTITLE + SingleUnit);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                    end;
                    if ReportBilled.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportNP.TrackBalances[Trackbal] / ReportBilled.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportNP.PlanDetail[k] / ReportBilled.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportBilled.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportNP.MonDetail[k] / ReportBilled.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportBilled.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportNP.PlanSummary[k] / ReportBilled.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportBilled.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportNP.MonSummary[k] / ReportBilled.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        SALESWAGE:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, SALESWAGETITLE);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                    end;
                    if MWages.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportSales.TrackBalances[Trackbal] / MWages.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if MWages.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportSales.PlanDetail[k] / MWages.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if MWages.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportSales.MonDetail[k] / MWages.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if MWages.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportSales.PlanSummary[k] / MWages.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if MWages.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportSales.MonSummary[k] / MWages.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        GPWAGE:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, GPWAGETITLE);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                    end;
                    if MWages.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportGP.TrackBalances[Trackbal] / MWages.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if MWages.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportGP.PlanDetail[k] / MWages.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if MWages.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportGP.MonDetail[k] / MWages.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if MWages.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportGP.PlanSummary[k] / MWages.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if MWages.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportGP.MonSummary[k] / MWages.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        NPWAGE:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, NPWAGETITLE);
                      ReportData.Annualise := False;
                      ReportData.FormatImage := REPORTCENTSCURRENCY;
                    end;
                    if MWages.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportNP.TrackBalances[Trackbal] / MWages.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if MWages.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportNP.PlanDetail[k] / MWages.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if MWages.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportNP.MonDetail[k] / MWages.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if MWages.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportNP.PlanSummary[k] / MWages.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if MWages.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportNP.MonSummary[k] / MWages.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        SALESFTE:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, SALESFTETITLE);
                      ReportData.Annualise := True;
                    end;
                    if ReportFTEOther.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportSales.TrackBalances[Trackbal] / ReportFTEOther.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportFTEOther.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportSales.PlanDetail[k] / ReportFTEOther.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportFTEOther.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportSales.MonDetail[k] / ReportFTEOther.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportFTEOther.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportSales.PlanSummary[k] / ReportFTEOther.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportFTEOther.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportSales.MonSummary[k] / ReportFTEOther.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        GPFTE:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, GPFTETITLE);
                      ReportData.Annualise := True;
                    end;
                    if ReportFTEOther.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportGP.TrackBalances[Trackbal] / ReportFTEOther.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportFTEOther.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportGP.PlanDetail[k] / ReportFTEOther.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportFTEOther.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportGP.MonDetail[k] / ReportFTEOther.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportFTEOther.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportGP.PlanSummary[k] / ReportFTEOther.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportFTEOther.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportGP.MonSummary[k] / ReportFTEOther.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
        NPFTE:
                  begin
                  for TrackBal := trperactual to trytdplan do    // Iterate
                    begin
                    if trackBal = trperactual
                      then begin
                      StrPCopy(ReportData.AccountTitle, NPFTETITLE);
                      ReportData.Annualise := True;
                    end;
                    if ReportFTEOther.TrackBalances[Trackbal] <> 0 then
                      ReportData.TrackBalances[Trackbal] := ReportNP.TrackBalances[Trackbal] / ReportFTEOther.TrackBalances[Trackbal]
                    else
                      ReportData.TrackBalances[Trackbal] := 0;
                  end;
                  if DetailEnd > 0
                    then begin
                    for k := 0 to DetailEnd - 1 do    // Iterate
                      begin
                      if ReportFTEOther.PlanDetail[k] <> 0 then
                        ReportData.PlanDetail[k] := ReportNP.PlanDetail[k] / ReportFTEOther.PlanDetail[k]
                      else
                        ReportData.PlanDetail[k] := 0;
                      if ReportFTEOther.MonDetail[k] <> 0 then
                        ReportData.MonDetail[k] := ReportNP.MonDetail[k] / ReportFTEOther.MonDetail[k]
                      else
                        ReportData.MonDetail[k] := 0;
                    end;
                  end
                  else begin
                    for k := 0 to SummaryEnd - 1 do    // Iterate
                      begin
                      if ReportFTEOther.PlanSummary[k] <> 0 then
                        ReportData.PlanSummary[k] := ReportNP.PlanSummary[k] / ReportFTEOther.PlanSummary[k]
                      else
                        ReportData.PlanSummary[k] := 0;
                      if ReportFTEOther.MonSummary[k] <> 0 then
                        ReportData.MonSummary[k] := ReportNP.MonSummary[k] / ReportFTEOther.MonSummary[k]
                      else
                        ReportData.MonSummary[k] := 0;
                    end;
                  end;
                end;
      end;    // case
    end;
    if (ReportData.Accountno <> TOTALEXPENSES) and (ReportData.Accountno <> TOTALEXPPC)
      then begin
      ReportData.TrackBalances[trperVar] := ReportData.TrackBalances[trperActual] - ReportData.TrackBalances[trperPlan];
      ReportData.TrackBalances[trYtdVar] := ReportData.TrackBalances[trytdActual] - ReportData.TrackBalances[trytdPlan];
    end
    else begin
      ReportData.TrackBalances[trperVar] := ReportData.TrackBalances[trperPlan] - ReportData.TrackBalances[trperActual];
      ReportData.TrackBalances[trYtdVar] := ReportData.TrackBalances[trytdPlan] - ReportData.TrackBalances[trytdActual];
    end;
    if ReportData.Accountno = PRODUCTIVITY
      then begin
      if (SingleUnit = 'Hour')
        then begin
         ReportHoursPerDay.TrackBalances[trpervar] := 480 * ReportData.TrackBalances[trpervar] / 6000;
         ReportHoursPerDay.TrackBalances[trytdvar] := 480 * ReportData.TrackBalances[trytdvar] / 6000;
      end;
    end;
  end;    // for
end;

procedure TDataCollector.CalculateMonitorDPLReportData(SummaryType : integer; perstart, Sdate, edate: TDateTime);
var
  k: Integer;
  SummaryEnd: Integer;
  DetailEnd: Integer;
  I: Integer;
  ReportGP : TReportDataRecPtr;
  ReportTotalExp : TReportDataRecPtr;
  ReportNOP : TReportDataRecPtr;
  ReportOtherInc : TReportDataRecPtr;
  ReportNP : TReportDataRecPtr;
  ReportData : TReportDataRecPtr;
//  TrackBal : TTrackingBals;
begin
  ReportGP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(GROSSPROFIT)]);
  ReportTotalExp := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(TOTALEXPENSES)]);
  ReportNOP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(NETOPERATINGPROFIT)]);
  ReportOtherInc := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(OTHERINCOME)]);
  ReportNP := TReportDataRecPtr(ReportDataList.Items[GetReportAccountIndex(NETPROFIT)]);

  ReportNOP.TrackBalances[trperactual] := ReportGP.TrackBalances[trperactual] - ReportTotalexp.TrackBalances[trperactual];
  ReportNP.TrackBalances[trperactual] := ReportNOP.TrackBalances[trperactual] + ReportOtherInc.TrackBalances[trperactual];
  ReportNOP.TrackBalances[trperPlan] := ReportGP.TrackBalances[trperPlan] - ReportTotalexp.TrackBalances[trperPlan];
  ReportNP.TrackBalances[trperPlan] := ReportNOP.TrackBalances[trperPlan] + ReportOtherInc.TrackBalances[trperPlan];
  ReportNOP.TrackBalances[trYtdactual] := ReportGP.TrackBalances[trYtdactual] - ReportTotalexp.TrackBalances[trYtdactual];
  ReportNP.TrackBalances[trYtdactual] := ReportNOP.TrackBalances[trYtdactual] + ReportOtherInc.TrackBalances[trYtdactual];
  ReportNOP.TrackBalances[trYtdPlan] := ReportGP.TrackBalances[trYtdPlan] - ReportTotalexp.TrackBalances[trYtdPlan];
  ReportNP.TrackBalances[trYtdPlan] := ReportNOP.TrackBalances[trYtdPlan] + ReportOtherInc.TrackBalances[trYtdPlan];
  for I := 0 to ReportDataList.Count - 1 do    // Iterate
    begin
    ReportData := TReportDataRecPtr(ReportDataList.Items[I]);
    if (ReportData.Accountno < FIRSTEXPENSE) or (ReportData.AccountNo > TOTALEXPENSES)
      then begin
      ReportData.TrackBalances[trperVar] := ReportData.TrackBalances[trperActual] - ReportData.TrackBalances[trperPlan];
      ReportData.TrackBalances[trYtdVar] := ReportData.TrackBalances[trytdActual] - ReportData.TrackBalances[trytdPlan];
    end
    else begin
      ReportData.TrackBalances[trperVar] := ReportData.TrackBalances[trperPlan] - ReportData.TrackBalances[trperActual];
      ReportData.TrackBalances[trYtdVar] := ReportData.TrackBalances[trytdPlan] - ReportData.TrackBalances[trytdActual];
    end;
  end;    // for
  DetailEnd := -1;
  SummaryEnd := -1;
  if SummaryType = 0 then
    DetailEnd := Trunc(DataModuleClient.DepartmentsCurrentMonitoringEnd.value
                - DataModuleClient.DepartmentsCurrentMonitoringStart.value) + 1
  else begin
    if Summarytype < 7 then
      I := 1
    else
      I := 0;
    while (SummaryPeriodIndexArray[I] <> 0) and (I < (NUM_WEEKS - 1)) do inc(I);
    SummaryEnd := I;
  end;
  if DetailEnd > 0
    then begin
    for k := 0 to DetailEnd - 1
      do begin   // Iterate
      ReportNOP.MonDetail[k] := ReportGP.monDetail[k] - ReportTotalExp.monDetail[K];
      ReportNP.MonDetail[k] := ReportNOP.monDetail[k] - ReportOtherInc.monDetail[K];
    end;
  end
  else begin
    for k := 0 to SummaryEnd - 1
      do begin   // Iterate
      ReportNOP.MonSummary[k] := ReportGP.monSummary[k] - ReportTotalExp.monSummary[K];
      ReportNP.MonSummary[k] := ReportNOP.monSummary[k] - ReportOtherInc.monSummary[K];
    end;
  end;
end;

procedure TDataCollector.GetWages(ReportWages: TReportDataRecPtr);
var
  K: Integer;
  I: Integer;
  SubTitle : array[0..120] of char;
  PastBal : TPastBalances;
  PlanDetail : TDetailedBalArray;
begin
  FillChar(ReportWages^, sizeof(TReportDataRecType), #0);
  psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  for I := 21 to 99 do    // Iterate
    begin
    if getAccountSubTitle(SubTitle, I) and (Subtitle[0] = 'W')
      then begin
      FillChar(PastBal, Sizeof(TPastBalances), #0);
      getPastBalances(PastBal, I);
      for K := 0 to 4 do    // Iterate
        begin
        ReportWages.PastBalances[K] := ReportWages.PastBalances[K] + PastBal[K];
      end;    // for
      FillChar(PlanDetail, Sizeof(TDetailedBalArray), #0);
      // Set psdate and pedate and get Plan Balances
      if getBalances(PlanDetail, I, True) then
        ReportWages.PlanTotal := ReportWages.PlanTotal +
          GetTotalBalance(
          PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
    end;
  end;    // for
end;

procedure TDataCollector.ReloadPastBalances;
begin
end;

procedure TDataCollector.PutPastBalances;
var
  cn : integer;
  PlanDataRec : TPlanDataRecPtr;
begin
  for cn := 0 to PlanDataList.count - 1
    do begin
    PlanDatarec := PlanDataList.Items[cn];
    if PlanDataRec.PastBalances[DataModuleClient.DateRangersD_Index.value - 1] <> 0
      then setPastBalance(@PlanDataRec^.PastBalances[DataModuleClient.DateRangersD_Index.value - 1], PlanDatarec.Accountno)
    else
      ClearPastBalance(@PlanDataRec^.PastBalances[DataModuleClient.DateRangersD_Index.value - 1], PlanDatarec.Accountno);

    // Get Past Balances
//    getPastBalances(PlanDataRec.PastBalances, PlanDatarec.Accountno);
  end;
end;

procedure TDataCollector.getPlanningExpData(AdjustOtherExpenses : Boolean);
var
  I: Integer;
  cn : integer;
  PlanDataRec : TPlanDataRecPtr;
  PlanExpDataRec : TPlanDataRecPtr;
  TotalPastBalances : TPastBalances;
  TotalPlanBalance{, tempbal, tempbal1} : Currency;
  varg : variant;
//  cm : integer;
begin
  if Assigned(PlanExpDataList)
    then begin
    if PlanExpDataList.Count > 0 then
      ClearPlanExpDataList;
  end;
  if not Assigned(PlanExpDataList) then
    PlanExpDataList := Tlist.create;
  fillchar(DetailedArray, sizeof(TDetailedBalArray), #0);
  Fillchar(TotalPastBalances, sizeof(TPastBalances), #0);
//  TotalPastBalance := 0;
  TotalPlanBalance := 0;
  DetailedTotal := True;
  // Set psdate and pedate and get Plan Balances
  psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  for cn := FIRSTEXPENSE to TOTALOTHEREXPENSES
    do begin
    Varg := cn;
    if DataModuleClient.AccountDetails.Locate('Account_Number',varg,[])
      then begin
      new(PlanDatarec);
      FillChar(PlanDatarec^, sizeof(TPlanDataRecType), #0);
      PlanDatarec.Accountno := cn;
      // Get Account Titles
      if DataModuleClient.AccountDetailsNON_CASH.value > 0 then
        PlanDataRec.NonCash := True
      else
        PlanDataRec.NonCash := False;
      getAccountTitle(PlanDatarec^.AccountTitle, cn);
      if not getAccountSubTitle(@PlanDatarec^.AccountSubTitle, cn) then
        strPcopy(PlanDatarec.AccountSubTitle, '');
      if PlanDataRec.AccountSubTitle = 'W' then
        PlanDataRec.WagesCB := cbChecked
      else
        PlanDataRec.WagesCB := cbUnChecked;
      getPastBalances(PlanDataRec.PastBalances, cn);
      if cn <> TOTALOTHEREXPENSES then
        for I := 0 to 4 do    // Iterate
          TotalPastBalances[I] := TotalPastBalances[I] + PlanDataRec.PastBalances[I];

      if not getBalances(PlanDataRec.PlanDetail, cn, True) then
        PlanDataRec.PlanTotal := 0
      else
        move(PlanDataRec.PlanDetail, PlanDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
      PlanDataRec.PlanTotal := GetTotalBalance(
        PlanDataRec^.PlanDetail,
        double(psdate),
        double(psdate),
        double(pedate));
      TotalPlanBalance := TotalPlanBalance + PlanDataRec.PlanTotal;
      PlanExpDataList.Add(PlanDataRec);
    end;
  end;
  PlanExpLoaded := True;
  // get TotalExpenses to obtain past total and adjust plan total
  PlanDataRec := PlanDataList.Items[GetAccountListIndex(TOTALEXPENSES)];

  PlanExpDataRec := PlanExpDataList.Items[getExpAccountListIndex(TOTALOTHEREXPENSES)];
  // This account carries any difference for Past Result
  for I := 0 to 4 do
    PlanExpDataRec.PastBalances[I] := PlanDataRec.PastBalances[I] - TotalPastBalances[I];

  // if the total of planned expenses is not zero then the plan must agree with
  // the new total obtained unless AdjustOtherExpenses is True.
  if AdjustOtherExpenses
    then begin
    // now its time to adjust Total Other Expense
    updateArray(PlanExpDataRec.PlanDetail,
                  double(psdate),
                  double(psdate),
                  double(pedate),
                  PlanExpDataRec.PlanTotal + PlanDataRec.PlanTotal - TotalPlanBalance,
                  6);
  end
  else begin
    if TotalPlanBalance <> 0
      then begin
      move(DetailedArray, PlanDatarec.PlanDetail, sizeof(TDetailedBalArray));
      // now set the new total
      PlanDataRec.PlanTotal := GetTotalBalance(
        PlanDataRec^.PlanDetail,
        double(psdate),
        double(psdate),
        double(pedate));
    end
    else // make the temp array equal to the distribution in Total Expenses
      move(PlanDatarec.PlanDetail, DetailedArray, sizeof(TDetailedBalArray));

    if TotalPlanBalance = 0
      then begin
      move(DetailedArray, PlanDatarec.PlanDetail, sizeof(TDetailedBalArray));
      // now set the new total
      PlanDataRec.PlanTotal := GetTotalBalance(
        PlanDataRec^.PlanDetail,
        double(psdate),
        double(psdate),
        double(pedate));
    end;
  end;
  for cn := 0 to PlanExpDataList.count - 1 do    // Iterate
    begin
    PlanExpDataRec := PlanExpDataList.Items[cn];
    BuildSummary(PlanExpDataRec.accountNo, True, PlanExpDataRec.PlanDetail, PlanExpDataRec^.PlanSummary);
  end;
  sortExpenseList(True);
end;

procedure TDataCollector.getMonitoringExpData;
var
//  I: Integer;
  cn : integer;
  MonitorDataRec : TPlanDataRecPtr;
//  MonitorExpDataRec : TPlanDataRecPtr;
  varg : variant;
  TempTitle : array [0..60] of char;
  TempPlanTotal : currency;
  TempDetail: TDetailedBalArray;
  OldStr, Newstr : string;

//  cm : integer;
begin
  if Assigned(MonitoringExpDataList)
    then begin
    if MonitoringExpDataList.Count > 0 then
      ClearMonitorExpDataList;
  end;
  if not Assigned(MonitoringExpDataList) then
    MonitoringExpDataList := Tlist.create;
  fillchar(DetailedArray, sizeof(TDetailedBalArray), #0);
//  TotalPastBalance := 0;
  MonitoringExpLoaded := False;
  DetailedTotal := True;
  psdate := DataModuleClient.DepartmentsCurrentMonitoringStart.value;
  pedate := DataModuleClient.DepartmentsCurrentMonitoringEnd.value;
  for cn := FIRSTEXPENSE to TOTALEXPENSES
    do begin
    Varg := cn;
    if DataModuleClient.AccountDetails.Locate('Account_Number',varg,[])
      then begin
      fillchar(DetailedArray, sizeof(TDetailedBalArray), #0);
      StrPcopy(tempTitle , '');
      getAccountTitle(TempTitle, cn);
      if not getBalances(TempDetail, cn, True) then
        TempPlanTotal := 0
      else
        TempPlanTotal := GetTotalBalance(
        tempDetail,
        double(psdate),
        double(psdate),
        double(pedate));
      if (strlen(TempTitle) > 0) or (TempPlanTotal <> 0)
        then begin
        new(MonitorDatarec);
        FillChar(MonitorDatarec^, sizeof(TPlanDataRecType), #0);
        MonitorDatarec.Accountno := cn;
        // Get Account Titles
        OldStr := strpas(temptitle);
        if (Not SearchStr(OldStr, ' /')) and (Not SearchStr(OldStr, '/ ')) then
          Newstr := searchAndReplace(Oldstr, '/', ' / ')
        else
          NewStr := OldStr;
        strPcopy(MonitorDatarec^.AccountTitle, NewStr);
        if not getAccountSubTitle(@MonitorDatarec^.AccountSubTitle, cn) then
          strPcopy(MonitorDatarec.AccountSubTitle, '');
        if MonitorDataRec.AccountSubTitle = 'W' then
          MonitorDataRec.WagesCB := cbChecked
        else
          MonitorDataRec.WagesCB := cbUnChecked;
        getBalances(MonitorDatarec^.PlanDetail, cn, False);
//         then  TempPlanTotal := 0;
        move(MonitorDataRec.PlanDetail, MonitorDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
        MonitorDataRec.PlanTotal := GetTotalBalance(
          MonitorDataRec^.PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
        MonitoringExpDataList.Add(MonitorDataRec);
      end;
    end;
  if Cn = TOTALOTHEREXPENSES then
    sortExpenseList(False);
  end;
  MonitoringExpLoaded := True;
end;

function TDataCollector.GetUserOption(OptName: String; Otype : TUOType): Variant;
var
  varg, Varg1 : Variant;
begin
  varg := OptName;
  result := 0;
  if DataModuleClient.OptionNames.Locate('OPTION_NAME', Varg, []) then
    begin
    Varg1 := DataModuleClient.OptionNamesNAME_INDEX.Value;
    if DataModuleClient.UserOptions.Locate('NAMEINDEX', Varg1, []) then
      begin
      case Otype of    //
        UOInteger:
          Result := DataModuleClient.UserOptionsINTEGER_VALUE.value;
        UOCurrency:
          Result := DataModuleClient.UserOptionsCURRENCY_VALUE.value;
        UODate:
          Result := DataModuleClient.UserOptionsDATETIME_VALUE.Value;
        UOString:
          Result := DataModuleClient.UserOptionsSTRING_VALUE.Value;
        end;    // case
      end;
    end;
end;

function TDataCollector.SetUserOption(OptName: String; Otype : TUOType; Ovalue : Variant): Boolean;
var
  varg, Varg1 : Variant;
begin
  varg := OptName;
  result := False;
  if not DataModuleClient.OptionNames.Locate('OPTION_NAME', Varg, []) then
    begin
    DataModuleClient.OptionNames.Insert;
    DataModuleClient.OptionNamesOPTION_NAME.Value := Optname;
    DataModuleClient.OptionNames.Post;
    DataModuleClient.OptionNames.refresh;
    DataModuleClient.OptionNames.Locate('OPTION_NAME', Varg, []);
    end;

  Varg1 := DataModuleClient.OptionNamesNAME_INDEX.Value;
  if DataModuleClient.UserOptions.Locate('NAMEINDEX', Varg1, []) then
    DataModuleClient.UserOptions.Edit
  else
    begin
    DataModuleClient.UserOptions.Insert;
    DataModuleClient.UserOptionsOPTION_GROUP_ID.Value := DataModuleClient.DeptOptionsOPTION_GROUP_ID.Value;
    DataModuleClient.UserOptionsNAMEINDEX.Value := Varg1;
    end;
  case Otype of    //
    UOInteger:
      DataModuleClient.UserOptionsINTEGER_VALUE.value := Ovalue;
    UOCurrency:
      DataModuleClient.UserOptionsCURRENCY_VALUE.value := Ovalue;
    UODate:
      DataModuleClient.UserOptionsDATETIME_VALUE.Value := Ovalue;
    UOString:
      DataModuleClient.UserOptionsSTRING_VALUE.Value := OValue;
    end;    // case
  DataModuleClient.UserOptions.Post;
  DataModuleClient.UserOptions.Refresh;
  Result := True;
end;

{ ---------------------------------------------------------------------------- }
{ -- clearCashFlowDataList - Frees the memory allocated to items in the list   }
{                        and clears the list ready for reloading.          }
{ ---------------------------------------------------------------------------- }
procedure TCashFlowEngine.clearCashFlowDataList;
var
  index: integer;
  CashFlowDataRec: TCashFlowRecPtr;
begin
  if CashFlowLoaded then
    begin
    for index := 0 to CashFlowDataList.Count - 1 do
      begin
      CashFlowDataRec := TCashFlowRecPtr(CashFlowDataList.Items[index]);
      dispose(CashFlowDataRec);
//      PlanDataList.Delete(index);
      end;
    CashFlowDataList.clear;
//    PlandataList.free;
    end;
  CashFlowLoaded := False;
end;


{ ---------------------------------------------------------------------------- }
{ -- clearPlanDataList - Frees the memory allocated to items in the list   }
{                        and clears the list ready for reloading.          }
{ ---------------------------------------------------------------------------- }
procedure TDataCollector.clearPlanDataList;
var
  index: integer;
  PlanDataRec: TPlanDataRecPtr;
begin
  if PlanLoaded
    then begin
    for index := 0 to PlanDataList.Count - 1
      do begin
      PlanDataRec := TPlanDataRecPtr(PlanDataList.Items[index]);
      dispose(PlanDataRec);
//      PlanDataList.Delete(index);
    end;
    PlandataList.clear;
//    PlandataList.free;
  end;
  PlanLoaded := False;
end;

{ ---------------------------------------------------------------------------- }
{ -- clearMonitoringDataList - Frees the memory allocated to items in the list   }
{                        and clears the list ready for reloading.          }
{ ---------------------------------------------------------------------------- }
procedure TDataCollector.clearMonitoringDataList;
var
  index: integer;
  PlanDataRec: TPlanDataRecPtr;
begin
  if Assigned(MonitoringDataList)
    then begin
    for index := 0 to MonitoringDataList.Count - 1
      do begin
      PlanDataRec := TPlanDataRecPtr(MonitoringDataList.Items[index]);
      dispose(PlanDataRec);
    end;
    MonitoringDataList.clear;
    MonitoringDataList.free;
    MonitoringDataList := nil;
  end;
  MonitoringLoaded := False;
end;

{ ---------------------------------------------------------------------------- }
{ -- clearReportDataList - Frees the memory allocated to items in the list   }
{                        and clears the list ready for reloading.          }
{ ---------------------------------------------------------------------------- }
procedure TDataCollector.clearReportDataList;
var
  index: integer;
  ReportDataRec: TReportDataRecPtr;
begin
  if Assigned(ReportDataList)
    then begin
    for index := 0 to ReportDataList.Count - 1
      do begin
      ReportDataRec := TReportDataRecPtr(ReportDataList.Items[index]);
      dispose(ReportDataRec);
    end;
    ReportdataList.clear;
//    ReportdataList.free;
  end;
end;

{ ---------------------------------------------------------------------------- }
{ -- clearPlanExpDataList - Frees the memory allocated to items in the list   }
{                        and clears the list ready for reloading.          }
{ ---------------------------------------------------------------------------- }
procedure TDataCollector.clearPlanExpDataList;
var
  index: integer;
  PlanDataRec: TPlanDataRecPtr;
begin
  if Assigned(PlanExpDataList)
    then begin
    for index := 0 to PlanExpDataList.Count - 1
      do begin
      PlanDataRec := TPlanDataRecPtr(PlanExpDataList.Items[index]);
      dispose(PlanDataRec);
//      PlanExpDataList.delete(index);
    end;
    PlanExpdataList.clear;
//    PlanExpDataList.free;
  end;
  PlanExpLoaded := False;
end;

{ ---------------------------------------------------------------------------- }
{ -- clearPlanExpDataList - Frees the memory allocated to items in the list   }
{                        and clears the list ready for reloading.          }
{ ---------------------------------------------------------------------------- }
procedure TDataCollector.clearMonitorExpDataList;
var
  index: integer;
  MonitorDataRec: TPlanDataRecPtr;
begin
//  if MonitoringExpLoaded
//    then begin
    for index := 0 to MonitoringExpDataList.Count - 1
      do begin
      MonitorDataRec := TPlanDataRecPtr(MonitoringExpDataList.Items[index]);
      dispose(MonitorDataRec);
    end;
    MonitoringExpdataList.clear;
    MonitoringExpdataList.free;
    MonitoringExpDataList := Nil;
//    MonitoringExpLoaded := False;
//  end;
end;

procedure TDataCollector.setPlanningData;
var
  cn : integer;
  ltotal : currency;
  PlanDataRec : TPlanDataRecPtr;
begin
  //
  psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  for cn := 0 to PlanDataList.count - 1
    do begin
    PlanDataRec := PlanDataList.items[cn];
    if PlanDataRec.AccountNo < 10000
      then begin
      // Set Past Balance
//      if PlanDatarec.Accountno = TOTALOTHEREXPENSES then
//        Ltotal := 0;
      if PlanDataRec.PastBalances[DataModuleClient.DateRangersD_Index.value - 1] <> 0
        then setPastBalance(@PlanDataRec^.PastBalances[DataModuleClient.DateRangersD_Index.value - 1], PlanDatarec.Accountno)
      else
        ClearPastBalance(@PlanDataRec^.PastBalances[DataModuleClient.DateRangersD_Index.value - 1], PlanDatarec.Accountno);
      // Set Plan Balances
      //Update Array with Total
      if (PlanDataRec.Accountno <> WHATIF) and (PlanDataRec.Accountno <> DETAILEDOPT)
        then begin
        ltotal := GetTotalBalance(
          PlanDataRec^.PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
        if (PlanDataRec.Accountno = FTEOTHER) or (PlanDataRec.Accountno = FTEPROD) then
          ltotal := ltotal / (Trunc(pedate - psdate) + 1);

        if (PlanDataRec.PlanTotal <>  ltotal)
          then begin
          if (PlanDataRec.Accountno = FTEOTHER) or (PlanDataRec.Accountno = FTEPROD) then
            PlanDataRec.planTotal := PlanDataRec.PlanTotal * (Trunc(pedate - psdate) + 1);
          if (GGlobals.UnitRounding = 0)
            and ((PlanDataRec.Accountno = BILLED) or (PlanDataRec.Accountno = BILLED))  then
            updateArray(  PlanDataRec.PlanDetail,
                  double(psdate),
                  double(psdate),
                  double(pedate),
                  PlanDataRec.PlanTotal,
                  0)
          else
            updateArray(  PlanDataRec.PlanDetail,
                  double(psdate),
                  double(psdate),
                  double(pedate),
                  PlanDataRec.PlanTotal,
                  6);
        end;
      end;
      if CompareMem(pointer(@PlanDataRec.PlanDetail), Pointer(@PlanDataRec.PlanDetailDisk), Sizeof(currency) * NUM_DAYSINYEAR) = False
        then begin
        setBalances(PlanDataRec.PlanDetail, PlanDatarec.Accountno, True);
        move(PlanDataRec.PlanDetail, PlanDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
        end;
    end;
  end;
end;

procedure TCashFlowEngine.setCashFlowData;
var
  cn : integer;
  CashFlowDataRec : TCashFlowRecPtr;
begin
  //
  psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  for cn := 0 to CashFlowDataList.count - 1 do
    begin
    CashFlowDataRec := CashFlowDataList.items[cn];
    // we have possibly an opening balance to store
    if CashFlowDataRec.AccountNo <= EQUITY then
      begin
      if CashFlowDatarec.InitialBalance and (CashFlowDataRec.OpeningBalance <> CashFlowDataRec.DiskBalance) then // store it
        SetPlanBalanceonDateEx((psdate - 1), CashFlowDataRec.Accountno, CashflowDataRec.OpeningBalance);
      end;
    if CompareMem(pointer(@CashFlowDataRec.PlanDetail), Pointer(@CashFlowDataRec.PlanDetailDisk), Sizeof(currency) * NUM_DAYSINYEAR) = False
      then begin
      DataCollect.setBalances(CashFlowDataRec.PlanDetail, CashFlowDatarec.Accountno, True);
      move(CashFlowDataRec.PlanDetail, CashFlowDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
      end;
    end;
end;

procedure TDataCollector.setMonitoringData;
var
  cn, J, K : integer;
  PlanDataRec : TPlanDataRecPtr;
  FirstMDate, LastMDate : Integer;
begin
  psdate := DataModuleClient.DepartmentsCurrentMonitoringStart.value;
  pedate := DataModuleClient.DepartmentsCurrentMonitoringEnd.value;
  K := Trunc(pedate) - trunc(psdate) + 1;
  FirstMdate := k + 1;
  LastMdate := -1;
  for cn := 0 to MonitoringDataList.count - 1
    do begin
    PlanDataRec := MonitoringDataList.items[cn];
    if PlanDataRec.AccountNo < 10000
      then begin
      // Set Past Balance
//      if PlanDatarec.Accountno = TOTALOTHEREXPENSES then
//        Ltotal := 0;
      // Set Plan Balances
      //Update Array with Total
      if PlanDataRec.AccountNo < 2000
        then begin
        J := k;
        while (PlanDataRec.PlanDetail[J] = 0) and (J >= 0) do
          dec(j);
        if J > LastMdate then LastMDate := J;
        J := 0;
        while (PlanDataRec.PlanDetail[J] = 0) and (J < K) do
          inc(j);
        if J < FirstMdate then FirstMDate := J;
      end;
      if CompareMem(pointer(@PlanDataRec.PlanDetail), Pointer(@PlanDataRec.PlanDetailDisk), Sizeof(currency) * NUM_DAYSINYEAR) = False
        then begin
        setBalances(PlanDataRec.PlanDetail, PlanDatarec.Accountno, False);
        move(PlanDataRec.PlanDetail, PlanDatarec.PlanDetaildisk, sizeof(TDetailedBalArray));
        end;
    end;
  end;
  // Update LastMonitored Date in Department
  DataModuleClient.Departments.edit;
  // if no data but the FirstMonitoringDate is the current period, delete both
  if (LastMDate = -1) and (DataModuleClient.DepartmentsFirstMonitoringdate.value >= psdate)
    then begin
    DataModuleClient.DepartmentsLast_Monitored.Clear;
    DataModuleClient.DepartmentsFirstMonitoringDate.Clear
  end
  else begin
    if (LastMDate > -1) and (DataModuleClient.DepartmentsLast_Monitored.value < (psdate + LastMdate))
      then DataModuleClient.DepartmentsLast_Monitored.value := psdate + LastMDate;
    if (FirstMDate < (K + 1))
     and ((DataModuleClient.DepartmentsFirstMonitoringDate.value > (psdate + FirstMDate))
     or (DataModuleClient.DepartmentsFirstMonitoringDate.IsNull))
      then DataModuleClient.DepartmentsFirstMonitoringDate.value := psdate + FirstMDate;
  end;
  DataModuleClient.Departments.Post;
end;

// This procedure restores values
// from the file overwriting values currently held in memory.
// It excludes past data values as they are direct.
procedure TDataCollector.RefreshPlanningData;
var
  cn : integer;
  PlanDataRec : TPlanDataRecPtr;
begin
  //
  psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  for cn := 0 to PlanDataList.count - 1
    do begin
    PlanDataRec := PlanDataList.items[cn];
    if PlanDataRec.AccountNo < 10000
      then begin
      move(PlanDataRec.PlanDetailDisk, PlanDatarec.PlanDetail, sizeof(TDetailedBalArray));
      if PlanDataRec.Accountno <> WHATIF
        then PlanDataRec.PlanTotal := GetTotalBalance(
          PlanDataRec^.PlanDetail,
          double(psdate),
          double(psdate),
          double(pedate));
    end;
  end;
end;

procedure TDataCollector.setPlanningExpData;
var
  cn : integer;
  ltotal : currency;
  PlanDataRec : TPlanDataRecPtr;
  varg : variant;
begin
  //
  psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  for cn := 0 to PlanExpDataList.count - 1
    do begin
    PlanDataRec := PlanExpDataList.items[cn];
    // Set Past Balance
    if PlanDatarec.Accountno = 560 then
      varg := 0;
      
    if PlanDataRec.PastBalances[DataModuleClient.DateRangersD_Index.value - 1] <> 0
      then setPastBalance(@PlanDataRec^.PastBalances[DataModuleClient.DateRangersD_Index.value - 1], PlanDatarec.Accountno)
    else
      ClearPastBalance(@PlanDataRec^.PastBalances[DataModuleClient.DateRangersD_Index.value - 1], PlanDatarec.Accountno);
    // Set Plan Balances
    //Update Array with Total
     varg := PlanDataRec.Accountno;
     if DataModuleClient.AccountDetails.Locate('Account_Number', varg, []) = true
       then begin
       DataModuleClient.AccountDetails.edit;
       if PlanDataRec.WagesCB = cbChecked then
         DataModuleClient.AccountDetailsAccount_SubTitle.value := 'W'
       else
         DataModuleClient.AccountDetailsAccount_SubTitle.value := '';
       DataModuleClient.AccountDetails.Post;
    end;
    ltotal := GetTotalBalance(
      PlanDataRec^.PlanDetail,
      double(psdate),
      double(psdate),
      double(pedate));
    if (PlanDataRec.PlanTotal <>  ltotal) then
        updateArray(PlanDataRec.PlanDetail,
                  double(psdate),
                  double(psdate),
                  double(pedate),
                  PlanDataRec.PlanTotal,
                  6);
    if CompareMem(pointer(@PlanDataRec.PlanDetail), Pointer(@PlanDataRec.PlanDetailDisk), Sizeof(currency) * NUM_DAYSINYEAR) = False then
      setBalances(PlanDataRec.PlanDetail, PlanDatarec.Accountno, True);
  end;
end;

procedure TDataCollector.setMonitoringExpData;
var
  cn, J, K : integer;
//  ltotal : currency;
  MonitorDataRec : TPlanDataRecPtr;
  varg : variant;
  FirstMdate, LastMDate : Integer;
begin
  psdate := DataModuleClient.DepartmentsCurrentMonitoringStart.value;
  pedate := DataModuleClient.DepartmentsCurrentMonitoringEnd.value;
  K := Trunc(pedate) - trunc(psdate) + 1;
  FirstMdate := k + 1;
  LastMdate := -1;
  for cn := 0 to MonitoringExpDataList.count - 1
    do begin
    MonitorDataRec := MonitoringExpDataList.items[cn];
    // Set Past Balance
    // Set Plan Balances
    //Update Array with Total
    J := k;
    while (MonitorDataRec.PlanDetail[J] = 0) and (J >= 0) do
      dec(j);
    if J > LastMdate then LastMDate := J;
    J := 0;
    while (monitorDataRec.PlanDetail[J] = 0) and (J <= K) do
      inc(j);
    if J < FirstMdate then FirstMDate := J;
    varg := MonitorDataRec.Accountno;
    if CompareMem(pointer(@MonitorDataRec.PlanDetail), Pointer(@MonitorDataRec.PlanDetailDisk), Sizeof(currency) * NUM_DAYSINYEAR) = False then
      setBalances(MonitorDataRec.PlanDetail, MonitorDatarec.Accountno, False);
  end;
  DataModuleClient.Departments.edit;
  if (LastMDate > -1) and (DataModuleClient.DepartmentsLast_Monitored.value < (psdate + LastMdate))
    then DataModuleClient.DepartmentsLast_Monitored.value := psdate + LastMDate;
  if (FirstMDate < (K + 1)) and (DataModuleClient.DepartmentsFirstMonitoringDate.value > (psdate + FirstMDate))
    then DataModuleClient.DepartmentsFirstMonitoringDate.value := psdate + FirstMDate;
  DataModuleClient.Departments.Post;
end;

Function TDataCollector.getAccountTitle(title : Pchar;Accountno : integer): Boolean;
var
  varg, varg1 : Variant;
begin
  Varg := Accountno;
  // Assume True
  Result := true;
  varg1 := DataModuleClient.AccountDetails.Lookup('Account_Number',varg,'Account_Title');
  if (varType(varg1) <> varstring)
    then Result := False
  else strPcopy(Title, varg1);
end;

function TDataCollector.getAccountSubTitle(SubTitle: Pchar; Accountno : Integer): Boolean;
var
  varg,varg1 : Variant;
begin
  Varg := Accountno;
  // Assume True
  Result := true;
  varg1 := DataModuleClient.AccountDetails.Lookup('Account_Number',varg,'Account_SubTitle');
  if (VarType(varg1) <> varString)
    then Result := False
  else strPcopy(SubTitle, varg1);
end;

procedure TDataCollector.getPastBalances(var balances : Array of currency;Accountno : Integer);
var
  I: Integer;
  varg : Variant;
  pastdate : double;
  DeptRec : TDepartRecPtr;
begin
  varg := VarArraycreate([0,3], VarVariant);
  varg[1] := AccountNo;
  for I := 0 to 4 do Balances[I] := 0;
  for I := 0 to ConsolidList.Count - 1 do    // Iterate
  begin
    DeptRec := TDepartRecPtr(ConsolidList.items[I]);
    varg[0] := DeptRec.DeptID;
    if (ConsolidList.count = 1) or (Not OKtoExclude(DeptRec.DeptId))then
    begin
      DataModuleClient.DateRef.IndexName := 'ENDDATEIDX';
      DataModuleClient.DateRef.First;
      while DataModuleClient.DateRef.Eof = False do
      begin
        pastdate := trunc(DataModuleClient.DateRefEndDate.asfloat);
        varg[2] := pastdate;
        if DataModuleClient.DateRefDept_ID.value = DeptRec.DeptId then
        begin
          if DataModuleClient.ActualDataLU.Locate('Dept_id;Account_Number;PeriodEnd', varg, []) then
            Balances[DataModuleClient.DateRefD_Index.value - 1] := Balances[DataModuleClient.DateRefD_Index.value - 1]
              + DataModuleClient.ActualDataLUBal.Value;

//          Varg1 := DataModuleClient.ActualData.Lookup('Dept_ID;Account;Date',varg,'Bal');
//          if (Varg1 <> null)
//            and (VarType(varg1) <> varBoolean) or ((varType(varg1) = varBoolean) and (varg1 = True)) then
//          Balances[DataModuleClient.wwDateRefIndex.value - 1] := Balances[DataModuleClient.wwDateRefIndex.value - 1] + varg1;
        end;
        DataModuleClient.DateRef.next;
      end;    // while
    end; // if add
  end;    // for
end;

function TDataCollector.setPastBalance(balance : Pcurrency;Accountno : Integer): Boolean;
var
  varg {, varg1} : Variant;
  pastdate : double;
begin
  // Assume True
  Result := true;
  varg := VarArraycreate([0,3], VarVariant);
  varg[0] := DataModuleClient.DepartmentsDept_ID.value;
  varg[1] := AccountNo;
  pastdate := trunc(DataModuleClient.DateRangersEndDate.asfloat);
  varg[2] := pastdate;
  if not DataModuleClient.ActualData.Locate('Dept_ID;Account_Number;Periodend',varg,[])
    then begin
    DataModuleClient.ActualData.Insert;
    DataModuleClient.ActualDataDept_ID.value := DataModuleClient.DepartmentsDept_ID.value;
    DataModuleClient.ActualDataAccount_Number.Value := AccountNo;
    DataModuleClient.ActualDataPeriodEnd.value := trunc(DataModuleClient.DateRangersEndDate.asfloat);
    end
  else
    DataModuleClient.ActualData.Edit;
  DataModuleClient.ActualDataBal.Value := Balance^;
  DataModuleClient.ActualData.Post;
end;

function TDataCollector.ClearPastBalance(balance : Pcurrency;Accountno : Integer): Boolean;
var
  varg{, varg1} : Variant;
  pastdate : double;
begin
  // Assume True
  Result := true;
  varg := VarArraycreate([0,3], VarVariant);
  varg[0] := DataModuleClient.DepartmentsDept_ID.value;
  varg[1] := AccountNo;
  pastdate := trunc(DataModuleClient.DateRangersEndDate.asfloat);
  varg[2] := pastdate;
  if not DataModuleClient.ActualData.Locate('Dept_ID;Account_Number;PeriodEnd',varg,[]) then
    Result := False
  else
    DataModuleClient.ActualData.Delete;
end;

function TDataCollector.getRateBalances(var Balances : array of currency; MonitorDate : TDateTime): Boolean;
var
  GPbal : TDetailedBalArray;
  BilledBal : TDetailedBalArray;
  d, m, y : Word;
  Days : word;
  TargetGP, TargetBilled {, TrackedGP, TrackedBilled }: Currency;
begin
  Result := True;
  decodeDate(monitordate, y, m, d);
  psDate := EncodeDate(Y, M, Word(1));
  Days := DaysinMonth(Y, M);
  peDate := EncodeDate(Y, M, Days);
  getBalances(GPBal, GROSSPROFIT, True);
  GetBalances(BilledBal, BILLED, True);
  TargetGP := GetTotalBalance(GPBal, double(psdate), double(psdate), double(pedate));
  TargetBilled := GetTotalBalance(BilledBal, double(psdate), double(psdate), double(pedate));
  if TargetBilled <> 0 then
    Balances[MMONTHLYTARGET] := TargetGP / TargetBilled
  else
    Balances[MMONTHLYTARGET] := 0;
  if M > 1 then
    Dec(M)
  else begin
    M := 12;
    Dec(Y);
  end;
  psDate := EncodeDate(Y, M, Word(1));
  Days := DaysinMonth(Y, M);
  peDate := EncodeDate(Y, M, Days);
  getBalances(GPBal, GROSSPROFIT, False);
  GetBalances(BilledBal, BILLED, False);
  TargetGP := GetTotalBalance(GPBal, double(psdate), double(psdate), double(pedate));
  TargetBilled := GetTotalBalance(BilledBal, double(psdate), double(psdate), double(pedate));
  if TargetBilled <> 0 then
    Balances[MLASTMONTHMONITORED] := TargetGP / TargetBilled
  else
    Balances[MLASTMONTHMONITORED] := 0;
end;

function TDataCollector.getBalances(var Balances : array of currency; Accountno : integer; UsePlanData : Boolean): Boolean;
Var
  J: Integer;
  I: Integer;
  tempstream : TmemoryStream;
  tempstream1 : TmemoryStream;
  Tempbalances : TDetailedBalArray;
//  Tempbalances1 : TDetailedBalArray;
  varg : Variant;
  found, found1 : Boolean;
  d, m, y, y1 : Word;
  daystostart, daystoend, offset : integer;
  DeptRec : TdepartRecPtr;
begin
  Result := False;
  tempstream := TmemoryStream.Create;
  tempstream1 := TmemoryStream.Create;
  tempstream.setsize(sizeof(Currency) * NUM_DAYSINYEAR);
  tempstream1.setsize(sizeof(Currency) * NUM_DAYSINYEAR);
  decodeDate(psdate, y, m, d);
  decodeDate(pedate, y1, m, d);
  varg := VarArraycreate([0,3], VarVariant);
  varg[1] := AccountNo;
  FillChar(Balances, sizeof(TDetailedBalArray), #0);
  for I := 0 to ConsolidList.Count - 1 do    // Iterate
  begin
    DeptRec := TDepartRecPtr(ConsolidList.items[I]);
    varg[0] := DeptRec.DeptId;
    if (ConsolidList.count = 1) or (not OKtoExclude(DeptRec.DeptId)) then
    begin
      if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
        Varg[2] := 0
      else
        varg[2] := Y;
      if UsePlanData then
        found := DataModuleClient.PlanData.Locate('Dept_ID;Account_Number;D_Year',varg,[])
      else
        found := DataModuleClient.MonitoringDataLU.Locate('Dept_ID;Account_Number;D_Year',varg,[]);
      Offset := 0;
      FillChar(tempstream.memory^, tempstream.size, #0);
      FillChar(tempstream1.memory^, tempstream1.size, #0);
      tempstream.Seek(0, soFromBeginning);
      FillChar(tempBalances, sizeof(TDetailedBalArray), #0);
      if found then
      begin
        if UsePlanData then
          DataModuleClient.PlanDataD_Bals.SavetoStream(tempstream)
        else
          DataModuleClient.MonitoringDataLUD_Bals.SavetoStream(tempstream);
//      tempstream.Seek(0, soFromBeginning);
//      tempstream.read(TempBalances1, tempstream.size);
        if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
          daystostart := 0
        else
          daystostart := DaysfromYearStart(psdate);
        tempstream.Seek(Sizeof(currency) * daystoStart,  soFromBeginning);
        if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
          daystoend := 365
        else
          daystoend := DaysRemainingInYear(psdate);
        offset := Sizeof(currency) * daystoend;
        tempstream1.Seek(0, soFromBeginning);
        tempstream1.CopyFrom(tempstream, offset);
      end;
      if (Y <> Y1) and (AccountNo <> WHATIF) and (Accountno <> DETAILEDOPT)then
      begin
        varg[2] := Y1;
        if UsePlanData then
          found1 := DataModuleClient.PlanData.Locate('Dept_ID;Account_Number;D_Year',varg,[])
        else
          found1 := DataModuleClient.MonitoringDataLU.Locate('Dept_ID;Account_Number;D_Year',varg,[]);
        tempstream.Seek(0, soFromBeginning);
        if found1 then
        begin
          if UsePlanData then
            DataModuleClient.PlanDataD_Bals.SavetoStream(tempstream)
          else
            DataModuleClient.MonitoringDataLUD_Bals.SavetoStream(tempstream);
//        tempstream.Seek(0, soFromBeginning);
//        tempstream.read(TempBalances1, tempstream.size);
          daystostart := DaysfromYearStart(pedate) + 1;
          tempstream.Seek(0, soFromBeginning);
          tempstream1.Seek(offset, sofromBeginning);
          tempstream1.CopyFrom(tempstream, sizeof(Currency) * DaysToStart);
        end;
      end;
      tempstream1.Seek(0, soFromBeginning);
      if (tempstream1.read(TempBalances, Sizeof(currency) * integer(Trunc(pedate) - Trunc(psdate) + 1)) > 0) then
        Result := True;
      for J := 0 to NUM_DAYSINYEAR - 1 do    // Iterate
        Balances[J] := Balances[J] + Tempbalances[J];
    end;
  end;    // for
  tempstream.Free;
  tempstream1.Free;
end;

function TDataCollector.setBalances(var Balances : array of currency; Accountno : integer; UsePlanData : Boolean): Boolean;
Var
  tempstream, tempstream1 : TmemoryStream;
  Found : boolean;
  varg : variant;
//  recdate : double;
  d, m, y, y1 : Word;
  daystostart, daystoend, offset : integer;
begin
  Result := False;
  tempstream := TmemoryStream.create;
  tempstream1 := TmemoryStream.Create;
  tempstream.setsize(sizeof(Currency) * NUM_DAYSINYEAR);
  tempstream1.setsize(sizeof(Currency) * NUM_DAYSINYEAR);
  FillChar(tempstream.memory^, tempstream.size, #0);
  FillChar(tempstream1.memory^, tempstream1.size, #0);
  // we dump balances into tempstream but save to DB from tempstream1
  tempstream.Write(Balances, Sizeof(currency) * NUM_DAYSINYEAR);

  decodeDate(psdate, y, m, d);
  decodeDate(pedate, y1, m, d);
  varg := VarArraycreate([0,3], VarVariant);
  varg[0] := DataModuleClient.DepartmentsDept_ID.value;
  varg[1] := AccountNo;
  if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
    varg[2] := 0
  else
    varg[2] := y;
  if UsePlanData then
    found := DataModuleClient.PlanData.Locate('Dept_ID;Account_Number;D_Year',varg,[])
  else
    found := DataModuleClient.MonitoringData.Locate('Dept_ID;Account_Number;D_Year',varg,[]);
  if not found then
    begin
    if UsePlanData then
      begin
      DataModuleClient.PlanData.Insert;
      DataModuleClient.PlanDataDept_ID.value := DataModuleClient.DepartmentsDept_ID.value;
      DataModuleClient.PlanDataAccount_Number.Value := AccountNo;
      if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
        DataModuleClient.PlanDataD_Year.value := 0
      else
        DataModuleClient.PlanDataD_Year.value := Y;
      DataModuleClient.PlanDataD_TYPE.Value := 1;
      end
    else
      begin
      DataModuleClient.MonitoringData.Insert;
      DataModuleClient.MonitoringDataDept_ID.value := DataModuleClient.DepartmentsDept_ID.value;
      DataModuleClient.MonitoringDataAccount_Number.Value := AccountNo;
      DataModuleClient.MonitoringDataD_TYPE.Value := 2;
      if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
        DataModuleClient.MonitoringDataD_Year.value := 0
      else
        DataModuleClient.MonitoringDataD_Year.value := Y;
      DataModuleClient.MonitoringDataD_TYPE.Value := 2;
      end;
    end
  else
    begin
    if UsePlanData then
      DataModuleClient.PlanData.Edit
    else
      DataModuleClient.MonitoringData.Edit;
    tempstream1.Seek(0,  soFromBeginning);
    if UsePlanData then
      DataModuleClient.PlanDataD_Bals.SavetoStream(tempstream1)
    else
      DataModuleClient.MonitoringDataD_bals.SavetoStream(tempstream1);
    end;
  if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
    daystostart := 0
  else
    daystostart := DaysfromYearStart(psdate);
  tempstream.seek(0, soFromBeginning);
  tempstream1.Seek(Sizeof(currency) * daystoStart,  soFromBeginning);
  if (AccountNo = WHATIF) or (AccountNo = DETAILEDOPT) then
    daystoend := 365
  else
    daystoend := DaysRemainingInYear(psdate);
  offset := Sizeof(currency) * daystoend;
  tempstream1.CopyFrom(tempstream, offset);
  if UsePlanData then
    Begin
    DataModuleClient.PlanDataD_Bals.LoadFromStream(tempstream1);
    DataModuleClient.PlanData.Post;
    end
  else
    begin
    DataModuleClient.MonitoringDataD_Bals.LoadFromStream(tempstream1);
    DataModuleClient.MonitoringData.Post;
    end;
  if (y <> y1) and (AccountNo <> WHATIF) and (AccountNo <> DETAILEDOPT) then
    begin
      varg[2] := y1;
      if UsePlanData then
        found := DataModuleClient.PlanData.Locate('Dept_ID;Account_Number;D_Year',varg,[])
      else
        found := DataModuleClient.MonitoringData.Locate('Dept_ID;Account_Number;D_Year',varg,[]);
      if not found then
        begin
          if UsePlanData then
            Begin
            DataModuleClient.PlanData.Insert;
            DataModuleClient.PlanDataDept_ID.value := DataModuleClient.DepartmentsDept_ID.value;
            DataModuleClient.PlanDataAccount_Number.Value := AccountNo;
            DataModuleClient.PlanDataD_Year.value := Y1;
            DataModuleClient.PlanDataD_TYPE.Value := 1;
            end
          else
            begin
            DataModuleClient.MonitoringData.Insert;
            DataModuleClient.MonitoringDataDept_ID.value := DataModuleClient.DepartmentsDept_ID.value;
            DataModuleClient.MonitoringDataAccount_Number.Value := AccountNo;
            DataModuleClient.MonitoringDataD_Year.value := Y1;
            DataModuleClient.MonitoringDataD_TYPE.Value := 2;
            end;
        end
      else
        begin
          if UsePlanData then
            DataModuleClient.PlanData.Edit
          else
            DataModuleClient.MonitoringData.Edit;
          tempstream1.Seek(0,  soFromBeginning);
          if UsePlanData then
            DataModuleClient.PlanDataD_Bals.SavetoStream(tempstream1)
          else
            DataModuleClient.MonitoringDataD_Bals.SavetoStream(tempstream1);
        end;
      daystostart := DaysfromYearStart(pedate) + 1;
      tempstream1.Seek(0,  soFromBeginning);
      tempstream.Seek(offset, sofromBeginning);
      tempstream1.CopyFrom(tempstream, sizeof(Currency) * DaysToStart);
      if UsePlanData then
        begin
        DataModuleClient.PlanDataD_Bals.LoadFromStream(tempstream1);
        DataModuleClient.PlanData.Post;
        end
      else
        begin
        DataModuleClient.MonitoringDataD_Bals.LoadFromStream(tempstream1);
        DataModuleClient.MonitoringData.Post;
        end;
    end;
    tempstream.Free;
    tempstream1.Free;
end;

procedure TDataCollector.CopyNewPlanData(SrcStart, SrcEnd, DstStart : TDateTime; SrcPlan, ClearData : Boolean; Range : TRangeType);
var
  I, J: Integer;
  Fbalances : TDetailedBalArray;
  TotalBal : Currency;
  StartAcc, EndAcc : integer;
begin
  Startacc := 0;
  EndAcc := 0;
  case Range of    //
    RtSales:        begin
                    StartAcc := SALES;
                    EndAcc := GROSSPROFIT;
                    end;
    RtOtherIncome:  Begin
                    StartAcc := OTHERINCOME;
                    EndAcc := NETPROFIT;
                    end;
    RtExpenses:     Begin
                    StartAcc := FIRSTEXPENSE;
                    EndAcc := NETOPERATINGPROFIT;
                    End;
    RtBalanceSheet: Begin
                    StartAcc := FIRSTBALANCESHEET;
                    EndAcc := LASTBALANCESHEET;
                    End;
  end;    // case

  for I := StartAcc to EndAcc do    // Iterate
    begin
    FillChar(Fbalances, Sizeof(TDetailedBalArray), #0);
    psdate := SrcStart;
    pedate := SrcEnd;
    if Not ClearData then
      begin
      if getBalances(FBalances, I, SrcPlan) then
        begin
        TotalBal := GetTotalBalance(Fbalances,
        double(psdate),
        double(psdate),
        double(pedate));
        end
      else
        TotalBal := 0;
      end
    else
      begin
      TotalBal := 0;
      for J := 0 to NUM_DAYSINYEAR do    // Iterate
        fBalances[J] := 0;
      end;
    if (ClearData) or (TotalBal <> 0) then
      begin
      psdate := DstStart;
      pedate := DstStart + Srcend - SrcStart;
      SetBalances(fBalances, I, True);
      end;
    end;    // for
end;

function getaccountlistindex(accountno: integer): integer;
var
  cn : integer;
begin
  Result := -1;
  for cn := 0 to SUMMARYPLANLIST - 1
    do begin
    if SummaryPlan[cn] = accountno
      then begin
      Result := cn;
      break;
    end;
  end;
end;

function getMonitoringSaleslistindex(accountno: integer): integer;
var
  cn : integer;
begin
  Result := -1;
  for cn := 0 to MONITORSALESLIST - 1
    do begin
    if MonitoringSalesAccounts[cn] = accountno
      then begin
      Result := cn;
      break;
    end;
  end;
end;

function getMonitoringSalesInputindex(accountno: integer): integer;
var
  cn : integer;
begin
  Result := -1;
  for cn := 0 to MONITORSALESLIST - 1
    do begin
    if MonitoringSalesInput[cn] = accountno
      then begin
      Result := cn;
      break;
    end;
  end;
end;

function getKeyaccountlistindex(accountno: integer): integer;
var
  cn : integer;
begin
  Result := -1;
  for cn := 0 to integer(Trunc(sizeof(KeyReportAccounts)/sizeof(integer)) - 1)
    do begin
    if KeyReportAccounts[cn] = accountno
      then begin
      Result := cn;
      break;
    end;
  end;
end;

function getExpAccountListindex(accountno: integer): integer;
var
  cn : integer;
  PlanDataRec : TPlanDataRecPtr;
begin
  Result := -1;
  for cn := 0 to PlanExpDataList.count - 1 do
    begin
    PlanDataRec := PlanExpDataList.Items[cn];
    if PlanDataRec.AccountNo = accountno then
      begin
      Result := cn;
      break;
      end;
    end;
end;

function getListpastbalance(Listindex: integer): currency;
begin
  Result := TPlanDataRecPtr(PlanDataList.Items[Listindex]).PastBalances[DataModuleClient.DateRangersD_Index.value - 1];
end;

procedure setListPastBalance(Listindex: integer; balance : currency);
begin
  TPlanDataRecPtr(PlanDataList.Items[Listindex]).PastBalances[DataModuleClient.DateRangersD_Index.Value - 1] := balance;
end;

function getListPlanbalance(Listindex: integer): currency;
begin
  Result := TPlanDataRecPtr(PlanDataList.Items[Listindex]).PlanTotal;
end;

procedure setListPlanBalance(Listindex: integer; balance : currency; UpdateArray : Boolean);
var
  PlanDataRec : TPlanDataRecPtr;
begin
  PlanDataRec := PlanDataList.items[listindex];
  PlanDataRec.PlanTotal := balance;
  if UpdateArray then
    begin
    DataCollect.psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
    DataCollect.pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
    if (PlanDataRec.Accountno <> WHATIF) and (PlanDataRec.Accountno <> DETAILEDOPT) then
      begin
      if (PlanDataRec.Accountno = FTEOTHER) or (PlanDataRec.Accountno = FTEPROD) then
        PlanDataRec.PlanTotal := PlanDataRec.PlanTotal * (Trunc(DataCollect.pedate - DataCollect.psdate) + 1);
      if (GGlobals.unitRounding = 0)
        and ((PlanDataRec.Accountno = BILLED) or (PlanDataRec.Accountno = BILLED))  then
        DataCollect.updateArray(  PlanDataRec.PlanDetail,
                  double(DataCollect.psdate),
                  double(DataCollect.psdate),
                  double(DataCollect.pedate),
                  PlanDataRec.PlanTotal,
                  0)
      else
        DataCollect.updateArray(  PlanDataRec.PlanDetail,
                  double(DataCollect.psdate),
                  double(DataCollect.psdate),
                  double(DataCollect.pedate),
                  PlanDataRec.PlanTotal,
                  6);
      if (PlanDataRec.Accountno = FTEOTHER) or (PlanDataRec.Accountno = FTEPROD) then
        PlanDataRec.PlanTotal := PlanDataRec.PlanTotal / (Trunc(DataCollect.pedate - DataCollect.psdate) + 1);
      end;
    end;
end;

procedure sortExpenseList(UseLPlanData : Boolean);

  function sortExpTitle(item1, Item2: pointer): integer;
    begin
    if TPlanDataRecPtr(item1).AccountNo = TOTALOTHEREXPENSES then
      result := 1
    else
      begin
      if (strlen(TPlanDataRecPtr(item1).AccountTitle) > 0) and (strlen(TPlanDataRecPtr(item2).AccountTitle) > 0) then
        begin
        if (strcomp(TPlanDataRecPtr(item1).AccountTitle, TPlanDataRecPtr(item2).AccountTitle) = 0) then
          begin
          if TPlanDataRecPtr(item1).AccountNo < TPlanDataRecPtr(item2).AccountNo then
            Result := -1
          else if TPlanDataRecPtr(item1).AccountNo = TPlanDataRecPtr(item2).AccountNo then
            Result := 0
          else
            Result := 1;
          end
        else
          if (strcomp(TPlanDataRecPtr(item1).AccountTitle, TPlanDataRecPtr(item2).AccountTitle) < 0) then
            result := -1
          else
          result := 1;
        end
      else
        begin
        if (strcomp(TPlanDataRecPtr(item1).AccountTitle, TPlanDataRecPtr(item2).AccountTitle) = 0) then
          begin
          if TPlanDataRecPtr(item1).AccountNo < TPlanDataRecPtr(item2).AccountNo then
            Result := -1
          else
            if TPlanDataRecPtr(item1).AccountNo = TPlanDataRecPtr(item2).AccountNo then
              Result := 0
            else
              Result := 1;
          end
        else
          if (strcomp(TPlanDataRecPtr(item1).AccountTitle, TPlanDataRecPtr(item2).AccountTitle) < 0) then
            result := 1
          else
            result := -1;
        end;
      end;
    end;
begin
  if UseLPlanData then
    PlanExpDataList.sort(@sortExpTitle)
  else
    MonitoringExpDataList.sort(@sortExpTitle);
end;

function BuildSummary(AccountNo: Integer; UsePlanDates: Boolean; Detail: TDetailedBalArray; var Summary: TSummaryBalArray): Currency;
var
  daysinyear: Integer;
  k, m : Integer;
  j: Integer;
  Startdate, Enddate : TDateTime;
begin
  k := 0;
  m := -1;     // because the start period is the first date
  Result := 0;
  if UsePlanDates then
    begin
    StartDate := DataModuleClient.DepartmentsCurrentPlanStart.value;
    Enddate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
    end
  else
    begin
    StartDate := DataModuleClient.DepartmentsCurrentMonitoringStart.value;
    Enddate := DataModuleClient.DepartmentsCurrentMonitoringEnd.value;
    end;
  // initialise the Summary Array
  fillchar(Summary, sizeof(TSummaryBalArray), #0);
  // Calculate the days in period
  daysinyear := trunc(EndDate) - trunc(StartDate);
  for j := 0 to DaysInYear do    // Iterate
    begin
    Summary[k] := Summary[k] + Detail[j];
    Result := Result + Detail[j];
    if (SummaryPeriodIndexArray[k] = j) then
      begin
      if (AccountNo = FTEPROD) or (AccountNo = FTEOTHER) then
        Summary[K] := Summary[k] / (J - m);
      M := J;
      inc(k);
      end;    // while
    end;    // for
end;
{
procedure buildMonitorsummary(ListIndex: integer; UseMonExpenseList: Boolean);
var
//  SumCount: Integer;
  daysinyear: Integer;
//  m: integer;
  k: Integer;
  j: Integer;
  PlanDataRec : TPlanDataRecPtr;
  Startdate, Enddate : TDateTime;
begin
  k := 0;
  StartDate := DataModuleClient.DepartmentsCurrentMonitoringStart.value;
  Enddate := DataModuleClient.DepartmentsCurrentMonitoringEnd.value;
  if UseMonExpenseList then
    PlanDataRec := MonitoringExpDataList.items[ListIndex]
  else
    PlanDataRec := MonitoringDataList.items[ListIndex];
  // initialise the Summary Array
  fillchar(PlanDataRec^.PlanSummary, sizeof(TSummaryBalArray), #0);
  // Calculate the days in period
  daysinyear := trunc(EndDate) - trunc(StartDate);
  PlanDataRec.PlanTotal := 0;
  for j := 0 to DaysInYear do    // Iterate
    begin
    PlanDataRec.PlanSummary[k] := PlanDataRec.PlanSummary[k] + PlanDataRec.PlanDetail[j];
    PlanDataRec.PlanTotal := PlanDataRec.PlanTotal + PlanDataRec.PlanDetail[j];
    if (SummaryPeriodIndexArray[k] = j)
      then begin
      inc(k);
    end;    // while
  end;    // for
end;
}

function createSummaryIndex(SummaryType: Integer; StartDate, Enddate: TDateTime): Integer;
var
  m: integer;
  TempDate: TDateTime;
  Year, Year1, Month, Month1, Day, Day1: word;
  SumCount: Integer;
  k: Integer;
  daysinyear: Integer;
  j: Integer;
//  Startdate, Enddate : TDateTime;
begin
//  StartDate := DataModuleClient.psdate;
//  DepartmentsCurrentPlanStart.value;
//  Enddate := DataModuleClient.pedate;
//  DepartmentsCurrentPlanEnd.value;
  for j := 0 to NUM_WEEKS + 1 do    // Iterate
    SummaryPeriodIndexArray[j] := 0;
  daysinyear := trunc(EndDate) - trunc(StartDate);
  // Calculate the days in the first period
  k := DataModuleClient.DepartmentsLastDayOfWeek.value;
  SumCount := 0;
  m := 0;
  case SummaryType of    //
    1:  begin   // Weekly based on end of week nomination
        m := DayofWeek(StartDate) - 1; // Zero based
        for j := 0 to DaysInYear - 1 do    // Iterate
          begin
          if m = k then
            begin
            SummaryPeriodIndexArray[SumCount] := j;
            inc(SumCount);
            end;
          inc(m);
          if m = 7 then m := 0;
          end; // for
        if SummaryPeriodIndexArray[SumCount - 1] < DaysInYear then
          begin
          SummaryPeriodIndexArray[SumCount] := DaysInYear;
          inc(Sumcount);
          end;
        Result := Sumcount;
        end;
    2:  begin  // 4 Weekly based on Starting date
        for j := 0 to DaysInYear - 1 do    // Iterate
          begin
          inc(m);
          if m = 28 then
            begin
            SummaryPeriodIndexArray[SumCount] := j;
            inc(SumCount);
            m := 0;
            end;
          end;    // for
        if SummaryPeriodIndexArray[SumCount - 1] < DaysInYear then
          begin
          SummaryPeriodIndexArray[SumCount] := DaysInYear;
          inc(Sumcount);
          end;
        Result := Sumcount;
        end;
    3:  begin  // 4 / 5 Weekly based on Starting Date
        DecodeDate(StartDate, Year, Month, Day);
        DecodeDate(Enddate, Year1, Month1, Day1);
        Day := MonthDays[IsLeapYear(Year), Month];
        TempDate := EncodeDate(Year, Month, Day);
        while (Year < Year1) or ((year = year1) and (Month <= Month1)) do
          begin
          while (DayofWeek(TempDate) - 1) <> k do  // Find the last "end of Week" for this month
            TempDate := TempDate - 1;
          if TempDate > EndDate then
            TempDate := EndDate;
          // Added 1 to correct the offset calculation
          SummaryPeriodIndexArray[SumCount] := trunc(TempDate) - trunc(StartDate);
          inc(SumCount);
          inc(Month);
          if Month = 13 then
            begin
            Month := 1;
            inc(Year);
            end;
          Day := MonthDays[IsLeapYear(Year), Month];
          TempDate := EncodeDate(Year, Month, Day);
          end;    // while
        if SummaryPeriodIndexArray[SumCount - 1] < DaysInYear then
          begin
          SummaryPeriodIndexArray[SumCount] := DaysInYear;
          inc(Sumcount);
          end;
        Result := Sumcount;
        end;
    4:  begin  // ^ Monthly based on
        DecodeDate(StartDate, Year, Month, Day);
        DecodeDate(EndDate, Year1, Month1, Day1);
        Day := MonthDays[IsLeapYear(Year), Month];
        TempDate := EncodeDate(Year, Month, Day);
        while (Year < Year1) or ((year = year1) and (Month <= Month1)) do
          begin
          if TempDate > EndDate then
            TempDate := EndDate;
          SummaryPeriodIndexArray[SumCount] := trunc(TempDate) - trunc(StartDate);
          inc(SumCount);
          inc(Month);
          if Month = 13 then
            begin
            Month := 1;
            inc(Year);
            end;
          Day := MonthDays[IsLeapYear(Year), Month];
          TempDate := EncodeDate(Year, Month, Day);
          end;    // while
        Result := Sumcount;
        end;
    5:  begin  // ^ Quarterly based on
        DecodeDate(StartDate, Year, Month, Day);
        DecodeDate(EndDate, Year1, Month1, Day1);
        Month := Month + 2; // Takes us to the end of the 3rd Month
        if Month > 12 then
          begin
          Month := Month - 12;
          inc(Year);
          end;
        Day := MonthDays[IsLeapYear(Year), Month];
        TempDate := EncodeDate(Year, Month, Day);
        while (Year < Year1) or ((year = year1) and (Month <= Month1)) do
          begin
          if TempDate > EndDate then
            TempDate := EndDate;
          SummaryPeriodIndexArray[SumCount] := trunc(TempDate) - trunc(StartDate);
          inc(SumCount);
          inc(Month, 3);
          if Month > 12 then
            begin
            Month := Month - 12;
            inc(Year);
            end;
          Day := MonthDays[IsLeapYear(Year), Month];
          TempDate := EncodeDate(Year, Month, Day);
          end;    // while
        Result := Sumcount;
        end;
    6:  begin  // 6 Monthly based on
        DecodeDate(StartDate, Year, Month, Day);
        DecodeDate(EndDate, Year1, Month1, Day1);
        Month := Month + 5; // Takes us to the end of the 6th Month
        if Month > 12 then
          begin
          Month := Month - 12;
          inc(Year);
          end;
        Day := MonthDays[IsLeapYear(Year), Month];
        TempDate := EncodeDate(Year, Month, Day);
        while (Year < Year1) or ((year = year1) and (Month <= Month1)) do
          begin
          if TempDate > EndDate then
            TempDate := EndDate;
          SummaryPeriodIndexArray[SumCount] := trunc(TempDate) - trunc(StartDate);
          inc(SumCount);
          inc(Month, 6);
          if Month > 12 then
            begin
            Month := Month - 12;
            inc(Year);
            end;
          Day := MonthDays[IsLeapYear(Year), Month];
          TempDate := EncodeDate(Year, Month, Day);
          end;    // while
        Result := Sumcount;
        end;
    7:  begin  // Yearly - but who would use this??
        SummaryPeriodIndexArray[SumCount] := trunc(EndDate) - trunc(StartDate);
        inc(SumCount);
        Result := Sumcount;
         end;
  else
    Result := 0;
  end;    // case
end;

procedure UpdateBalances(var Barray: array of currency; new: currency);
begin
  DataCollect.psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  DataCollect.pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  DataCollect.updateArray(Barray, double(DataCollect.psdate), double(DataCollect.psdate),
                  double(DataCollect.pedate), new, 6);
end;

procedure AdjustBalances(var Barray, totalexp: array of currency; new: currency);
var
  j : integer;
  temparray : TDetailedBalArray;
begin
  // save the old balances for the update
  move(barray, temparray, sizeof(TDetailedBalArray));
  UpdateBalances(Barray, new);
  for j := 0 to NUM_DAYSINYEAR do    // Iterate
    begin
    totalexp[j] := totalexp[j] - temparray[j] + barray[j];
    end;    // for
end;

procedure UpdateFromSummaryBalances(var Barray, totalExp: array of currency; new: currency; fromperiod, toperiod, AccountNo: integer);
var
  j : integer;
  temparray : TDetailedBalArray;
begin
  DataCollect.psdate := DataModuleClient.DepartmentsCurrentPlanStart.value;
  DataCollect.pedate := DataModuleClient.DepartmentsCurrentPlanEnd.value;
  move(barray, temparray, sizeof(TDetailedBalArray));
  if ((GGlobals.UnitRounding = 0)
    and ((AccountNo = BILLED) or (AccountNo = POTENTIAL))) or ((AccountNo >= FIRSTEXPENSE) and (AccountNo <= TOTALEXPENSES)) then
    DataCollect.updateArray(Barray, double(DataCollect.psdate), double(DataCollect.psdate) + fromperiod,
                  double(DataCollect.psdate) + toperiod, new, 0)
  else
    DataCollect.updateArray(Barray, double(DataCollect.psdate), double(DataCollect.psdate) + fromperiod,
                  double(DataCollect.psdate) + toperiod, new, 6);
  for j := fromperiod to toperiod do    // Iterate
    begin
    totalexp[j] := totalexp[j] - temparray[j] + barray[j];
    end;    // for
end;

// Get What If balance from the Detailed Array in the WHATIF account Record
function getWIBalance(WIset, WIAccount : integer): currency;
var
  PlanDataRec : TPlanDataRecPtr;
begin
  PlanDataRec := PlanDataList.items[GetAccountListIndex(WHATIF)];
  Result := PlanDataRec.PlanDetail[WIset * 20 + WIAccount];
end;

// Set What If balance to the Detailed Array in the WHATIF account Record
procedure setWIBalance(WIset, WIAccount : integer; balance : Currency);
var
  PlanDataRec : TPlanDataRecPtr;
begin
  PlanDataRec := PlanDataList.items[GetAccountListIndex(WHATIF)];
  PlanDataRec.PlanDetail[WIset * 20 + WIAccount] := Balance;
end;

function FindPrinterIndex(NewPrinter : string): integer;
var
  I : integer;
  S1 : Array[0..120] of char;
  S2 : Array[0..120] of char;
  Maxlen : Cardinal;
begin
  Result := printer.Printers.indexof(NewPrinter);
  if Result < 0 then
    begin
    StrPcopy(S1, NewPrinter);
    Maxlen := Strlen(S1);
    for I := 0 to Printer.Printers.count - 1 do    // Iterate
      begin
      StrPCopy(S2, Printer.Printers.strings[I]);
      if (Strlen(S2) >= Maxlen) and (AnsiStrLIComp(S1, S2, MaxLen) = 0) then
        begin
        Result := I;
        Break;
        end;
      end;    // for
    end;
end;

procedure TDataCollector.GetQuotes(StartDate, EndDate: TDateTime);
var
  I : TQuoteFields;
  J : TQuoteRepRows;
  QuoteDataRec : TQuoteRecPtr;
  Invoicesfound : Boolean;
//  K : Integer;
begin
  if Assigned(QuoteList) then
    begin
    if QuoteList.Count > 0 then
      ClearQuoteList;
    end;
  if not assigned(QuoteList) then
    QuoteList := Tlist.create;
  DataModuleClient.QuotesLU.First;
  while DataModuleClient.QuotesLU.eof = False do
    begin
    Invoicesfound := False;
    if (DataModuleClient.QuotesLUQ_Date.Value >= StartDate)
      and (DataModuleClient.QuotesLUQ_Date.Value <= Enddate) then
      begin
      new(QuoteDataRec);
//      K := sizeof(TQuoteRec);
      Fillchar(QuoteDataRec^, sizeof(TQuoteRec), #0);
//      K := QuotesLuDept_Id.Value;
      QuoteDataRec.Depart_ID := DataModuleClient.QuotesLuDept_Id.Value;
      QuoteDataRec.Quote_Date := DataModuleClient.QuotesLUQ_Date.Value;
      QuoteDataRec.Quote_Number := DataModuleClient.QuotesLUQuote_Number.Value;
      QuoteDataRec.Quote_Customer := DataModuleClient.QuotesLUCustomerName.value;
      QuoteDataRec.Values[qfSales, QrrQuote] := DataModuleClient.QuotesLUQ_Value.Value;
      QuoteDataRec.Values[qfMaterials, QrrQuote] := DataModuleClient.QuotesLUQ_Materials.Value;
      QuoteDataRec.Values[qfSubCon, QrrQuote] := DataModuleClient.QuotesLUQ_Subcontractors.Value;
      QuoteDataRec.Values[qfHours, QrrQuote] := DataModuleClient.QuotesLUTargetUnits.Value;
      QuoteDataRec.Values[qfTimeSheetHours, QrrQuote] := DataModuleClient.QuotesLUTargetUnits.Value;
      DataModuleClient.InvQuoteLU.First;
      while DataModuleClient.InvQuoteLu.eof = False do
        begin
        Invoicesfound := True;
        QuoteDataRec.Values[QfSales, qrrActual] := QuoteDataRec.Values[QfSales, qrrActual] + DataModuleClient.InvQuoteLUNetSales.Value;
        QuoteDataRec.Values[QfMaterials, qrrActual] := QuoteDataRec.Values[QfMaterials, qrrActual] + DataModuleClient.InvQuoteLUMaterialsatCost.Value;
        QuoteDataRec.Values[QfSubCon, qrrActual] := QuoteDataRec.Values[QfSubCon, qrrActual] + DataModuleClient.InvQuoteLUSubcontractors.Value;
        QuoteDataRec.Values[QfHours, qrrActual] := QuoteDataRec.Values[QfHours, qrrActual] + DataModuleClient.InvQuoteLUUnitsRequired.Value;
        QuoteDataRec.Values[QfTimeSheetHours, qrrActual] := QuoteDataRec.Values[QfTimeSheetHours, qrrActual] + DataModuleClient.InvQuoteLURecordedUnits.Value;
        if QuoteDataRec.LastInvDate < DataModuleClient.InvQuoteLUInv_Date.value then
          begin
          QuoteDataRec.LastInvDate := DataModuleClient.InvQuoteLUInv_Date.value;
          if DataModuleClient.InvQuoteLUOrderComplete.value = 0 then
            begin
            if DataModuleClient.InvQuoteLUUnitstoRun.Value <> 0 then
              QuoteDataRec.HourstoRun := DataModuleClient.InvQuoteLUUnitsToRun.Value
            else
              begin
              QuoteDataRec.HourstoRunS := 'Not Available';
              QuoteDataRec.HourstoRun := -1;
              end;
            end
          else
            QuoteDataRec.HourstoRun := 0;
          end;
        DataModuleClient.InvQuoteLU.Next;
        end;
      // Calculate Values on Rows
      for J := QrrQuote to QrrActual do    // Iterate
        begin
        QuoteDataRec.Values[QfGP, J] := QuoteDataRec.Values[QFSales, J]
          - QuoteDataRec.Values[QfMaterials, J] - QuoteDataRec.values[QfSubcon, J];
        if QUoteDataRec.Values[QFSales, J] <> 0 then
          QuoteDataRec.Values[QfGPPC, J] := QuoteDataRec.Values[QFGP, J] * 100 / QuoteDataRec.Values[QFSales, J];
        if GGlobals.TimeSheetRate and (QuoteDataRec.Values[QfTimeSheetHours, J] <> 0) then
          QuoteDataRec.Values[QFRate, J] := QuoteDataRec.Values[QFGP, J] / QUoteDataRec.Values[QFTimeSheetHours, J];
        if (Not GGlobals.TimeSheetRate) and (QUoteDataRec.Values[QFHours, J] <> 0) then
          QuoteDataRec.Values[QFRate, J] := QuoteDataRec.Values[QFGP, J] / QUoteDataRec.Values[QFHours, J];
        end;    // for
      // Calculate All Valiances
      for I := QfSales to QFEnd do    // Iterate
        QuoteDataRec.Values[I, qrrVariance] := QuoteDataRec.values[I, QrrQuote] - QuoteDataRec.Values[I, QrrActual];
      // Reverse the values for Sales, GP and Rate
      QuoteDataRec.Values[qfSales, QrrVariance] := QuoteDataRec.Values[qfSales, QrrVariance] * -1;
      QuoteDataRec.Values[qfGP, QrrVariance] := QuoteDataRec.Values[qfGP, QrrVariance] * -1;
      QuoteDataRec.Values[qfGPPC, QrrVariance] := QuoteDataRec.Values[qfGPPC, QrrVariance] * -1;
      QuoteDataRec.Values[qfRate, QrrVariance] := QuoteDataRec.Values[qfRate, QrrVariance] * -1;
      if Invoicesfound then
        QuoteList.Add(QuoteDataRec);
      end;
    DataModuleClient.QuotesLU.Next;
    end;    // while
end;

{ ---------------------------------------------------------------------------- }
{ -- clearPlanDataList - Frees the memory allocated to items in the list   }
{                        and clears the list ready for reloading.          }
{ ---------------------------------------------------------------------------- }
procedure TDataCollector.clearQuoteList;
var
  index: integer;
  QuoteDataRec: TQuoteRecPtr;
begin
  if Assigned(QuoteList) then
    begin
    for index := 0 to QuoteList.Count - 1 do
      begin
      QuoteDataRec := TQuoteRecPtr(QuoteList.Items[index]);
      dispose(QuoteDataRec);
      end;
    QuoteList.clear;
    QuoteList.free;
    QuoteList := nil;
    end;
end;

function TDataCollector.OkToExclude(deptid : integer): Boolean;
begin
  DataModuleClient.DeptRef.indexName := 'DEPTNAMEIDX';
  DataModuleClient.DeptRef.First;
  Result := False;
  while DataModuleClient.DeptRef.eof = False do
    begin
    if (DataModuleClient.DeptRefDept_Id.value = deptid) and (DataModuleClient.DeptRefExclude_from_Reporting.value > 0) then
      Result := True;
    DataModuleClient.DeptRef.next;
    end;    // while
end;

procedure TDataCollector.sortQuotes(SortType: TQuoteSortType);

{
  TQuoteRecPtr = ^TQuoteRec;TQuoteRec = record
    Depart_ID : Integer;
    Quote_LDate : LongInt;
    Values : TQuoteValues; //array[qfSales..qfEnd, QrrQuote..QrrVariance] of Currency;
    HourstoRun : currency;
    HourstoRunS : string[20];
    LastInvDate : TDateTime;
  end;
}

//    Quote_Number: string[20];

  function QuoteNumber(item1, Item2: pointer): integer;
    begin
    if TQuoteRecPtr(item1).Quote_Number < TQuoteRecPtr(item2).Quote_Number then
      result := -1
    else
      if TQuoteRecPtr(item1).Quote_Number > TQuoteRecPtr(item2).Quote_Number then
        Result := 1
      else
        result := 0;
    end;
//    Quote_Customer and Date
  function CustomerName(item1, Item2: pointer): integer;
    begin
    if TQuoteRecPtr(item1).Quote_Customer < TQuoteRecPtr(item2).Quote_Customer then
      result := -1
    else
      if TQuoteRecPtr(item1).Quote_Customer > TQuoteRecPtr(item2).Quote_Customer then
        Result := 1
      else
        begin
        if TQuoteRecPtr(Item1).Quote_date < TQuoteRecPtr(Item2).Quote_Date then
          Result := -1
        else
          if TQuoteRecPtr(Item1).Quote_date > TQuoteRecPtr(Item2).Quote_Date then
            Result := 1
          else
            result := 0;
        end;
    end;
//    Quote_Date and Number
  function QuoteDate(item1, Item2: pointer): integer;
    begin
    if TQuoteRecPtr(Item1).Quote_date < TQuoteRecPtr(Item2).Quote_Date then
      Result := -1
    else
      if TQuoteRecPtr(Item1).Quote_date > TQuoteRecPtr(Item2).Quote_Date then
        Result := 1
      else
        begin
        if TQuoteRecPtr(item1).Quote_Number < TQuoteRecPtr(item2).Quote_Number then
          result := -1
        else
          if TQuoteRecPtr(item1).Quote_Number > TQuoteRecPtr(item2).Quote_Number then
            Result := 1
          else
            result := 0;
        end;
    end;
// QuoteSales
  function QuoteSales(item1, Item2: pointer): integer;
    begin
    if TQuoteRecPtr(item1).Values[qfSales, QrrQuote] < TQuoteRecPtr(item2).Values[qfSales, QrrQuote] then
      result := -1
    else
      if TQuoteRecPtr(item1).Values[qfSales, QrrQuote] > TQuoteRecPtr(item2).Values[qfSales, QrrQuote] then
        Result := 1
      else
        begin
        if TQuoteRecPtr(Item1).Quote_date < TQuoteRecPtr(Item2).Quote_Date then
          Result := -1
        else
          if TQuoteRecPtr(Item1).Quote_date > TQuoteRecPtr(Item2).Quote_Date then
            Result := 1
          else
            result := 0;
        end;
    end;
// QuoteGPPC
  function QuoteGPPC(item1, Item2: pointer): integer;
    begin
    if TQuoteRecPtr(item1).Values[qfGPPC, QrrQuote] < TQuoteRecPtr(item2).Values[qfGPPC, QrrQuote] then
      result := -1
    else
      if TQuoteRecPtr(item1).Values[qfGPPC, QrrQuote] > TQuoteRecPtr(item2).Values[qfGPPC, QrrQuote] then
        Result := 1
      else
        begin
        if TQuoteRecPtr(Item1).Quote_date < TQuoteRecPtr(Item2).Quote_Date then
          Result := -1
        else
          if TQuoteRecPtr(Item1).Quote_date > TQuoteRecPtr(Item2).Quote_Date then
            Result := 1
          else
            result := 0;
        end;
    end;
// Quote Rate
  function QuoteRate(item1, Item2: pointer): integer;
    begin
    if TQuoteRecPtr(item1).Values[qfRate, QrrQuote] < TQuoteRecPtr(item2).Values[qfRate, QrrQuote] then
      result := -1
    else
      if TQuoteRecPtr(item1).Values[qfRate, QrrQuote] > TQuoteRecPtr(item2).Values[qfRate, QrrQuote] then
        Result := 1
      else
        begin
        if TQuoteRecPtr(Item1).Quote_date < TQuoteRecPtr(Item2).Quote_Date then
          Result := -1
        else
          if TQuoteRecPtr(Item1).Quote_date > TQuoteRecPtr(Item2).Quote_Date then
            Result := 1
          else
            result := 0;
        end;
    end;
// Quote Hours
  function QuoteHours(item1, Item2: pointer): integer;
    begin
    if TQuoteRecPtr(item1).Values[qfHours, QrrQuote] < TQuoteRecPtr(item2).Values[qfHours, QrrQuote] then
      result := -1
    else
      if TQuoteRecPtr(item1).Values[qfHours, QrrQuote] > TQuoteRecPtr(item2).Values[qfHours, QrrQuote] then
        Result := 1
      else
        begin
        if TQuoteRecPtr(Item1).Quote_date < TQuoteRecPtr(Item2).Quote_Date then
          Result := -1
        else
          if TQuoteRecPtr(Item1).Quote_date > TQuoteRecPtr(Item2).Quote_Date then
            Result := 1
          else
            result := 0;
        end;
    end;

begin
  case SortType of    //
    qstQuoteNumber: QuoteList.sort(@QuoteNumber);
    qstCustomerName: QuoteList.sort(@CustomerName);
    qstDate: QuoteList.sort(@QuoteDate);
    qstSales: QuoteList.sort(@QuoteSales);
    qstGPPC: QuoteList.Sort(@QuoteGPPC);
    qstAverageRate: QuoteList.sort(@QuoteRate);
    qstHours: QuoteList.sort(@QuoteHours);
  end;    // case
end;

procedure TDataCollector.GetMonitoringAccountArray(NotGraph: Boolean);
var
  cn,I,J,cnt : integer;
  MonitorDataRec : TPlanDataRecPtr;
  varg : variant;
  TempTitle : array [0..60] of char;
//  TempPlanTotal : currency;
//  TempDetail: TDetailedBalArray;
  OldStr, Newstr : string;
begin
  if Assigned(MonitoringExpDataList) then
    begin
    if MonitoringExpDataList.Count > 0 then
      ClearMonitorExpDataList;
    end
  else
    MonitoringExpDataList := Tlist.create;
  fillchar(DetailedArray, sizeof(TDetailedBalArray), #0);
//  TotalPastBalance := 0;
  MonitoringExpLoaded := False;
  DetailedTotal := True;
  cnt := 0;
  for cn := FIRSTEXPENSE to TOTALEXPENSES do
    begin
    Varg := cn;
    if DataModuleClient.AccountDetails.Locate('Account_Number',varg,[]) then
      begin
      fillchar(DetailedArray, sizeof(TDetailedBalArray), #0);
      StrPcopy(tempTitle , '');
      getAccountTitle(TempTitle, cn);
      if (strlen(TempTitle) > 0) then
        begin
        new(MonitorDatarec);
        FillChar(MonitorDatarec^, sizeof(TPlanDataRecType), #0);
        MonitorDatarec.Accountno := cn;
        // Get Account Titles
        OldStr := strpas(temptitle);
        if (Not SearchStr(OldStr, ' /')) and (Not SearchStr(OldStr, '/ ')) then
          Newstr := searchAndReplace(Oldstr, '/', ' / ')
        else
          NewStr := OldStr;
        strPcopy(MonitorDatarec^.AccountTitle, NewStr);
        if MonitorDataRec.AccountSubTitle = 'W' then
          MonitorDataRec.WagesCB := cbChecked
        else
          MonitorDataRec.WagesCB := cbUnChecked;
        MonitoringExpDataList.Add(MonitorDataRec);
        end;
      end;
    if Cn = TOTALOTHEREXPENSES then
      sortExpenseList(False);
    end;
  MonitoringExpLoaded := True;
  // Start loading a new array
  fillchar(MonitoringAccountarray, MONITORINGACCOUNTLIST, #0);
  if NotGraph then
    begin
    for I := getaccountlistindex(SALES) to getaccountlistindex(GROSSPROFIT) do
      begin   // Iterate
      MonitoringAccountArray[cnt] := SummaryPlan[I];
      Inc(cnt);
      end;
    end
  else
    begin
    for I := getaccountlistindex(SALES) to getaccountlistindex(NETPROFIT) do
      begin   // Iterate
      MonitoringAccountArray[cnt] := SummaryPlan[I];
      inc(cnt);
      end;
    end;
  for cn := 0 to MonitoringExpDataList.count - 1 do
    begin
    MonitorDataRec := TPlanDataRecPtr(MonitoringExpDataList.items[cn]);
    MonitoringAccountArray[cnt] := MonitorDataRec.accountNo;
    Inc(cnt);
    end;
  if NotGraph then
    begin
    for J := getaccountlistindex(NETOPERATINGPROFIT) to getaccountlistindex(NETPROFIT) do    // Iterate
      begin
      MonitoringAccountArray[cnt] := SummaryPlan[J];
      inc(cnt);
      end;    // for
    end;
  // Collapse the monitoringExpDataList
  if MonitoringExpDataList.Count > 0 then
    ClearMonitorExpDataList;
  MonitoringExpLoaded := False;
end;

procedure TDataCollector.GetDetailedOptions;
begin
  GetConsolidatedList(False);
  GetBalances(DetailedOptions, DETAILEDOPT, True);
end;

procedure TDataCollector.SetDetailedOptions;
begin
  GetConsolidatedList(False);
  SetBalances(DetailedOptions, DETAILEDOPT, True);
end;

function TCashFlowEngine.totalBalanceArray(const balances: array of currency): currency;
var
  balIndex: integer;
begin
  result := 0;
  for balIndex := 0 to PeriodCount -1 do
    result  := result + balances[balIndex];
end;
{ ---------------------------------------------------------------------------- }
{ -- roundCurrency - Rounds the passed currency to the required decimal places }
{ ---------------------------------------------------------------------------- }
function TcashFlowEngine.roundCurrency(var value: currency; const noDP: smallint): currency;

  function decimalpicture(noDP: smallint):string;
  var
     c : byte;
  begin
    result:='';
    for c := 1 to noDp do
      result := result+'0';
    if noDp > 0 then result := '.'+result;
    result := '0' + result;
    for c := 2 to 3 do   {Could substitute number in thousands group WININI here}
      result := '#'+ result;
    result:= '#'+ result;
  end;
var
  numStr: string;
begin
  // Convert to string rounded to noDP
  numStr := FormatFloat(DecimalPicture(noDp), value);

  // then convert it back
  value := StrToFloat(numStr);
  result := Value;
end;

// MonthFrom , MonthTo are zerobased, Moving average and Opening balance and Var for array
procedure TCashFlowEngine.calculateBSDays(monthFrom, MonthTo, moveAvg: integer; CFType : TCashFlowType);
var
  monthNum, mths: integer;
  daysInMonth: TDateTime;
  temp, OpeningBal: currency;
  BSAccountRec : TCashFlowRecPtr;
  BSDaysRec : TCashFlowRecPtr;
  CFInputRec : TCashFlowRecPtr;
  CFOutputRec : TCashFlowRecPtr;
begin
// All these types calculate Days outstanding based on a default of 2 months of "Input" averaged
// against the current period Balance
  BSAccountRec := Nil;
  BSDaysRec := Nil;
  CFInputRec := Nil;
  CFOutputRec := Nil;
  case CFType of    //
    cfReceivables:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_REC)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AR_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_GROSS_SALES)]);
      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_RECEIPTS_AR)]);
      end;
    cfPayables:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_PAY)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AP_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_AP_INVOICES)]);
      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_PAYMENTS_AP)]);
      end;
    cfAccruedExpenses:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCRUED_EXPENSES)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AE_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(GROSS_EXPENSES_ACCRUED)]);
      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_PAYMENTS_AE)]);
      end;
  end;    // case

  if Moveavg = 0 then // default
    Moveavg := 2;
  // Zero the days o/s as were about to re-calculate it
  for monthNum := monthFrom to MonthTo do
    begin
    if MonthNum = 0 then
      OpeningBal := BSAccountRec.OpeningBalance
    else
      OpeningBal := BSAccountRec.planSummary[monthNum-1];

    // If no opening bal and days o/s and invoices are the same or less that the
    // cash receipts (Which are also non zero) then let the cash receipts equal
    // the invoices. (JM Not sure if this condition will ever be true
    // but TW orignal code includes it, so i did)
    if (OpeningBal = 0) and (BSDaysRec.planSummary[monthNum] = 0) and
       (CFInputRec.planSummary[monthNum] <= CFOutputRec.Plansummary[monthNum]) and
       (CFInputRec.planSummary[monthNum] <> 0) then
        CFOutputRec.Plansummary[monthNum] := CFInputRec.planSummary[monthNum];

    // Work out the total receivable for this period
    temp := OpeningBal + CFInputRec.Plansummary[monthNum];

    // If its less then the cash receipts then let the receipts equal it
    if temp < CFOutputRec.Plansummary[monthNum] then
      CFOutputRec.Plansummary[monthNum] := temp;

    // Now subtract the cash receipts from the opening balance
    temp := temp - CFOutputRec.Plansummary[monthNum];

    // Set the closing balance
    BSAccountRec.planSummary[monthNum]:= temp;

    // Initialise value
    BSDaysRec.planSummary[monthNum] := 0;
    // Now work out the days o/s for this period, only if there is a balance to work with
    if temp <> 0 then
      begin
      Mths := MonthNum - moveAvg;
      if Mths < 0 then
        DaysInMonth := SummaryPeriodIndexArray[Mths] + 1
      else
        DaysInMonth := SummaryPeriodIndexArray[MonthNum] - SummaryPeriodIndexArray[Mths] + 1;
      mths := MonthNum;
      temp := 0;
      while (Mths >= 0) and ((MonthNum - mths) < moveavg) do
        begin
        temp := temp + CFInputRec.planSummary[mths];
        dec(mths);
        end;    // while

      if BSAccountRec.planSummary[monthNum] <> 0 then
        if temp <> 0 then
          BSDaysRec.planSummary[monthNum] := BSAccountRec.planSummary[monthNum] * daysInMonth / temp
        else
          BSDaysRec.planSummary[monthNum] := 0;

      roundCurrency(BSDaysRec.planSummary[monthNum], 2);
      end;
    end;
end;

procedure TCashFlowEngine.defineBSDays(cfType : TCashFlowType);
var
  defDays, totDaysOS, totSalesInv: currency;
  curMonth: integer;
  daysInMonth: TDateTime;
  BSAccountRec : TCashFlowRecPtr;
  BSDaysRec : TCashFlowRecPtr;
  CFInputRec : TCashFlowRecPtr;
//  CFOutputRec : TCashFlowRecPtr;
begin
  BSAccountRec := Nil;
  BSDaysRec := Nil;
  CFInputRec := Nil;
//  CFOutputRec := Nil;
  case CFType of    //
    cfReceivables:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_REC)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AR_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_GROSS_SALES)]);
//      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_RECEIPTS_AR)]);
      end;
    cfPayables:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_PAY)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AP_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_AP_INVOICES)]);
//      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_PAYMENTS_AP)]);
      end;
    cfAccruedExpenses:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCRUED_EXPENSES)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AE_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(GROSS_EXPENSES_ACCRUED)]);
//      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_EXPENSES_PAID)]);
      end;
  end;    // case

  // Total the number of days + invoices
  totDaysOS := totalBalanceArray(BSDaysRec.PlanSummary);
  totSalesInv := totalBalanceArray(CFInputRec.PlanSummary);
  // If there are no days but there is an opening balance, calculate
  // default days
  if (totDaysOS = 0) and (BSAccountRec.OpeningBalance <> 0) then
    begin
    daysInMonth := Trunc(pedate) - trunc(psdate) + 1;
    if totSalesInv <> 0 then
      defDays := BSAccountRec.OpeningBalance * daysInMonth / totSalesInv
    else
      defDays := 0;

    roundCurrency(defDays, 2);

    for curMonth := 0 to PeriodCount - 1 do
      begin
      BSDaysRec.PlanSummary[curMonth] := defDays;
      calculateBSBalance(curMonth, 2, cfType);
      end;
    end;
end;

procedure TCashFlowEngine.calculateBSBalance(month, moveAvg: integer; cfType : TCashFlowType);
var
  mths: integer;
  temp: currency;
  daysInMonth: TDateTime;
  OpeningBal : Currency;
  BSAccountRec : TCashFlowRecPtr;
  BSDaysRec : TCashFlowRecPtr;
  CFInputRec : TCashFlowRecPtr;
  CFOutputRec : TCashFlowRecPtr;
begin
  BSAccountRec := Nil;
  BSDaysRec := Nil;
  CFInputRec := Nil;
  CFOutputRec := Nil;
  case CFType of    //
    cfReceivables:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_REC)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AR_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_GROSS_SALES)]);
      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_RECEIPTS_AR)]);
      end;
    cfPayables:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_PAY)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AP_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_AP_INVOICES)]);
      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_PAYMENTS_AP)]);
      end;
    cfAccruedExpenses:
      begin
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCRUED_EXPENSES)]);
      BSDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AE_DAYS)]);
      CFInputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(GROSS_EXPENSES_ACCRUED)]);
      CFOutputRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_PAYMENTS_AE)]);
      end;
  end;    // case
  // If there are days  then use that to calculate the balance
  if Month = 0 then
    OpeningBal := BSAccountRec.OpeningBalance
  else
    OpeningBal := BSAccountRec.planSummary[month - 1];

  if BSDaysRec.PlanSummary[month] <> 0 then
    begin
    mths := 1;
    if Mths = 0 then
      DaysInMonth := SummaryPeriodIndexArray[Mths] + 1
    else
      DaysInMonth := SummaryPeriodIndexArray[Month] - SummaryPeriodIndexArray[Mths] + 1;
    mths := Month;
    temp := 0;
    while (Mths >= 0) and ((Month - mths) < moveavg) do
      begin
      temp := temp + CFInputRec.planSummary[mths];
      dec(mths);
      end;    // while

    BSAccountRec.PlanSummary[month] := (BSDaysRec.PlanSummary[month] * temp) / daysInMonth;
    roundCurrency(BSAccountRec.PlanSummary[month], 0);

    temp := OpeningBal + BSAccountRec.PlanSummary[month];
    if temp < BSAccountRec.PlanSummary[month] then
      BSAccountRec.PlanSummary[month] := temp;

    CFOutputRec.PlanSummary[month] := OpeningBal + CFInputRec.PlanSummary[month] - BSAccountRec.PlanSummary[month];
    roundCurrency(CFOutputRec.PlanSummary[month], 0);
    end
  else
    begin
    CFOutputRec.PlanSummary[month] := OpeningBal + CFInputRec.PlanSummary[month];
    BSAccountRec.PlanSummary[month] := 0;
  end;
end;
{
procedure TDataCollector.calculateSTOCKDays(monthFrom, MonthTo, moveAvg: integer);
var
  monthNum, mths: integer;
  daysInMonth: TDateTime;
  temp, OpeningBal: currency;
  STOCKDataRec : TCashFlowRecPtr;
  STOCKDaysRec : TCashFlowRecPtr;
  STOCKTotalInvRec : TCashFlowRecPtr;
  STOCKTotalRecRec : TCashFlowRecPtr;
begin
  STOCKDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK)]);
  STOCKDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DAYS)]);
  STOCKTotalInvRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_SOLD)]);
  STOCKTotalRecRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DELIVERIES)]);
}
{ ---------------------------------------------------------------------------- }
{ -- calculateStockturn - Calculate balances for stockturns, opening balance    }
{                        and stock delivery                                    }
{ ---------------------------------------------------------------------------- }
procedure TCashFlowEngine.calculateStockturn(monthFrom, MonthTo, moveAvg: integer);
var
  monthNum, mths: integer;
  daysInMonth: TDateTime;
  temp: currency;
  STOCKDataRec : TCashFlowRecPtr;
  STOCKDaysRec : TCashFlowRecPtr;
  STOCKTotalInvRec : TCashFlowRecPtr;
  STOCKTotalRecRec : TCashFlowRecPtr;
  OpeningBal : currency;
begin
  STOCKDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK)]);
  STOCKDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DAYS)]);
  STOCKTotalInvRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_SOLD)]);
  STOCKTotalRecRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DELIVERIES)]);
  if MoveAvg = 0 then
    Moveavg := 2;
  for monthNum := monthFrom to MonthTo do
    begin
    if Monthnum = 0 then
      OpeningBal := STOCKDataRec.OpeningBalance
    else
      OpeningBal := STOCKDataRec.PLanSummary[MonthNum - 1];

    // Work out the closing balance for the month
    temp := abs(OpeningBal) - abs(STOCKTotalInvRec.PlanSummary[monthNum]);

    // If its less then zero and less then the stock delivery then make them equal
    if (temp < 0) and ( abs(temp) > STOCKTotalRecRec.PlanSummary[monthNum]) then
      STOCKTotalRecRec.PlanSummary[monthNum] := abs(temp); //????

    // Now add stoc                       k delivery to the opening balance
    temp := temp + STOCKTotalRecRec.PlanSummary[monthNum];
    // Set the closing balance
    STOCKDataRec.PLanSummary[monthNum] := temp;

    mths := 0;
    temp := 0;
    daysInMonth := 0;
    while( (monthNum + mths) <= PeriodCount) and (mths < moveAvg) do
      begin
      inc(mths);
      // Add up all the cost of goods
      temp := temp + STOCKTotalInvRec.PlanSummary[MonthNum + mths];
      // this is incremented here to ensure we get the right maximum - not very efficient.
      daysInMonth := SummaryPeriodIndexArray[MonthNum + mths];
      end;
    if MonthNum > 0 then
      daysInMonth := DaysInMonth - SummaryPeriodIndexArray[MonthNum - 1];
    // Zero the stockturns as were about to re-calculate it
    STOCKDaysRec.PlanSummary[monthNum] := 0;
    // Calculate Stock Days First
    if STOCKDataRec.PLanSummary[monthNum] <> 0 then
      if temp <> 0 then
        STOCKDaysRec.PlanSummary[monthNum] := STOCKDataRec.PLanSummary[monthNum] * daysInMonth / temp
      else
        STOCKDaysRec.PlanSummary[monthNum] := 0;
  //end;
    // Calculate Stockturns here
    if STOCKDaysRec.PlanSummary[monthNum] <> 0 then
      STOCKDaysRec.PlanSummary[monthNum] := 365 / STOCKDaysRec.PlanSummary[monthNum];

    if STOCKDataRec.PLanSummary[monthNum] = 0 then
      STOCKDaysRec.PlanSummary[monthNum] := 0;

    roundCurrency(STOCKDaysRec.PlanSummary[monthNum], 2);
    end;
end;

{ ---------------------------------------------------------------------------- }
{ -- defineStockturn - Called when setting the opening balance figure. If there}
{                      is no stockturn calculate the default based on the OPBal}
{ ---------------------------------------------------------------------------- }
procedure TCashFlowEngine.defineStockturn(moveAvg: integer);
var
  defDays, totStockturns, totCOGS: currency;
  curMonth: integer;
  daysInMonth: TDateTime;
  STOCKDataRec : TCashFlowRecPtr;
  STOCKDaysRec : TCashFlowRecPtr;
  STOCKTotalInvRec : TCashFlowRecPtr;
//  STOCKTotalRecRec : TCashFlowRecPtr;
//  OpeningBal : currency;
begin
  STOCKDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK)]);
  STOCKDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DAYS)]);
  STOCKTotalInvRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_SOLD)]);
//  STOCKTotalRecRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DELIVERIES)]);
  // Total the number of stockturns
  totStockturns := totalBalanceArray(STOCKDaysRec.PlanSummary);
  totCOGS := totalBalanceArray(STOCKTotalInvRec.PlanSummary);
//  OpeningBal := STOCKDataRec.OpeningBalance;
  // If there are no stickturns but there is an opening balance, calculate
  // default stockturns
  if (totStockturns = 0) and (STOCKDataRec.OpeningBalance <> 0) then
    begin

    daysInMonth := SummaryPeriodIndexArray[PeriodCount - 1];

    if totCOGS <> 0 then
      DefDays := STOCKDataRec.OpeningBalance * daysInMonth / totCogs
    else
      defDays := 0;
    // Calculate Stockturns here
    if DefDays <> 0 then
      DefDays := 365 / DefDays;

    roundCurrency(defDays, 2);

    for curMonth := 1 to PeriodCount do
      begin
      STOCKDaysRec.PlanSummary[Curmonth] := defDays;
      calculateStockturn(curMonth, CurMonth, MoveAvg);
      end;
    end;
end;

{ ---------------------------------------------------------------------------- }
{ -- calculateBalances - Calculate the closing balance from the stockturn    }
{                          for the passed month                                }
{ ---------------------------------------------------------------------------- }
procedure TCashFlowEngine.calculateStockBalances(month, moveAvg: integer);
var
  mths: integer;
  temp, tempDays: currency;
  daysInMonth: TDateTime;
  STOCKDataRec : TCashFlowRecPtr;
  STOCKDaysRec : TCashFlowRecPtr;
  STOCKTotalInvRec : TCashFlowRecPtr;
  STOCKTotalRecRec : TCashFlowRecPtr;
  OpeningBal : currency;
begin
  STOCKDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK)]);
  STOCKDaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DAYS)]);
  STOCKTotalInvRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_SOLD)]);
  STOCKTotalRecRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DELIVERIES)]);
  if Month = 0 then
    OpeningBal := STOCKDataRec.OpeningBalance
  else
    OpeningBal := STOCKDataRec.PLanSummary[Month - 1];

  // If there is a stockturn then use that to calculate the balance
  if STOCKDaysRec.PLanSummary[month] <> 0 then
    begin
    // Convert StockTurns into Days OS
    tempDays := 365 / STOCKDaysRec.PLanSummary[month];
    // Add up all the cost of goods
    mths := 0;
    temp := 0;
    daysInMonth := 0;
    while( (month + mths) <= PeriodCount) and (mths < moveAvg) do
      begin
      inc(mths);
      // Add up all the cost of goods
      temp := temp + STOCKTotalInvRec.PlanSummary[Month + mths];
      // this is incremented here to ensure we get the right maximum - not very efficient.
      daysInMonth := SummaryPeriodIndexArray[Month + mths];
      end;
    if Month > 0 then
      daysInMonth := DaysInMonth - SummaryPeriodIndexArray[Month - 1];

// jm 22.05.98 replace with the above
//    for curMonth := month+1 to NumberOfMonths do
//      temp := temp + mCostofGoods[curMonth];

    if daysInMonth <> 0 then
      STOCKDataRec.PLanSummary[month] := tempDays * temp / daysInMonth
    else
      STOCKDataRec.PLanSummary[month] := 0;

    temp := OpeningBal - STOCKDataRec.PLanSummary[month];

    if (temp > 0) and (temp > STOCKDataRec.PLanSummary[month]) then
      STOCKDataRec.PLanSummary[month] := temp;

// Very suspicious, 25.05.98 Should now be OK. STOCKDataRec.PLanSummary[month]
    STOCKTotalRecRec.PlanSummary[month] := STOCKDataRec.PLanSummary[month] + STOCKTotalInvRec.PlanSummary[month] - OpeningBal;
    end
  else
    begin
    STOCKTotalRecRec.PlanSummary[month] := STOCKTotalInvRec.PlanSummary[month];
    STOCKDataRec.PLanSummary[month] := 0;
    end;
  roundCurrency(STOCKTotalRecRec.PlanSummary[month], 0);
  roundCurrency(STOCKDataRec.PLanSummary[month], 0);
end;

procedure TCashFlowEngine.ProcessExpenses;
var
  I: Integer;
  BSAccountRec : TCashFlowRecPtr;
  ExpAccountRec : TDetailedBalArray;
  AccumulatedAdjustment : Currency;
  Taxamount : Currency;
  BSAccountNo : integer;
begin
{
    function getBalances(var Balances : array of currency; Accountno : integer; UsePlanData: Boolean): Boolean;
    function setBalances(var Balances : array of currency; Accountno : integer; UsePlanData: Boolean): Boolean;
}
  // initialise
  FillChar(ExpensesViaAPRec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  FillChar(TaxExpensesAPRec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  FillChar(GrossExpviaAPRec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  FillChar(ExpensesAERec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  FillChar(TaxExpensesAERec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  FillChar(GrossExpensesAccruedRec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  FillChar(ARAdjustmentsRec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  FillChar(STOCKAdjustmentsRec.PlanDetail, Sizeof(TDetailedBalArray), #0);

  DataModuleClient.ExpAccounts.First;
  while DataModuleClient.ExpAccounts.Eof = False do
    begin
    if DataModuleClient.ExpAccountsNON_CASH.value > 0 then
      begin
      // we must have a BS account to update
      BSaccountNo := DataModuleClient.Dept_AccountsBALANCE_SHEET_ACCOUNT.value;
      if BSAccountNo = ACCOUNT_REC then
        BSAccountNo := AR_ADJUSTMENTS;
      if BSAccountNo = STOCK then
        BSAccountNo := ST_ADJUSTMENTS;
      BSAccountRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(BSAccountNo)]);
      if DataCollect.getbalances(ExpAccountRec, DataModuleClient.ExpAccountsACCOUNT_NUMBER.Value, True) then
        begin
        AccumulatedAdjustment := 0
        for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
          begin
          AccumulatedAdjustment := AccumulatedAdjustment + ExpAccountRec[I];
          BSAccountRec.plandetail[I] := BSAccountRec.plandetail[I] - Accumulatedadjustment;
          end;    // for
        end;
      end
    else
    if DataModuleClient.Dept_AccountsPAID_VIA_AP.Value > 0 then // accumulate and calc tax for AP
      begin
      if DataCollect.getbalances(ExpAccountRec, DataModuleClient.ExpAccountsACCOUNT_NUMBER.Value, True) then
        begin
        for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
          begin
          // calc and add tax to AP expenses tax
          Taxamount := 0;
          if DataModuleClient.Dept_AccountsTAX_RATE.Value > 0 then
            taxAmount := ExpAccountrec[I] * DataModuleClient.Dept_AccountsTAX_RATE.Value;
          // add to net and calc Gross value, day by day
          ExpensesViaAPRec.PlanDetail[i] := ExpensesViaAPRec.PlanDetail[i] + ExpaccountRec[i];
          TaxExpensesAPRec.PlanDetail[I] := TaxExpensesAPRec.PlanDetail[I] + Taxamount;
          GrossExpviaAPRec.PlanDetail[i] := ExpensesViaAPRec.PlanDetail[i] + TaxExpensesAPRec.PlanDetail[I];
          end;
        end;    // for
      end
    else // catch all else
      begin
      if DataCollect.getbalances(ExpAccountRec, DataModuleClient.ExpAccountsACCOUNT_NUMBER.Value, True) then
        begin
        for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
          begin
          // calc and add tax to AP expenses tax
          Taxamount := 0;
          if DataModuleClient.Dept_AccountsTAX_RATE.Value > 0 then
            taxAmount := ExpAccountrec[I] * DataModuleClient.Dept_AccountsTAX_RATE.Value;
          // add to net and calc Gross value, day by day
          ExpensesAERec.PlanDetail[i] := ExpensesAERec.PlanDetail[i] + ExpaccountRec[i];
          TaxExpensesAERec.PlanDetail[I] := TaxExpensesAERec.PlanDetail[I] + Taxamount;
          GrossExpensesAccruedRec.PlanDetail[i] := ExpensesAERec.PlanDetail[i] + TaxExpensesAERec.PlanDetail[I];
          end;
        end;    // for
      end;
    DataModuleClient.ExpAccounts.next;
    end;    // while
end;

procedure TCashFlowEngine.CalculateAll;
var
  I: Integer;
  TaxRateSales, StaxAmt : Currency;
  TaxrateSubcon, BTaxAmt : Currency;
  TaxRateCOGS, CtaxAmt : Currency;
begin
// 1. Initialise balance sheet balances with their opening balance
  I := DataCollect.GetUserOption(OPERIODSIZE, UOInteger);
  Periodcount := createSummaryIndex(I, psdate, pedate);
  I := 0;
  while CashFlowMain[I] <> SALES do
    begin
    SetBSBalance(TCashFlowRecPtr(CashFlowDataList.Items[I]));
    inc(i);
    end;    // while
// 2. process expenses
  DataModuleClient.BSAccounts.active := True;
  DataModuleClient.ExpAccounts.Active := True;
  DataModuleClient.Dept_Accounts.Active := False;
  DataModuleClient.Dept_Accounts.Filter := 'DEPT_ID=' + DataModuleClient.DepartmentsDEPT_ID.AsString;
  DataModuleClient.Dept_Accounts.Filtered := True;
  DataModuleClient.Dept_Accounts.active := True;
  CreateDeptExpenseAccountRecords;

  // make list of Expenses that affect BS accounts.
  // All non cash expenses must affect BS accounts.
  // get detailed balance and make the other side of the journal.
  ProcessExpenseAccounts;
  DataModuleClient.BSAccounts.active := False;
  DataModuleClient.ExpAccounts.Active := False;
  DataModuleClient.Dept_Accounts.Active := False;

// 3. process journals
      // All journals must only affect BS accounts except for tax and dividends which affect PNL Appropriation

// 4. calc AR, STOCK, AP, AE
      // Here we assume days have been calculated
  // first calculate tax added to net sales
  // Get tax on sales, COGS and Subcons
  TaxRateSales := DataCollect.GetUserOption(OTAXRATE_SALES, UOCurrency);
  TaxrateSubcon := DataCollect.GetUserOption(OTAXRATE_SUBCON, UOCurrency);
  TaxRateCOGS := DataCollect.GetUserOption(OTAXRATE_STOCK, UOCurrency);
  FillChar(ARCashReceiptsRec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
    begin
    TAXSalesRec.PlanDetail[i] := 0
    if TaxRateSales > 0 then
      TAXSalesRec.PlanDetail[i] := SalesRec.PlanDetail[I] * TaxRateSales;
    GrossSalesRec.PlanDetail[I] := SalesRec.PlanDetail[I] + TAXSalesRec.PlanDetail[i]
    end;    // for
  // buildsummary array for sales
  BuildSummary(GrossSalesRec.accountNo, True, GrossSalesRec.PlanDetail, GrossSalesRec^.planSummary);
  // calculate cash receipts and balances
  for I := 0 to PeriodCount - 1 do    // Iterate
    begin
    calculateBSBalance(I, moveAvg, cfReceivables);
    // update detailed array for cash receipts
//    function TDataCollector.updateArray(var barray: array of currency; PeriodStart, StartDate, EndDate: double;
                     new: currency; roundto: Extended): boolean;
    if I = 0 then
      updateArray(ARCashReceiptsRec.PlanDetail,
                  double(psdate),
                  double(psdate),
                  double(psdate + DataCollect.SummaryPeriodIndexArray[I]),
                  ARCashReceiptsRec.PlanSummary[I],
                  2)
    else
      updateArray(ARCashReceiptsRec.PlanDetail,
                  double(psdate),
                  double(psdate + DataCollect.SummaryPeriodIndexArray[I - 1]),
                  double(psdate + DataCollect.SummaryPeriodIndexArray[I]),
                  ARCashReceiptsRec.PlanSummary[I],
                  2);
    end;
  for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
    begin
    if I = 0 then
      ARDataRec.PlanDetail[I] := ARDataRec.OpeningBalance + GrossSalesRec.PlanDetail[I] - ARCashReceiptsRec.PlanDetail[I]
    else
      ARDataRec.PlanDetail[I] := ARDataRec.PlanDetail[I - 1] + GrossSalesRec.PlanDetail[I] - ARCashReceiptsRec.PlanDetail[I];
    end;    // for

//  calculateBSBalance(month, moveAvg: integer; cfType : TCashFlowType);
// 5. calc TAX

// 6. calc BANK
  for I := 0 to PeriodCount - 1 do    // Iterate
    begin
;
    end;    // for
end;

procedure TCashFlowEngine.SetBSBalance(BSrec : TCashFlowRecPtr);
var
  I, K: Integer;
begin
  // initialise the detail array
  FillChar(BSRec.PlanDetail, Sizeof(TDetailedBalArray), #0);
  if (BSRec.Openingbalance <> 0) then
    begin
    K := 0;
    for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
      begin
      BSrec.PlanDetail[I] := BSRec.Openingbalance;
      end;    // for
    end;
  BuildBSSummary(BSrec);
end;

procedure TCashFlowEngine.UpdateBSBalance(BSrec : TCashFlowRecPtr; newBalance : Currency; ForceUpdate : Boolean);
var
  I, K: Integer;
  adjustbal : currency;
begin
  if BSRec.PlanTotal = 0 then
    adjustbal := newbalance
  else
    adjustbal := newBalance - BSREC.OpeningBalance;
  if (AdjustBal <> 0) or (ForceUpdate) then
    begin
    K := 0;
    for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
      begin
      if ForceUpdate then
        BSrec.PlanDetail[I] := adjustbal
      else
        BSrec.PlanDetail[I] := BSrec.PlanDetail[I] + adjustbal;
      end;    // for
    end;
  BSrec.OpeningBalance := newbalance;
  BuildBSSummary(BSrec);
end;

procedure TCashFlowEngine.BuildBSSummary(BSrec : TCashFlowRecPtr);
var
  I, K: Integer;
begin
  K := 0;
  while SummaryPeriodIndexArray[k] <> 0 do
    begin
    BSrec.PlanSummary[K] := BSrec.plandetail[SummaryPeriodIndexArray[k]];
    inc(k);
    end;    // while
{  for I := 0 to trunc(peDate) - trunc(psDate) + 1 do    // Iterate
    begin
      if (SummaryPeriodIndexArray[k] = I) then
        begin
        BSrec.PlanSummary[K] := BSrec.plandetail[I];
        inc(k);
        end;    // while
    end;    // for
}
end;

constructor TCashFlowEngine.create(StartDate, EndDate: TDateTime; PeriodType: integer);
begin
  psdate := StartDate;
  Pedate := EndDate;
  PeriodType := PeriodType; // Default is 4 = monthly
  DataCollect.GetConsolidatedList(False);
  PeriodCount := createSummaryIndex(PeriodType, psdate, pedate);
  // get the list filled
  getCashFlowData;
  // Set up the pointers
  BankDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_AT_BANK)]);
  ARDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_REC)]);
  StockDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK)]);
  CMFDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_MAN_FUND)]);
  MSDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(MARKETSEC)]);
  OCADataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(OTHER_CURRENT_ASSETS)]);
  NDADataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(NON_DEP_ASSETS)]);
  DADataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(DEP_ASSETS)]);
  IADataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(INTANG_ASSETS)]);
  BankODDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(BANK_OVERDRAFT)]);
  APDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCOUNT_PAY)]);
  AEDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ACCRUED_EXPENSES)]);
  TAXPAYDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TAX_PAYABLE)]);
  INCTAXDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(INC_TAX_PAYABLE)]);
  DIVDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(DIVIDENDS_PAYABLE)]);
  OCLDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(OTHER_CURRENT_LIAB)]);
  LOANSDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(LOANS)]);
  EQUITYDataRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(EQUITY)]);
//     GROSSPROFIT, , // STOCK SOLD is SALES - GP - SUBCONTRACTORS
  SalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(SALES)]);
  StockSoldRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_SOLD)]);
  SubcontractorsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(SUBCONTRACTORS)]);
  TAXSalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TAX_ON_SALES)]);
  GrossSalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_GROSS_SALES)]);
  ARCashReceiptsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_RECEIPTS_AR)]);
  ARAdjustmentsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AR_ADJUSTMENTS)]);
  StockDeliveriesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DELIVERIES)]);
  TaxStockRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TAX_ON_STOCK_DELIVERIES)]);
  GrossStockDelRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(GROSS_STOCK_PURCHASES)]);
  StockAdjustmentsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(ST_ADJUSTMENTS)]);
  TaxSubcontractorsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TAX_ON_SUBCONTRACTORS)]);
  GrossSubContractorsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(GROSS_SUBCONTRACTORS)]);
  CashManagementDepsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_MAN_DEPOSITS)]);
  CashmanagementWdrlsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_MAN_WITHDRAWALS)]);
  MarketSecPurchasesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(MARKET_SEC_PURCHASES)]);
  MarketSecSalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(MARKET_SEC_SALES)]);
  OtherAssetsPurchRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(OTHER_ASSETS_PURCHASES)]);
  OtherAssetsSalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(OTHER_ASSETS_SALES)]);
  NonDepnAssetsPurchRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(NON_DEP_ASSET_PURCHASES)]);
  NonDepnAssetsSalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(NON_DEP_ASSET_SALES)]);
  DepnAssetsPurchRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(DEP_ASSET_PURCHASES)]);
  DepnAssetsSalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(DEP_ASSET_SALES)]);
  IntangAssetsPurchRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(INTANG_ASSET_PURCHASES)]);
  IntangAssetsSalesRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(INTANG_ASSET_SALES)]);
  ExpensesViaAPRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(NET_EXPENSES_VIA_AP)]);
  TaxExpensesAPrec := TcashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TAX_EXPENSES_VIA_AP)]);
  GrossExpviaAPRec := TcashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(GROSS_EXPENSES_VIA_AP)]);
  TotalInvoiceAPRec := TcashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_AP_INVOICES)]);
  CashPaymentsAPRec := TCashFlowrecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_PAYMENTS_AP)]);
  APAdjustmentsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AP_ADJUSTMENTS)]);
  ExpensesAERec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(NET_EXPENSES_ACCRUED)]);
  TaxExpensesAERec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TAX_EXPENSES_ACCRUED)]);
  GrossExpensesAccruedRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(GROSS_EXPENSES_ACCRUED)]);
  CashPaymentsAERec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(CASH_PAYMENTS_AE)]);
  AEAdjustmentsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AE_ADJUSTMENTS)]);
  TotalTaxCollectedRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_TAX_COLLECTED)]);
  TotalTaxPaidRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TOTAL_TAX_PAID)]);
  TaxAdjustmentsRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(TAX_ADJUSTMENTS)]);
  NetTaxPayableRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(INC_TAX_INCURRED)]);
  NetTaxRefundRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(INC_TAX_PAID)]);
  DividendDeclaredRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(DIV_DECLARED)]);
  DividendPaidRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(DIV_PAID)]);
  OtherLiabIncurredRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(OTHER_LIAB_INCURRED)]);
  OtherLiabPaidRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(OTHER_LIAB_PAID)]);
  LoansIncurredRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(LOANS_INCURRED)]);
  LoansRepaidRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(LOANS_REPAID)]);
  EquityInjectedRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(EQUITY_INJECTED)]);
  EquityWithdrawnRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(EQUITY_WITHDRAWN)]);
  AR_DaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AR_DAYS)]);
  Stock_DaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(STOCK_DAYS)]);
  AP_DaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AP_DAYS)]);
  AE_DaysRec := TCashFlowRecPtr(CashFlowDataList.Items[GetCashFlowAccountIndex(AE_DAYS)]);
end;

destructor TCashFlowEngine.Destroy;
begin
  // Save Account balances
  setCashFlowData;
  // Call XXX to tidy up Account List
  clearCashFlowDataList;
  inherited destroy;
end;

procedure TCashFlowEngine.CreateDeptExpenseAccountRecords;
var
  Isdepn : Boolean;
begin
  DataModuleClient.ExpAccounts.First;
  while DataModuleClient.ExpAccounts.Eof = false do
    begin
    if DataModuleClient.ExpAccountsACCOUNT_TITLE.Value > '' then
      begin
      isDepn := False;
      if DataModuleClient.ExpAccountsACCOUNT_TITLE.Value = 'Depreciation' then
        begin
        isDepn := True;
        DataModuleClient.ExpAccounts.Edit;
        DataModuleClient.ExpAccountsNON_CASH.value := 1;
        DataModuleClient.ExpAccounts.Post;
        end;
      if DataModuleClient.Dept_Accounts.RecordCount = 0 then
        begin
          DataModuleClient.Dept_Accounts.INSERT;
          DataModuleClient.Dept_AccountsDEPT_ID.Value := DataModuleClient.DepartmentsDEPT_ID.Value;
          DataModuleClient.Dept_AccountsACCOUNT_NUMBER.Value := DataModuleClient.ExpAccountsACCOUNT_NUMBER.Value;
          DataModuleClient.Dept_Accounts.Post;
        end;
      if (isdepn = True) and (DataModuleClient.Dept_AccountsBALANCE_SHEET_ACCOUNT.Value <> 1310)  then
        DataModuleClient.Dept_AccountsBALANCE_SHEET_ACCOUNT.Value := 1310;
      end;
    DataModuleClient.ExpAccounts.Next;
    end;    // while
  DataModuleClient.ExpAccounts.First;
end;


function GetFileModDate(Filename: String): TDateTime;
var
  Handle_Info : _BY_HANDLE_FILE_INFORMATION;
  FileNameC : array [0..200] of char;
  FileHandle : THandle;
  Systime : TSystemTime;
//  FileInfo : TWin32FileInfoData;
begin
  StrPCopy(FileNameC, FileName);
  if Not FileExists(FileName) then
    FileHandle := createfile(FileNameC, DWord(GENERIC_WRITE),
      DWord(FILE_SHARE_WRITE), nil, DWord(CREATE_NEW), DWord(FILE_ATTRIBUTE_HIDDEN), 0)
  else
    FileHandle := createfile(FileNameC, DWord(GENERIC_READ),
      DWord(FILE_SHARE_READ), nil, DWord(OPEN_EXISTING), DWord(FILE_ATTRIBUTE_HIDDEN), 0);

  if FileHandle = INVALID_HANDLE_VALUE then
    begin
    GetLastError;
    Result := 0;
    exit;
    end;
  if GetFileInformationByHandle(hfile(FileHandle), Handle_Info) then
    begin
    FileTimeToSystemTime(_FileTime(Handle_Info.ftLastWriteTime), Systime);
    Result := SystemTimeToDateTime(systime);
    end
  else
    Result := 0;
  CloseHandle(FileHandle);
end;

function ReportFileInuse(Filename: String): Boolean;
var
  FName, fname1, tmpfile : string;
begin
  result := True;
  FName := fileName;
  Fname1 := ChangeFileExt(Fname, '');
  tmpfile := fname1 + '.tmp';
  if fileexists(tmpfile) then
    DeleteFile(tmpfile);
  if (RenameFile(Filename, tmpfile)) then
    begin
    renameFile(tmpfile, filename);
    Result := False;
    end;
end;

function CheckFileName(basefolder, filename: String): string;
var
  I: Integer;
  FName, fname1, Fext, goodname, flname, tmpfile : string;
begin
  FName := BaseFolder + fileName;
  fext := ExtractFileExt(Filename);
  Fname1 := ChangeFileExt(Fname, '');
  tmpfile := fname1 + '.tmp';
  if fileexists(tmpfile) then
    DeleteFile(tmpfile);
  goodname := '';
  if fileexists(Fname) then
    begin
    for I := 0 to 10 do    // Iterate
      begin
      if I = 0 then
        flname := fname
      else
        flname := fname1 + '(' + inttostr(I) + ')' + fext;
      if not FileExists(flname) then
        begin
        if length(goodname) < 1 then
          Goodname := Flname;
        end
      else
        begin
        if (RenameFile(Flname, Fname1 + '.tmp')) then
          begin
          renameFile(fname1 + '.tmp', flname);
          if length(goodname) < 1 then
            Goodname := Flname;
          // Clean up
          deleteFile(flname);
          end;
        end;
      if fileexists(tmpfile) then
        DeleteFile(tmpfile);
      end;
    end;
  if length(goodname) < 1 then
    Result := fname
  else
    Result := goodname;
end;

procedure ShowConcatMessage(Flname: String);
begin
  showmessage('The Concatenation file (' + Flname + ') is still open preventing concatenation.'
   + #13#10#13#10 + 'The report will display but will not appended.' + #13#10#13#10 + 'Close Acrobat Reader to allow concatenation.');
end;

end.
