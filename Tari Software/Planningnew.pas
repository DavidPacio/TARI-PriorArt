ؑɊؑɊؑ͑ħюקĂ솊Đފϊ샑юק؊ŊқلފŊϧħ̊қϊħބϧބΑاބқґބҝґބّ؄ϑ̊ϙާĊħϙފϑޑΑ̊يΊϊ΄̊Ċϧ̊冊ĊˊΊқς̃ϊΊϊ̈́̊͂ŊߊŊӊϊΊيŊ؊يĆنŧѧ̊يϧĊħބˑӂӂӂ郑ӂ󃑧қϊқґ؊ŊŊϧħӂ҂σΑاΊϊފϊŊϊފފΊӧӂӂӂ郑ӂ󃑧Ƃ؂ΑקɊބ҂Ɋބ҂Ɋބ҂يɂބ΄σɂބބσ؊ŊيŊϧħɄɄɄΑاɄƊɄƊɄƑ؊ŊŊϧقΊϑΑϊϝ؂ؐރاؑħюקĂ솊Đ؊ϊ샑юקƛĊ͊ފٍ̊ƘĊބބފŊބ΄ޑ٘̊ϊϊˊފϊϊާڄϊ΂ς҂̊ڄϊħڄϊ΂ς҂ڄϊڄϑلϊƑτϊƑτϊƑ̊ބτϊĊħτҊęϊϑΧϊħτҊęϊϑΑފΊފϊ٧ϑފŊǊϊ̊Ŋيބ؊ŊŊϧħ̊ςكĊħςنςφςςφς憊ςφ惃ςςφΑΑاފϊފŧϊτҊϊϊ٧ɂΑϊɂފ؃اؑƐӑيӑސؑħϊϑފޑ̊ފϊϊيΧĊħ̊ςφރħςφފςφފςφރϧςφފςφފފފΑϊފǊ݊ħ̊ފ惊؊ފĊħ̊ςφƃΊςφĊħςφςφ惊ςφ̊͊Ċħςφ΂ςφςφ憊΂ςφ惃ΑΑ̊ςφƃħςφފƊŊΑϊϊϊ̊Ɗςφςφ̊ފ؊ފĊħςφςφςφ̊ފ΃؊لҊĊħ̊ςφ郊ħςφنςφςφ郃Χϊħςφنςφƃ̊ςφكħςφ醊ςφςφكΑΑ̊ފĊħςφنςφςφ̊لҊħςφςφςφ郊ϊħςφςφكƃ̊ςφكħςφ醊ςφςφكΑΑ̊ފ駠Ċħ̊لҊĊħ̊ςφ郊ħςφنςφςφ郃Χϧςφςφςφ郊Αϊ٧̊ςφكħςφ醊ςφςφك̊ςφ΃ħςφςφكςφ΃̊ςφ΃ħςφςφςφ΃̊ςφƃħςφςφ΃ςφƃلϊ΂ςφكϊ΂ςφƄϊςφƃ΄ϊςφ΃ϊςφ郑ބϊςφބϊςφӄϊςφ̊ӄϊΊӄϊĊħيӄϊĊϊي؊ӊ؂ɂك؊؂ɂيΊٍΧϧĊބϊ΂ςφڄϑϊɊϧ؊ŊŊϧħ̊ςφħςφςφςφϧςφΑالϊςφパϊςφパƄϊςφパ΄ϊςφパϊςφパބϊςφパބϊςφパӄϊςφパϊϑΑϊؐރħϑɂΑϊςؐރħ̊ϧĊħςφ醊σɂ郑ΑΑϊςؐރħ̊ϧĊħςφބσɂΑΑϊςؐރħ̊ϧĊħςφބσɂΑΑϊςؐރħ̊ϧĊħ̊͊Ċ΄ϊ΂΄σςφΆ΄σɂ΃ΑΑϊςؐރħ̊ϧĊħ̊͊ĊƄϊ΂Ƅσςφ憊Ƅσɂ惑ΑΑϊςؐރħ̊ϧĊħςφӄσɂΑΑϊςؐރħ̊ϧĊħςφㆊσɂパΑΑϊςؐރħ̊ϧĊħςφㆊބσɂパΑΑϊςؐރħ̊ϧĊħςφㆊބσɂパΑΑϊςؐރħ̊ϧĊħςφㆊ΄σɂパΑΑϊςؐރħ̊ϧĊħςφㆊƄσɂパΑΑϊςؐރħ̊ϧĊħςφㆊӄσɂパΑΑϊěؐރħюקĂ솊Đލ샑юקςφنςφςφςφςφ憊ςφ惃ςφςφɂΑϊĘؐރħюקĂ솊Đӊٍ샑юקς҂ςφكσς҂ςφσς҂ςφςφσς҂ςφ΃σς҂惆ςφƃσ̊ς҂ΊڄϊĊς҂ڄφσ̊ڄϊĊħς҂ڄφσς҂ςφσς҂ςφσΑފƊي̊ފĊƧ̊τҊĊħϑɂΑΑϊĂؐޑ؊ӐΑސσħ̊ӊ䧠ĊħӂӆӊΑΑΑϊәĂؐޑ؊ӐΑސσاǊؑħ̊ӊ䃊ħħǊϘݑϘŊħ݂ǃ݊ϑ̊ǊݧĊħςσӂ݆ƃƂǊƃϑΑ݊ϑϑΑӊΑΑϊϒ؂ؐރاؐؑؑɊؑɊؑħюקĂ솊Đ؊ϊ샑юקϙފϑƛĊފƊӊΊĊٍ̊ބΊϊħބˑ̊ފ΃ĊħĄĊϑነϑқؑ؊ŊŊϧħɊބ҂̊ɄŊ惊؊ɄŊ؊ɄŊħқل΂ςɄŃϧқل΂Ʉσ̊ބħқϧϧқϑΑҝؑ؊ŊŊϧħɊބ҂̊Ċħ̊ɄŊ惊؊ɄŊ؊ɄŊħҝل΂ςɄŃϧҝل΂ɄσΑΑاބلޑқؑϊބل̊ϧŊħқل΂ބɄσބلޑΑފΊƧڛϊƑڛҊނ؂ɄފΊƧ؊ŊқلފŊϧħ̊ބħқϧϧқϑΑاқҊނ؂ބ̊қҊħқҊқϊқґҝҊނ؂ބҊҝґΙلҝޑ؊ɂބ΄σɂބބσ̊қҊħϙފ҂қ҆ބބφބ΄σϊϙފ؊؊Ŋ؊Ŋϧς⊁ބބϊӟފˑޛلފ΍獑Ίϑқς؃ΑΑϊϙؐރاɊؑħϙςσ̊ފĊħɊބ҂̊қϊħƊɄϙ݊ϧƊɄϙ݊ϑΞĊϑΞĊ؂΂ƊΧϊħϑΞĊϑΞĊΑϙϑΑϊΞؐރħϑΞĊϑΞĊΑϊӟĂؐޑ؊ӐΑސσاǊؑħ̊ӊ䃧ĊħǊϙݑϙŊħ݂ǃ݊ϑ̊ǊݧĊħςσӂ݆ƃƂǊƃϑΑ݊ϑϑΑӊΑΑϊϙ΂ؐޑǆǐ؃ħϙςσϙ݊ϑϙ݂ϙ݃ϙ݊ϑϙϑΑϊϙ͂ؐޑΐΑ؊ǆǐ؃اɊؑħ̊Ǌ؊ފ΃Ċޑϊϊӊ͊يϊڊŊφΊފϊފي٧̊ƊيފƆފӆ͊ĊϊΊϊƧ̊ފϙˊĊħǊϙݑǊϙƑޑΑɊބ҂ϊΊ̧ސϙŊħ݊ϑςσɂǃϑ݊ϑΑސϙŊħ݊ϑςσɂǃϑ݊ϑΑϐϙŊħ݊ϑςσϑ݊ϑΑĐϙŊħ݊ϑςσ̊ǊݧĊħ݂ǆΑ̊ĄħĊħ݊ϑ̊қϊħӊɄǊϧӊɄǊ̊қϊħɄǊƧϧɄǊƑƂǃΑϑ݊ϑΑڐϙŊħ݊ϑςσϑ݊ϑΑΑΑϊɊ؊Ӑӊ̊ӑŐ؃اϐđƐӑސؑħŊފŊ憊؊لϊϊ؊٧ފő̊ڛҊħϊϧϧϊϑ̊ފ惊؊ފħħ̊Ίħ̊͊ħħ΂Α̊ħފƊŊާΑ̊ފħħ̊ħ̊͊ħħ΂ΑފƊŊާΑϊϊϊ̊Ɗ̊ފħħ̊ފσħħ̊ΊħϧΧϧħ̊ħƧϧ̊ΊħΑΑ̊ފħħ̊ފσΊΊħϧħƑ̊ΊħΑΑ̊ފħħ̊ފσħħ̊ΊħΧϧΑϊ٧̊Ίħ̊ħħΑ̊ħΑϊƂǊ؃اؐؑؑɊؑ؊ؑɊؑɊؑӊӑΆΊؑφنđني񚄄̊ӑؐ񚄄̊ؑيӑħɊބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂Ɋބ҂Ɋބ҂̊қϊӊ٧Ċħފފ٧؊ŊŊϧǊӊي݊٧ςنن̂Ӄ̊͊ΊɄŊ؊ɄŊ惃ħ񘊁΂񘊁ϊΊϧ񘊁ӑϊ٧ɂنɄŃފ݊٧؊ŊŊϧħ̊ĊħǊ̊ŊħƊƊΑΑاΧϊĊƊيފϊӧ̊ǊħΊϧΊǊΊǊފފ٧؊ŊŊϧǊӊي݊٧ςنن̂Ӄ̊͊ΊɄŊ؊ɄŊ惃ħ񘊁΂񘊁ϊΊϧ񘊁ӑϊ٧ɂنɄŃފ݊٧؊ŊŊϧħ̊؊ħқϊ̊ĊħǊ̊ŊĊħقƆӆΆΆŃƊƊΑΑاΑΑ؊ɂބ΄σɂބބσϊފ͊Ίފބޑ؊ބ҂؄Ɗӂ؄ņφ؄Ɔ؄Ӄ؊ބ҂؄Ɗӂ؄ņφ؄Ɔ؄Ӄ̊ƊħƊƊƑ̊ƊħƊƊƑ̊ƊħƊƊƑ̊ƊħƊƊƑ̊ħƄϊɄƑلϊƑބϊƑބϊƊɄƊƑ؊ŊŊϧħققΑا̊ĄħĊħ̊қϊħƊɄϙ݊ϧƊɄϙ݊ΑΑϊϙނؐޑǆǐؑ؊ސăاɊؑħ̊ފΊĊޑɊބ҂̊ފĄă؊ފ݃Ċħ̊қϊħӊɄǊϧӊɄǊΑ݊ϑΑϊϙނؐޑǆǐ؃ħ̊ǊħǊǑƂǃΑϊϙ˂ؐޑǆǐؑ؊ːؑϐσاɊؑħ̊Ǌ؊ފ΃ĊޑɊބ҂ϊǊ̧ħ̊қϊħˊǊϧˊǊΑħ̊қϊĊˊɄǊϧˊɄǊΑΑΑϊқςؐރħ̊ҘҊΊқҊħҘҊқґّΑϊҘςؐރħ̊қҊΊҘҊħқҊҘґّΑϊқނؐރħ̊қل̂қރΊқރħқҊқل΂қރΑϊҘނؐރħ̊Ҙل̂ҘރΊҘރħҘҊҘل΂ҘރΑϊҝςؐރاɊؑǐؑħϙςσϙ݊ϑĄĊϑΞĊϑΞĊǊϙݑҊҝґބґϙϑ݂ϙ݃Ιلҝޑӂӂӂ郑ӂ󃑧Ɋބ҂̊͊ΊɄŊ؊ɄŊ惃ħӟيϧӟي̊қϊħӊɄǊϧӊɄǊƂǃϙ݊ϑϙϑΑϊӂŐ؃اɊؑɊؑɊؑɊؑɊؑɊؑؑħɊބ҂ŃɊބ҂Ɋބ҂Ɋބ҂Ɋބ҂ϊϙފ؊̊қϊĊħ̊Ŋħ؊Ŋϙފŧ̊ɄħɄɄɄϧɄ̊Ŋħ؊ŊϙފŊϧ̊ɄħɄɄɄϧɄ̊Ŋħ؊ŊϙފŊϧ̊ɄħɄɄɄϧɄ̊Ŋħ؊ŊϙފŊϧ̊ɄħɄɄɄϧɄΧϊħ̊Ŋħ؊ŊϙފŊϧ̊ɄħɄɄɄϧɄ̊Ŋħ؊ŊϙފŊϧ̊ɄħɄɄɄϧɄ̊Ŋħ؊ŊϙފŊϧ̊ɄħɄɄɄϧɄ̊Ŋħ؊ŊϙފŊϧ̊ɄħɄɄɄϧɄΑΑϊқؐރħ̊қҊĊħقқ҃قқ҃ΑΑϊқؐރħ̊қΊħޛݙϧϧޛݙϑޛΑĊςŊ؃͑ħϊŊ̊搊ފƊҘҘފΊҘҘފي؊ққފ؊ққ鐊ފيފފӊΑΑϊҘؐރاؑħ؊ŊŊϧħققΑاޛΑϊؐރħюקĂ솊ĐĊފيڍ샑юקϛ݊ϑϊܑϊބބϑϊބ΄ϑĄǂ솊샑ɂққҘҘƑ̊ϊħބϊϑϑӑ슐Ƒӂϛ݊ϑΑϊϞ؂ؐރħюקĂ솊Đ؊ϊ샑юקƛĊ͊ӊΊčّّّӂӂΑϊϞނؐރħюקĂ솊Đފϊ샑юקّΑϊؐރħюקĂ솊ĐĊΊڍ샑юקĄǂ솊샑Ƒϑӑ슐ƑΑϊؐރħюקĂ솊Đڍ샑юקĄǂ솊샑Ƒϑӑ슐ƑΑϊؐރħюקĂ솊ĐފƊيڍ샑юקĄǂ솊샑Ƒ̊ΊħلϊĄϊΑ̊͊Ċلϊ΂لσϑΑϊؐރħюקĂ솊ĐފƊيڍ샑юקĄǂ솊샑ƑϑΑϊςؐރħ݊ϑ͊ϑބފ΄ފބފ⑧ބފ⑧τބστބσΑϊ؛ςؐؑĐđϐσħ̊ބلފΊ؛ބΊσħ؛ބΊϑΑϊϙނؐޑƐؑǆǐؑ؊ސăħ̊ǊħƂǃΑϊؐރħĄǂ솊샑ƑϑĄ؊ޑΑϊςؐރħ̊τϊΊħĄΊϑΑѧϊؐރاؑيّħϛ݊ϑς҂ς҂؊ŊŊĊϧބقنބ҄Α͊ққ؊ҘҘĄǂ솊샑Ƒ̊ĊΊĊħ΄ϊ̊͊Ċ΄ϊ΂΄σӂ؊ŊŊĊϧބςΑΑ̊ĊكΊϊĊħބϊϑӂΑϑӑ슐Ƒϛ݊ϑΑקϊěؐރاؑɊؑ؊ؑɊؑӊӑΆΊؑǐؑني񚄄̊ӑؐ񚄄̊ؑħюקĂ솊ĐӊΊŊϊ샑юקነϑϙςσነϑϙ݊ϑɊބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂ބ҂Ɋބ҂ފފ٧؊ŊŧħϧƑΑӊي݊٧ςنن̂Ӄ̊ϊފފي؊Ί͊يŊާ̊͊ΊɄŊ؊ɄŊ惃ħƄϊ΂ƄσϊΊϧ񘊁Ƅϑϊ٧ɂنފ݊٧ΊΊɂބ΄σɂބބσ؊ŊŊϧħ̊ĊħƊ̊ŊĊħقƆӆΆΆŃ؊ބ҂Ńӂ؄ņφ؄Ɔ؄ӃΑاΑΑاӂӂӂ郑ӂ󃑧؊Ŋ؊ŊϧɄɄޑ؊ބ҂؄Ɗӂ؄ņφ؄Ɔ؄Ӄ؊ބ҂؄Ɗӂ؄ņφ؄Ɔ؄Ӄ؊ŊŊϧ̊Ŋħӂ҂Ńσ̊ƊħƊƊƑ̊ƊħƊƊƑ̊ƊħƊƊƑ̊ƊħƊƊƑ̊ħƄϊɄƑلϊƑބϊƑބϊƊɄƊƑϙϑ݂ϙ݃ϙ݊ϑϙϑƄّ؊ŊŊϧħققΑاޛΑϊؐރħϊτҊɂΑϊϑħ̊τҊĊħςφنς҂ςφς҂ςφƆς҂惃ςφΆς҂ڄϊς҂Χϊħςφنς҂ςφς҂ςφƆς҂惃ςφΆς҂ڄϊς҂ΑلϊςφكϊςφƄϊςφƃ΄ϊςφ΃̊ςφكħς醊ςφςφكϧς醊̊ςφ΃ħςςφكςφ΃ϧς̊ςφ΃ħςςφςφ΃ϧς̊ςφƃħςςφ΃ςφƃϧςϊς郑ބϊςބϊςӄϊςބϊςφڄϑΑϊނؐރħӂ󃑧ΑϊނؐރħӂΑϊނؐރħّΑϊނؐރħӂΑϊęؐރħюקĂ솊Đފٍ샑юקĞ؃ڄϊς҂ɂΑϊϙނؐރħϙފϑΑϊؐރħюקĂ솊ĐĊƊيڍ샑юקĄǂ솊샑Ƒ̊ΊħلϊĄϊΑ̊͊Ċلϊ΂لσϑΑϊؐރħюקĂ솊Đފيڍ샑юקϊܑϊބτϑϊބτϑĄǂ솊샑ɂққҘҘƑ̊ϊħħބϊϑӂΑϑΑϊؐރاؑيّħюקĂ솊Đފڍ샑юקς҂ς҂؊ŊŊĊϧބقنބ҄ϊΑĄǂ솊샑̊Ɗħħ̊ħħ΄ϊ̊͊Ċ΄ϊ΂΄σӂ؊ŊŧĊϧބςΑΑΑϑΑῗؐރا㊐ؑފđħ̊΄ϊϛħħފϊ͊ΊϊϊފϊˊŊӊĄ؊ّބނσ̊ބΊϊħħބˑΑΑ̊΄ϊϘΊފ΄̓ħħ̊ބΊϊħބˑބޑΑΑϊ؛ؐޑĐăħϊބϑϛŧħّӂ݆ƃӂ݆ƃϑϑ݊ϑΑ̊΄ϊϞħħّّӂΑΑϊ؛ĂؐޑĐăħϛŧħςσ݊ϑΑ̊΄ϊϞħّΑϊΛނؐރħ̊ϊފĊϊފϊϊˊτ̊ϊΊĊϊϊϊيފǊӊ؊ϊ؊ƊŊΊΊˊӧΑϊق؊͊σħ̊̈́ǊΊ̈́Ǌ䃊ħ؛ބΊϑ̊̈́ǊΊ̈́Ǌ탊ħ؛ބΊϑΑϊΛςؐޑސϑ؃ħĄّΑĊقϊσđا͊ޑħ͊ς񚆘ރބϑϑފބ̄ςύ͆ΑϊނؐރاΆǆӊΑϊϑ؊đħςބφӆǆ΃؊ϑ̊Ί̊§̊Ίħħ̊ǊĊފا؊ϑ̊ǊĊɂǃϊǊ̊؊ħΊǆ󊁊ϧΊǆ󆊛Χϧħ؊ϑɂ΃Α̊؊ĊɂӃϊςӆǆ΃ييΊϊӊޕϊقσŊϊϊ̊ފބلϊĊކħބلޑބϊϑΑϊނؐރاΆΛǆӊΑħς΄φӆǆ΃Λǆ󆊛̊ǊΊΛ΃ħɂӃ̊ΊΛħħ̊ǊĊǊϊɂǃΊΧϧɂ΃̊ފބلϊĊކħބلޑބϊςӆǆ΃ΑϊĂؐރħބلޑΑϊޛؐރħτّΑϊϙقؐޑ؊Ӑ؃ħ̊ӊ؂䃊ħӊ؂ȃΑϊϙĂؐޑ؊ӐΑސσħ̊ӊ΂䃊ħӊ葧Αϊقؐޑ؊Ӑ؃ħ̊Ƅϊϙħ̊ӊ؂䃊ħӊ؂胑ΑϊϛĂؐޑ؊ӐΑސσħ̊ӊħӊ䑧Αϊϒӂؐޑ؊ϐăħ̊ƄϊϙĊϊϑΑϊ؛ؐރħΛّΑϊ݂ؐރħΛّބّΑϊޛؐރħτّΑϊ؛ςؐؑĐđϐσħ̊ބلފΊ؛ބΊσħ؛ބΊϑΑϊϘނؐރħϘϑΑϊϘނؐޑǆǐ؃ħ̊ǊĊޑϊǊ̧؆φφɆɐޑƆƐقǆǃΑϊϊΊϊ݊٧ϘŊħ݊ϑϑ݊ϑΑΑ΄Ze(	>cߑ8+f  x2u3I}^<Nd4UFS'Pd]PAe'M}U6UUc/>[W)$eP,p^E٠=wUY{c\,*6M`mb
} P+<0!,$ E-3^baoh),6=/7!d7Hk>t5UUUl1$D=¦`P	/;;Try?@Oƅ
*(p!{lɦ1KM><aD?~"(w=6F\s`Ll8</M̨2*&*Ks^pǏ #m`^&ٮ؃>k.jeh˞~I{XqfYJNT̛r.h$UleϟKtaRecPtr;
  PlanCogsRec : TPlanDataRecPtr;
  PlanGPRec : TPlanDataRecPtr;
  NamesT : string;
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Exit Page 8');
  flush(F);
{$ENDIF}
  for j := 0 to CheckListBox1.Items.Count - 1 do    // Iterate
    begin
    if CheckListBox1.Checked[j] = True then
      DataCollect.DetailedOptions[j] := 1
    else
      DataCollect.DetailedOptions[j] := 0;
  end;    // for
  DataCollect.DetailedOptions[41] := ComboBox1.ItemIndex;
  DataCollect.DetailedOptions[42] := AComboBox7.itemIndex;
  DataCollect.SetDetailedOptions;
  NamesT := Sender.ClassName;
  if OvcTable3ExitCaught
    then begin
    OvcTable3ExitCaught := False;
    Exit;
  end;

  // Ask if Details should be saved.
//  if YES, then continue
// if NO, then RefreshPlanningData and Combobox1.change(self) are called before proceding.
//  if MessageDlg('Do you wish to apply the detailed changes to your targets ?',
//    mtConfirmation, [mbYes, mbNo], 0) = mrNo
{
  if ApplyDetails = False
    then begin
    DataModuleClient.RefreshPlanningData;
    CalculateArray(SALESUNIT);
    CalculateArray(GPUNIT);
    CalculateArray(GPPC);
    CalculateArray(PRODUCTIVITY);
    ComboBox1State := ComboBox1.Itemindex;
    for j := 0 to DETAILEDPLANLIST - 1 do    // Iterate
      begin
      BuildSummary(GetaccountListIndex(DetailedPlan[j]), False);
    end;    // for
    // Record the latest State to ensure it get saved correctly
    CalculateArray(SALESUNIT);
    CalculateArray(GPUNIT);
    CalculateArray(GPPC);
    CalculateArray(PRODUCTIVITY);
    CalcDetail(integer(1));
  end;
}
  PlanSalesRec := PlanDataList.Items[GetAccountListIndex(SALES)];
  PlanCogsRec := PlanDataList.Items[GetAccountListIndex(COGS)];
  PlanGPRec := PlanDataList.Items[GetAccountListIndex(GROSSPROFIT)];
  days := trunc(DataModuleClient.DepartmentsCurrentPlanEnd.value) - trunc(DataModuleClient.DepartmentsCurrentPlanStart.value);
  for j := 0 to days do    // Iterate
    begin
    PlanCogsRec.PlanDetail[j] := PlanSalesRec.PlanDetail[j] - PlanGPRec.PlanDetail[j];
  end;    // for
  PlanCogsRec.PlanTotal := PlanSalesRec.PlanTotal - PlanGPRec.PlanTotal;
  for j := 0 to DETAILPLANGRAPHLIST - 1 do    // Iterate
    DeleteSeries(j);
//  Initialised := False;
end;

procedure TPlanningF.PlanWizardPage7Enter(Sender: TObject);
var
  j: Integer;
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Enter Page 7');
  flush(F);
{$ENDIF}
  Label1.Caption := 'Targeting - What If Scenarios';
//  fcLabel2.Caption := DataModuleClient.DepartmentsCurrentPlanStart.DisplayText + ' to ' +
//    DataModuleClient.DepartmentsCurrentPlanEnd.DisplayText;
  setlabels2;

  // if we have a past balance use it
  WIScenTotalExp.Value := round(getListPlanBalance(getaccountlistindex(TOTALEXPENSES)));
  if WIScenTotalExp.Value = 0 then
    WIScenTotalExp.Value := round(getListPastBalance(getaccountlistindex(TOTALEXPENSES)));

  WIBaseTotalExp.Value := WIScenTotalExp.value;

  RGSales.CaptionStyle := csNormal;
  RGScene.CaptionStyle := csNormal;
  RGBase.CaptionStyle := csNormal;
  if DataModuleClient.DateRangersStartDate.value <> 0
    then begin
    RGBase.ItemIndex := 0;
    fcImageBtn3.Visible := True;
  end
  else begin
    RGBase.ItemIndex := 1;
    fcImageBtn3.Visible := False;
  end;
  // get and Set Base Balances
  getbase;
  // Set Scenario 1,2,3 from base if no balances exist.
  for j := 1 to 3 do    // Iterate
    begin
    if GetWIBalance(j, WISales) = 0
      then begin
      SetWIBalance(J, WISales, GetWIBalance(WIBase, WISALES));
      SetWIBalance(J, WIGP, GetWIBalance(WIBase, WIGP));
      SetWIBalance(J, WIPOTENTIAL, GetWIBalance(WIBase, WIPOTENTIAL));
      SetWIBalance(J, WIBILLED, GetWIBalance(WIBase, WIBILLED));
    end;
  end;    // for
  // Set the Current Scenario
  CurrentScene := 1;
  RGScene.ItemIndex := CurrentScene - 1;
  // calculate results
  WhatIfCalc(WISALES);
end;

procedure TPlanningF.WhatIfCalc(Account : integer);
var
  j: integer;
  TempBal: Currency;
  HoursMins : Currency;
  Laccount: Integer;
begin
  WhatIfUpdate := False;
  Laccount := Account;
  //
  if account > WIPROD  // A Percentage change has occurred
    then begin
    if GetWIBalance(CurrentScene, Account) <> 0 then
      SetWIBalance(CurrentScene, Account - 10, GetWIBalance(WIBase, Account - 10) * (getWIBalance(CurrentScene, Account) + 100) / 100)
    else
      SetWIBalance(CurrentScene, Account - 10, GetWIBalance(WIBase, Account - 10));
    Laccount := Account - 10;
  end;
  // Use Laccount ONLY from now on
  if (Laccount = WIPOTENTIAL) or (Laccount = WIPROD)
    then begin
    if (GetWIbalance(CurrentScene, WIPotential) <> 0) and (GetWIBalance(CurrentScene, WIPROD) <> 0)
      then begin
      SetWIBalance(CurrentScene, WIBILLED, GetWIBalance(CurrentScene, WIPOTENTIAL) * GetWIBalance(CurrentScene, WIPROD) / 100);
      If unitRounding = 0
        then begin
        SetWIBalance(CurrentScene, WIBILLED, round(GetWIBalance(CurrentScene, WIBILLED)));
        SetWIBalance(CurrentScene, WIPOTENTIAL, round(GetWIBalance(CurrentScene, WIPOTENTIAL)));
      end;
    end;
    if GetWIbalance(CurrentScene, WIPotential) = 0 then
      SetWIBalance(CurrentScene, WIPROD, 0);
    Laccount := WIGPU; // fall through to GPU
  end;
  // store the value of COGS
  TempBal := GetWIBalance(CurrentScene, WISALES) - GetWIBalance(CurrentScene, WIGP);
  if (Laccount = WIGPU) or (Laccount = WIBILLED)
    then begin
    SetWIBalance(CurrentScene, WIGP, GetWIBalance(CurrentScene, WIBILLED) * GetWIBalance(CurrentScene, WIGPU));
    if (Laccount = WIBilled) or (RGSales.Itemindex = 1)
      then begin
      if GetWIBalance(CurrentScene, WIGPPC) <> 0 then
        SetWIBalance(CurrentScene, WISales, GetWIBalance(CurrentScene, WIGP) * 100 / GetWIBalance(CurrentScene, WIGPPC));
    end
    else begin
      SetWIBalance(CurrentScene, WISales, GetWIBalance(CurrentScene, WIGP) + tempbal);
      if GetWIBalance(CurrentScene, WISales) <> 0 then
        SetWIBalance(CurrentScene, WIGPPC, GetWIBalance(CurrentScene, WIGP) * 100 / GetWIBalance(CurrentScene, WISales));
    end;
  end;
  if Laccount = WISU
    then begin
    SetWIBalance(CurrentScene, WISales, GetWIBalance(CurrentScene, WIBILLED) * GetWIBalance(CurrentScene, WISU));
    if (RGSales.Itemindex = 1) then
      SetWIBalance(CurrentScene, WIGP, GetWIBalance(CurrentScene, WISALES) * GetWIBalance(CurrentScene, WIGPPC) / 100)
    else begin
      SetWIBalance(CurrentScene, WIGP, GetWIBalance(CurrentScene, WISales) - tempbal);
      if GetWIBalance(CurrentScene, WISales) <> 0 then
        SetWIBalance(CurrentScene, WIGPPC, GetWIBalance(CurrentScene, WIGP) * 100 / GetWIBalance(CurrentScene, WISales));
    end;
  end;
  if Laccount = WIGPPC
    then begin
    if (RGSales.Itemindex = 1)
      then begin
      if GetWIBalance(CurrentScene, WIGPPC) <> 0 then
        SetWIBalance(CurrentScene, WISales, GetWIBalance(CurrentScene, WIGP) * 100 / GetWIBalance(CurrentScene, WIGPPC));
    end
    else
      SetWIBalance(CurrentScene, WIGP, GetWIBalance(CurrentScene, WISALES) * GetWIBalance(CurrentScene, WIGPPC) / 100);
  end;
  // Calculate 4 ratios
  if GetWIBalance(CurrentScene, WISales) <> 0 then
    SetWIBalance(CurrentScene, WIGPPC, GetWIBalance(CurrentScene, WIGP) * 100 / GetWIBalance(CurrentScene, WISales));
  if GetWIBalance(CurrentScene, WIBilled) <> 0 then
    SetWIBalance(CurrentScene, WISU, GetWIBalance(CurrentScene, WISales) / GetWIBalance(CurrentScene, WIBilled));
  if GetWIBalance(CurrentScene, WIBilled) <> 0 then
    SetWIBalance(CurrentScene, WIGPU, GetWIBalance(CurrentScene, WIGP) / GetWIBalance(CurrentScene, WIBilled));
  if GetWIBalance(CurrentScene, WIPotential) <> 0 then
    SetWIBalance(CurrentScene, WIPROD, GetWIBalance(CurrentScene, WIBilled) * 100 / GetWIBalance(CurrentScene, WIPotential));

  WIScenSales.value := Round(GetWIBalance(CurrentScene, WISales));
  WIScenGP.Value := round(GetWIBalance(CurrentScene, WIGP));
  WIScenPotential.Value := GetWIBalance(CurrentScene, WIPotential);
  
  WIScenBilled.Value := GetWIBalance(CurrentScene, WIBilled);

  WIScenGPPC.Value := getWIBalance(CurrentScene, WIGPPC);
  WIScenSalesUnit.Value := getWIBalance(CurrentScene, WISU);
  WIScenGPUnit.Value := getWIBalance(CurrentScene, WIGPU);
  WIScenProductivity.Value := getWIBalance(CurrentScene, WIPROD);
  if (WIScenProductivity.value > 0) and (WIScenProductivity.value < 100)
    then begin
    Hoursmins := 8 * WIScenProductivity.value / 100;
    HourspdLblWI.caption := 'Productive Hours per day = ' + inttostr(trunc(hoursmins)) + 'hr ' + inttostr(trunc(Hoursmins * 60) mod 60) + 'mins';
  end
  else
    HourspdLblWI.Caption := '';
  WIScenNetProfit.Value := round(GetWIBalance(CurrentScene, WIGP)) - WIScenTotalExp.Value;
  // Calculculate pc change
  for j := 10 to 17 do    // Iterate
  begin
    if getWIBalance(WIBase, j - 10) <> 0 then
      SetWIBalance(CurrentScene, J, (GetWIBalance(CurrentScene, j - 10) * 100 / GetWIBalance(WIBase, J - 10)) - 100)
    else
      SetWIBalance(CurrentScene, J, 0);
  end;
      // for
  WIChangeSales.value := GetWIBalance(CurrentScene, WISalesPCI);
  WIChangeGP.Value := GetWIBalance(CurrentScene, WIGPPCI);
  WIChangePotential.Value := GetWIBalance(CurrentScene, WIPotentialPCI);
  WIChangeBilled.Value := GetWIBalance(CurrentScene, WIBilledPCI);

  WIChangeGPPC.Value := getWIBalance(CurrentScene, WIGPPCPCI);
  WIChangeSalesUnit.Value := getWIBalance(CurrentScene, WISUPCI);
  WIChangeGPUnit.Value := getWIBalance(CurrentScene, WIGPUPCI);
  WIChangeProductivity.Value := getWIBalance(CurrentScene, WIPRODPCI);
  WhatIfUpdate := True;
end;

procedure TPlanningF.RGBaseClick(Sender: TObject);
begin
  getbase;
  WhatIfCalc(WISALES);
end;

procedure TPlanningF.WIScenGPPCChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIGPPC, WIScenGPPC.value);
    WhatIfCalc(WIGPPC);
  End;
end;

procedure TPlanningF.WIScenSalesUnitChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WISU, WIScenSalesUnit.value);
    WhatIfCalc(WISU);
  End;
end;

procedure TPlanningF.WIScenGPUnitChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIGPU, WIScenGPUnit.value);
    WhatIfCalc(WIGPU);
  End;
end;

procedure TPlanningF.WIScenBilledChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    if UnitRounding = 0 then WIScenBilled.value := round(WIScenBilled.value);
    SetWIBalance(CurrentScene, WIBilled, WIScenBilled.value);
    WhatIfCalc(WIBilled);
  End;
end;

procedure TPlanningF.WIScenPotentialChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    if UnitRounding = 0 then WIScenPotential.value := round(WIScenPotential.value);
    SetWIBalance(CurrentScene, WIPOTENTIAL, WIScenPotential.value);
    WhatIfCalc(WIPOTENTIAL);
  End;
end;

procedure TPlanningF.WIScenProductivityChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIPROD, WIScenProductivity.value);
    WhatIfCalc(WIPROD);
  End;
end;

procedure TPlanningF.WIChangeGPPCChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIGPPCPCI, WIChangeGPPC.value);
    WhatIfCalc(WIGPPCPCI);
  End;
end;

procedure TPlanningF.WIChangeSalesUnitChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WISUPCI, WIChangeSalesUnit.value);
    WhatIfCalc(WISUPCI);
  End;
end;

procedure TPlanningF.WIChangeGPUnitChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIGPUPCI, WIChangeGPUnit.value);
    WhatIfCalc(WIGPUPCI);
  End;
end;

procedure TPlanningF.WIChangeBilledChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIBilledPCI, WIChangeBilled.value);
    WhatIfCalc(WIBilledPCI);
  End;
end;

procedure TPlanningF.WIChangePotentialChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIPOTENTIALPCI, WIChangePotential.value);
    WhatIfCalc(WIPOTENTIALPCI);
  End;
end;

procedure TPlanningF.WIChangeProductivityChange(Sender: TObject);
begin
  if WhatifUpdate
    then begin
    SetWIBalance(CurrentScene, WIPRODPCI, WIChangeProductivity.value);
    WhatIfCalc(WIPRODPCI);
  End;
end;

procedure TPlanningF.fcImageBtn1Click(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: WI Reset');
  flush(F);
{$ENDIF}
  SetWIBalance(CurrentScene, WISales, GetWIBalance(WIBase, WISALES));
  SetWIBalance(CurrentScene, WIGP, GetWIBalance(WIBase, WIGP));
  SetWIBalance(CurrentScene, WIPOTENTIAL, GetWIBalance(WIBase, WIPOTENTIAL));
  SetWIBalance(CurrentScene, WIBILLED, GetWIBalance(WIBase, WIBILLED));
  WhatIfCalc(WISALES);
end;

procedure TPlanningF.fcImageBtn2Click(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: WI Apply Targers');
  flush(F);
{$ENDIF}
  setListPlanBalance(GetAccountListIndex(SALES), GetWIBalance(CurrentSCene, WISales), True);
  setListPlanBalance(GetAccountListIndex(GROSSPROFIT), GetWIBalance(CurrentSCene, WIGP), True);
  setListPlanBalance(GetAccountListIndex(COGS), GetWIBalance(CurrentSCene, WISALES) - GetWIBalance(CurrentSCene, WIGP), True);
  setListPlanBalance(GetAccountListIndex(BILLED), GetWIBalance(CurrentSCene, WIBilled), True);
  setListPlanBalance(GetAccountListIndex(POTENTIAL), GetWIBalance(CurrentSCene, WIPotential), True);
  if (getListPlanBalance(getaccountlistindex(TOTALEXPENSES)) = 0)
    and (WIScenTotalExp.value <> 0)
    then setListPlanBalance(GetAccountListIndex(TOTALEXPENSES), WIScenTotalExp.value, True);
  if WIScenTotalExp.value = 0
    then begin
    setListPlanBalance(GetAccountListIndex(TOTALEXPENSES), WIScenTotalExp.value, True);
    setListPlanBalance(GetAccountListIndex(NETOPERATINGPROFIT), GetWIBalance(CurrentSCene, WIGP), True);
    setListPlanBalance(GetAccountListIndex(NETPROFIT), GetWIBalance(CurrentSCene, WIGP), True);
  end;

  // set Total Expenses if <> Current Plan Total
  if RGBase.itemindex = 1
    then begin
    getbase;
    WhatifCalc(WISALES);
  end;    
end;

procedure TPlanningF.WIChangeProductivityKeyDown(Sender: TObject;
  var Key: Word; Shift: TShiftState);
begin
  if Key = VK_RETURN
    then begin
    ProcessEnterKey(PlanningF.WIChangeProductivity, 0);
    key := 0;
  end;
  inherited;
end;

procedure TPlanningF.AOvcTCCurrency3KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  rowNum : integer;
begin
  if (key = VK_RETURN) then
  begin
    rownum := OvcTable2.activeRow;
    with OvcTable2
      do begin
      invalidateRow(rownum);
      AllowRedraw := False;
      if RowNum = ActiveRow
        then begin
        StopEditingState(True);
        calculateSummary(activerow, activecol);
        SetActiveCell((RowNum + 1), Activecol);
        StartEditingState;
      end;
      AllowRedraw := True;
      invalidate;
    End;
    key := 0;
  end;
end;

procedure TPlanningF.PlanWizardPage8Enter(Sender: TObject);
var
  daysinyear: integer;
  j: Integer;
//  PlanDataRec : TPlanDataRecPtr;
  PlanAccDataRec : TPlanDataRecPtr;
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Enter Page 8');
  flush(F);
{$ENDIF}
  OvcTable3ExitCaught := False;
  Label1.Caption := 'Target Detail - Activity and Contribution Drivers';
  if DataCollect.Planloaded = True then
    DataCollect.setPlanningData;
  if (not initialised)
    then begin
    AdvancedOnBtn.down := False;
    DetailedOK := True;
    CheckListBox1.Clear;
    for j := 0 to DETAILPLANGRAPHLIST - 1 do    // Iterate
      begin
      PlanAccDataRec := PlanDataList.Items[GetAccountListIndex(DetailPlanGraph[j])];
      if (PlanAccDataRec.Accountno = POTENTIAL) or (PlanAccDataRec.Accountno = BILLED)
        or (PlanAccDataRec.Accountno >= 10000)
        then
        CheckListBox1.Items.Add(GetUnitTitle(PlanAccDataRec.AccountNo))
      else
        CheckListBox1.Items.Add(PlanAccDataRec.AccountTitle);
      if DataCollect.DetailedOptions[j] > 0 then
        CheckListBox1.Checked[j] := True
      else
        CheckListBox1.Checked[j] := False;
    end;
    AComboBox7.Clear;
    for j := 0 to DETAILEDPLANLIST - 1 do    // Iterate
      begin
      PlanAccDataRec := PlanDataList.Items[GetAccountListIndex(DetailedPlan[j])];
      if j > 4
        then begin
        if (PlanAccDataRec.Accountno = POTENTIAL) or (PlanAccDataRec.Accountno = BILLED)
          or (PlanAccDataRec.Accountno >= 10000) then
          AComboBox7.Items.add(GetUnitTitle(PlanAccDataRec.Accountno))
        else
          AComboBox7.Items.add(PlanAccDataRec.AccountTitle);
      end;
    end;    // for
    DataModuleClient.LookupSummaryIntervals.First;
    ComboBox1.Clear;
    while DataModuleClient.LookupSummaryIntervals.eof = False
      do begin
      Combobox1.Items.Add(DataModuleClient.LookupSummaryIntervalsPeriod_Desc.value);
      DataModuleClient.LookupSummaryIntervals.Next;
    end;
    // Chart period interval
    HgRadioGroup1.CaptionStyle := csNormal;
//    HgRadioGroup1.ItemIndex := strtoint(currtostr(PlanDataRec.PlanDetail[40]));
    // Edit period interval
    for j := 0 to CheckListBox1.Items.Count - 1 do    // Iterate
      begin
      if DataCollect.DetailedOptions[j] > 0 then
        CheckListBox1.Checked[j] := True
      else
        CheckListBox1.Checked[j] := False;
      end;    // for

    ComboBox1.ItemIndex := strtoint(currtostr(DataCollect.DetailedOptions[41]));
    if ComboBox1.ItemIndex < 0 then
      ComboBox1.ItemIndex := 0;
    ComboBox1State := ComboBox1.itemindex;
    AComboBox7.ItemIndex := strtoint(currtostr(DataCollect.DetailedOptions[42]));
    DetailedIndex := AComboBox7.itemIndex;
    OvcTCColHead3.Headings.Strings[1] := AComboBox7.text;
    daysinyear := trunc(DataModuleClient.DepartmentsCurrentPlanEnd.value) - trunc(DataModuleClient.DepartmentsCurrentPlanStart.value);
    if ComboBox1.Itemindex > 0 then
      Ovctable3.RowLimit :=  createSummaryIndex(ComboBox1.ItemIndex, DataModuleClient.DepartmentsCurrentPlanStart.value, DataModuleClient.DepartmentsCurrentPlanEnd.value) + 1
    else OvcTable3.RowLimit := DaysinYear + 2;
    for j := 0 to DaysInYear do    // Iterate
      YearDates[j] := FormatDateTime(' '+ GetDateFENH + ' ', DataModuleClient.DepartmentsCurrentPlanStart.value + j);
    AOvcTCCurrency5.NumericFormat := nfcomma;
    Chart1.BottomAxis.DateTimeFormat := 'dd' + #13 + 'MMM';
    Initialised := True;
    ComboBox1Change(Sender);
  end;
end;

procedure TPlanningF.OvcTable3DblClick(Sender: TObject);
//var
//  PlanDataRec : TPlanDataRecPtr;
begin
//  OvcTable3.StopEditingState(True);
//  if not DblClick
//    then begin
//    PlanDataRec := PlanDataList.Items[GetaccountListIndex(DetailedPlan[DETAILEDEDITSTART + DetailedIndex])];
//    if ComboBox1State = 0 then
//      DropBal := PlanDataRec.PlanDetail[OvcTable3.activeRow - 1]
//    else
//      DropBal := PlanDataRec.PlanSummary[OvcTable3.activeRow - 1];
//    dblclick := true;
//    Led4.Down := False;
//    Led4.Caption := '$' + currtostr(round(DropBal * 100) / 100);
//  end
//  else begin
//    dblclick := False;
//    Led4.Down := True;
//    Led4.Caption := '';
//  end;
//  OvcTable3.StartEditingState;
end;

procedure TPlanningF.led4Click(Sender: TObject);
begin
//  dblclick := False;
//  Led4.Down := True;
//  Led4.Caption := '';
end;

procedure TPlanningF.AOvcTCCurrency5KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  rowNum : integer;
begin
  if (key = VK_RETURN)
    then begin
    rownum := OvcTable3.activeRow;
    with OvcTable3
      do begin
      invalidateRow(rownum);
      AllowRedraw := False;
      if RowNum = ActiveRow
        then begin
        StopEditingState(True);
//        calculateSummary(activerow, activecol);
        SetActiveCell((RowNum + 1), Activecol);
        StartEditingState;
      end;
      AllowRedraw := True;
      invalidate;
    End;
    key := 0;
  end;
end;

procedure TPlanningF.OvcTable3ActiveCellChanged(Sender: TObject; RowNum,
  ColNum: Integer);
begin
  OvcTable3.StopEditingState(False);
  OvcTable3.AllowRedraw := False;
  OvcTable3.invalidateRow(OvcTable3.activeRow);
  OvcTable3.AllowRedraw := True;
  OvcTable3.StartEditingState;
end;

procedure TPlanningF.OvcTable3ActiveCellMoving(Sender: TObject;
  Command: Word; var RowNum, ColNum: Integer);
var
  planDataRec : TPlanDataRecPtr;
begin
  if (RowNum = 0) or (not initialised)then exit;

  // Make sure any pending edits are up to date, and get the current lines entries
  // if cell contents not legal, exit immediately, staying on the old active cell
  if not OvcTable3.SaveEditedData then begin
    RowNum := OvcTable3.ActiveRow;
    ColNum := OvcTable3.ActiveCol;
    exit;
  end;
  PlanDataRec := PlanDataList.Items[GetAccountListIndex(DetailedPlan[DETAILEDEDITSTART + Detailedindex])];
   case Command of
    ccRight:
      with OvcTable3
      do begin
        AllowRedraw := False;
        StopEditingState(True);
        Inc(RowNum);
        StartEditingState;
        AllowRedraw := True;
      end;
    ccLeft:
      with OvcTable3
      do begin
        AllowRedraw := False;
        StopEditingState(True);
        dec(RowNum);
        StartEditingState;
        AllowRedraw := True;
      end;
    ccMouse:
      with OvcTable3
      do begin
        AllowRedraw := False;
        StopEditingState(True);
        StartEditingState;
        AllowRedraw := True;
      end;
    ccDown:
      with OvcTable3
      do begin
        AllowRedraw := False;
        StopEditingState(True);
        if RowNum = ActiveRow
        then begin
          IncRow(RowNum, 1);
        end;
        if AdvancedOnBtn.down
          then begin
          DownArrow := True;
          if ComboBox1State = 0 then
            OldPlanSummary := PlanDataRec.PlanDetail[RowNum - 1]
          else
            OldPlanSummary := PlanDataRec.PlanSummary[RowNum - 1];
          if ComboBox1State = 0 then
            PlanDataRec.PlanDetail[RowNum - 1] := DropBal
          else
            PlanDataRec.PlanSummary[RowNum - 1] := DropBal;
//          CalcDetail(Rownum);
        end;
        StartEditingState;
        AllowRedraw := True;
      End;
    ccUp:
      with OvcTable3
      do begin
        AllowRedraw := False;
        StopEditingState(True);
        StartEditingState;
        AllowRedraw := True;
      end;
  end;
end;

procedure TPlanningF.DetailedCalc (var Parray: array of currency; AccountNo: integer);
var
  UsePrice: boolean;
  TempBal: Currency;
  Laccount: Integer;
begin
// NB Do not zero POTENTIAL, BILLED, GPPC or GPUNIT Values. These are user drivers

  Laccount := AccountNo;
  if HgRadioGroup1.ItemIndex = 0 then
    UsePrice := True
  else
    UsePrice := False;

  if (laccount = POTENTIAL) or (laccount = PRODUCTIVITY) then
  begin
    if (Parray[PDPOTENTIAL] <> 0) and (Parray[PDPROD] <> 0) then
      Parray[PDBILLED] := Parray[PDPOTENTIAL] * Parray[PDPROD] / 100;
    if unitRounding = 0 then
    begin
      Parray[PDBILLED] := Round(Parray[PDBILLED]);
    end;
    if (Parray[PDPOTENTIAL] = 0) then
      Parray[PDPROD] := 0;
    Laccount := GPUNIT; // fall through to GPUnit
  end;

  if (laccount = BILLED) then
  begin
    if (Parray[PDPROD] <> 0) then
      Parray[PDPOTENTIAL] := Parray[PDBILLED] * 100 / Parray[PDPROD];
    if unitRounding = 0 then
    begin
      Parray[PDPOTENTIAL] := Round(Parray[PDPOTENTIAL]);
    end;
    Laccount := GPUNIT; // fall through to GPUnit
  end;

  // store the value of COGS
  TempBal := Parray[PDSALES] - Parray[PDGROSS];

  if (Laccount = GPUNIT) then
    begin
    Parray[PDGROSS] := Parray[PDBILLED] * Parray[PDGPUNIT];
    if (not UsePrice) then
      begin
      if (Parray[PDGPPC] <> 0) and (Parray[PDGROSS] <> 0)then
        PArray[PDSALES] := Parray[PDGROSS] * 100 / Parray[PDGPPC]
      else
        Parray[PDSALES] := 0;
      end
    else
      begin
      if Parray[PDGROSS] <> 0 then
        Parray[PDSALES] := PArray[PDGROSS] + tempbal
      else
        Parray[PDSALES] := 0;
      if (Parray[PDSALES] <> 0) and (Parray[PDGROSS] <> 0) then
        Parray[PDGPPC] := Parray[PDGROSS] * 100 / Parray[PDSALES];
      end;
    end;

  if Laccount = SALESUNIT then
    begin
    PArray[PDSALES] := Parray[PDBILLED] * Parray[PDSALESUNIT];
    if (not usePrice) and (Parray[PDSALES] <> 0) and (Parray[PDGPPC] <> 0)then
      Parray[PDGROSS] := Parray[PDSALES] * Parray[PDGPPC] / 100
    else
      begin
      Parray[PDGROSS] := Parray[PDSALES] - tempbal;
      if (Parray[PDSALES] <> 0) and (Parray[PDGROSS] <> 0)then
        Parray[PDGPPC] := Parray[PDGROSS] * 100 / Parray[PDSALES];
      end;
    end;

  if Laccount = GPPC then
    begin
    if (Not UsePrice) then
      begin
      if (Parray[PDGPPC] <> 0) and (Parray[PDGROSS] <> 0) then
        Parray[PDSALES] := Parray[PDGROSS] * 100 / Parray[PDGPPC];
      end
    else
      Parray[PDGROSS] := Parray[PDSALES] * Parray[PDGPPC] / 100;
    end;

  // Calculate 4 ratios
  if (Parray[PDSALES] <> 0) and (Parray[PDGROSS] <> 0) then
    Parray[PDGPPC] := Parray[PDGROSS] * 100 / Parray[PDSALES];

  if Parray[PDBILLED] <> 0 then
    begin
    Parray[PDSALESUNIT] := Parray[PDSALES] / Parray[PDBILLED];
    Parray[PDGPUNIT] := Parray[PDGROSS] / Parray[PDBILLED];
    end;

  if Parray[PDPOTENTIAL] <> 0 then
    Parray[PDPROD] := Parray[PDBILLED] * 100 / Parray[PDPOTENTIAL];
end;

procedure TPlanningF.CalcDetail(rownum : integer);
var
//  daysinyear: Integer;
  j: Integer;
  PlanDataRec : TPlanDataRecPtr;
  SummaryPtr : TPlanDataRecPtr;
  PlanExpDataRec : TPlanDataRecPtr;
//  PlanNPDataRec : TPlanDataRecPtr;
  temparray : TDetailedBalArray;
  fromperiod, toperiod : integer;
//  UsePrice, UpdateSales, UpdateGP : Boolean;
  Oldvalues, NewValues : array[0..PDEND - 1] of currency;
  RecordPtr: array[0..PDEND - 1] of TPlanDataRecPtr;
//  CBalances : ^TDetailedBalArray;
begin
  PlanDataRec := PlanDataList.Items[getAccountListIndex(DetailedPlan[DETAILEDEDITSTART + Detailedindex])];
  RecordPtr[PDSALES] := PlanDataList.Items[getAccountListIndex(SALES)];
  RecordPtr[PDGROSS] := PlanDataList.Items[getAccountListIndex(GROSSPROFIT)];
  RecordPtr[PDPOTENTIAL] := PlanDataList.Items[getAccountListIndex(POTENTIAL)];
  RecordPtr[PDBILLED] := PlanDataList.Items[getAccountListIndex(BILLED)];
  RecordPtr[PDSALESUNIT] := PlanDataList.Items[getAccountListIndex(SALESUNIT)];
  RecordPtr[PDGPUNIT] := PlanDataList.Items[getAccountListIndex(GPUNIT)];
  RecordPtr[PDGPPC] := PlanDataList.Items[getAccountListIndex(GPPC)];
  RecordPtr[PDPROD] := PlanDataList.Items[getAccountListIndex(PRODUCTIVITY)];
  RecordPtr[PDOTHER] := PlanDataList.Items[getAccountListIndex(OTHERINCOME)];
  PlanExpDataRec := PlanDataList.Items[GetaccountListIndex(TOTALEXPENSES)];
//  PlanNPDataRec := PlanDataList.Items[GetaccountListIndex(NETOPERATINGPROFIT)];
  if ComboBox1State <= 0     // Daily Balances
    then begin
    // Get current values
    for j := 0 to (PDEND - 1) do    // Iterate
      Oldvalues[j] := RecordPtr[j].PlanDetail[RowNum - 1];
    // copy as New values
    move(Oldvalues, newValues, sizeof(Currency) * PDEND);
    if (UnitRounding = 0)
      and ((PlanDataRec.Accountno = BILLED) or (PlanDataRec.AccountNo = POTENTIAL)) then
      NewValues[2 + Detailedindex] := round(NewValues[2 + Detailedindex]);
    // place old value
    OldValues[2 + Detailedindex] := OldPlanSummary;
    // calculate values
    DetailedCalc(newValues, PlanDataRec.accountNo);
    // set new values
    for j := 0 to (PDEND - 1) do    // Iterate
    begin
      if Oldvalues[j] <> Newvalues[j]
        then begin
        RecordPtr[j].PlanDetail[RowNum - 1] := newvalues[j];
        if RecordPtr[j].accountNo < SALESUNIT then
          RecordPtr[j].PlanTotal := RecordPtr[j].PlanTotal + Newvalues[j] - oldvalues[j];
      end;
    end;    // for
  end
  else begin   // All balances that are NOT Daily
    if Rownum < 2 then
      fromperiod := 0
    else
      fromperiod := SummaryPeriodIndexArray[rownum - 2] + 1;
    toperiod := SummaryPeriodIndexArray[Rownum - 1];
    // Get current values
    for j := 0 to (PDEND - 1) do    // Iterate
      Oldvalues[j] := RecordPtr[j].PlanSummary[RowNum - 1];
    // copy as New values
    move(Oldvalues, newValues, sizeof(Currency) * PDEND);
    if (UnitRounding = 0)
      and ((PlanDataRec.Accountno = BILLED) or (PlanDataRec.AccountNo = POTENTIAL)) then
      NewValues[2 + Detailedindex] := round(NewValues[2 + Detailedindex]);
    // place old value
    OldValues[2 + Detailedindex] := OldPlanSummary;
    // calculate values
    DetailedCalc(newValues, PlanDataRec.accountNo);
    // set new values
    for j := 0 to (PDEND - 1) do    // Iterate
    begin
//      if (Newvalues[j] > 100000) or (NewValues[j] < -100000) then
//         Combobox1State := 0;
      if Oldvalues[j] <> Newvalues[j]
        then begin
        RecordPtr[j].PlanSummary[RowNum - 1] := newvalues[j];
        if RecordPtr[j].accountNo < SALESUNIT
          then begin
          UpdateFromSummaryBalances(RecordPtr[j].Plandetail, temparray,
            newvalues[j], fromperiod, toperiod, RecordPtr[j].Accountno);
          RecordPtr[j].PlanTotal := RecordPtr[j].PlanTotal + Newvalues[j] - oldvalues[j];
        end;
      end;    // for
    end;
  end;
// daysinyear := trunc(DataModuleClient.DepartmentsCurrentPlanEnd.value) - trunc(DataModuleClient.DepartmentsCurrentPlanStart.value);
// Calculate Net Operating and Net Profit.
  CalcNetProfit;
  SummaryPtr := PlanDataList.Items[getAccountListIndex(NETOPERATINGPROFIT)];
  SummaryPtr.PlanTotal := BuildSummary(SummaryPtr.Accountno, True, SummaryPtr.PlanDetail, SummaryPtr.PlanSummary);
  SummaryPtr := PlanDataList.Items[getAccountListIndex(NETPROFIT)];
  SummaryPtr.PlanTotal := BuildSummary(SummaryPtr.Accountno, True, SummaryPtr.PlanDetail, SummaryPtr.PlanSummary);
  if (RecordPtr[PDBILLED].PlanTotal <> 0) then
    RecordPtr[PDSALESUNIT].PlanTotal := RecordPtr[PDSALES].PlanTotal / RecordPtr[PDBILLED].PlanTotal;
  if (RecordPtr[PDBILLED].PlanTotal <> 0) then
    RecordPtr[PDGPUNIT].PlanTotal := RecordPtr[PDGROSS].PlanTotal / RecordPtr[PDBILLED].PlanTotal;
  if (RecordPtr[PDSALES].PlanTotal <> 0)then
    RecordPtr[PDGPPC].PlanTotal := RecordPtr[PDGROSS].PlanTotal * 100 / RecordPtr[PDSALES].PlanTotal;
  if (RecordPtr[PDPOTENTIAL].PlanTotal <> 0)then
    RecordPtr[PDPROD].PlanTotal := RecordPtr[PDBILLED].PlanTotal * 100 / RecordPtr[PDPOTENTIAL].PlanTotal;
  if DetailedOK then
      DetailedTotal.value := PlanDataRec.PlanTotal;
  DetailedSales.value := RecordPtr[PDSALES].PlanTotal;
  DetailedGrossProfit.value := RecordPtr[PDGROSS].PlanTotal;
  DetailedNetProfit.value := RecordPtr[PDGROSS].PlanTotal - PlanExpDataRec.PlanTotal + RecordPtr[PDOTHER].PlanTotal;
  for j := 0 to DETAILPLANGRAPHLIST - 1 do    // Iterate
    begin
    DeleteSeries(j);
    BuildSeries(j);
  end;    // for
  if AdvancedOnBtn.down
    then begin
    if ComboBox1State = 0 then
      DropBal := PlanDataRec.PlanDetail[OvcTable3.activeRow - 1]
    else
      DropBal := PlanDataRec.PlanSummary[OvcTable3.activeRow - 1];
  end;
end;

procedure TPlanningF.OvcTable3BeginEdit(Sender: TObject; RowNum,
  ColNum: Integer; var AllowIt: Boolean);
var
  PlanDataRec : TPlanDataRecPtr;
begin
  if not initialised then exit;
  PlanDataRec := PlanDataList.Items[GetAccountListIndex(DetailedPlan[DETAILEDEDITSTART + Detailedindex])];
  if (not AdvancedOnBtn.Down) or (Not DownArrow)
    then begin
    if ComboBox1State = 0 then
      OldPlanSummary := PlanDataRec.PlanDetail[RowNum - 1]
    else
      OldPlanSummary := PlanDataRec.PlanSummary[RowNum - 1];
  end;
  DownArrow := False;
end;

procedure TPlanningF.OvcTable3DoneEdit(Sender: TObject; RowNum,
  ColNum: Integer);
begin
//  if Colnum = 1 then
//  Colnum := Colnum;
//    Calcdetail(rownum);
end;

procedure TPlanningF.OvcTable3GetCellData(Sender: TObject; RowNum,
  ColNum: Integer; var Data: Pointer; Purpose: TOvcCellDataPurpose);
var
  PlanDataRec : TPlanDataRecPtr;
begin
  if (RowNum = 0) or (Not Initialised) then exit;
  PlanDataRec := PlanDataList.Items[GetaccountListIndex(DetailedPlan[DETAILEDEDITSTART + Detailedindex])];
  case ColNum Of
    0: begin
      if ComboBox1State = 0 then
        Data := @YearDates[RowNum - 1]
      else
        Data := @YearDates[SummaryPeriodIndexArray[RowNum - 1]];
     end;
    1: begin
      if ComboBox1State = 0
        then Data := @PlanDataRec.PlanDetail[RowNum - 1]
      else
        Data := @PlanDataRec.PlanSummary[RowNum - 1];
    end;
  end;
end;

procedure TPlanningF.AComboBox1Change(Sender: TObject);
begin
  if (AComboBox2.ItemIndex < 7) and (AComboBox1.ItemIndex < 7) then
    AcomboBox2.ItemIndex := AComboBox1.itemIndex;
  setLabels;
end;

procedure TPlanningF.AComboBox2Change(Sender: TObject);
begin
  if (AComboBox1.ItemIndex < 7) and (AComboBox2.ItemIndex < 7) then
    AcomboBox1.ItemIndex := AComboBox2.itemIndex;
  setLabels;
end;

procedure TPlanningF.AComboBox1Exit(Sender: TObject);
begin
  if (AComboBox1.Items.IndexOf(AComboBox1.text)< 0) and (length(AComboBox1.text) > 0)then
    AComboBox1.itemindex := AComboBox1.items.Add(AComboBox1.text);
end;

procedure TPlanningF.AComboBox2Exit(Sender: TObject);
begin
  if (AComboBox2.Items.IndexOf(AComboBox2.text)< 0) and (length(AComboBox2.text) > 0) then
    AComboBox2.itemindex := AComboBox2.items.Add(AComboBox2.text);
end;

procedure TPlanningF.AComboBox7Change(Sender: TObject);
var
  PlanDataRec : TPlanDataRecPtr;
  RowNum: integer;
begin
  OvcTable3.StopEditingState(False);
  OvcTable3.AllowRedraw := False;
  AdvancedOnBtn.down := False;
//  Led4.Down := True;
//  Led4.Caption := '';
  Rownum := Ovctable3.ActiveRow;
  DetailedIndex := AComboBox7.itemindex;
  Datacollect.DetailedOptions[42] := DetailedIndex;
  OvcTable3.invalidate; //Row(OvcTable3.activeRow);
  OvcTCColHead3.Headings.Strings[1] := AComboBox7.text;
  CalculateArray(SALESUNIT);
  CalculateArray(GPUNIT);
  CalculateArray(GPPC);
  CalculateArray(PRODUCTIVITY);
  PlanDataRec := PlanDataList.Items[GetAccountListIndex(DetailedPlan[DETAILEDEDITSTART + Detailedindex])];
  if (UnitRounding = 0)
    and ((PlanDataRec.Accountno = BILLED) or (PlanDataRec.AccountNo = POTENTIAL)) then
    AOvcTCCurrency5.DecimalFigures := 0
  else
    AOvcTCCurrency5.DecimalFigures := 2;
  if ComboBox1State = 0 then
    OldPlanSummary := PlanDataRec.PlanDetail[RowNum - 1]
  else
    OldPlanSummary := PlanDataRec.PlanSummary[RowNum - 1];
  CalcDetail(RowNum);
  OvcTable3.AllowRedraw := True;
  OvcTable3.StartEditingState;
end;

procedure TPlanningF.CalculateArray(Accountno: integer);
var
  PlanDataRec : TPlanDataRecPtr;
  PlanSalesRec : TPlanDataRecPtr;
  PlanGPRec : TPlanDataRecPtr;
//  PlanExpDataRec : TPlanDataRecPtr;
  PlanBilledRec : TPlanDataRecPtr;
  PlanPotentialRec : TPlanDataRecPtr;
  j: integer;
begin
  PlanDataRec := PlanDataList.Items[GetaccountListIndex(AccountNo)];
  PlanSalesRec := PlanDataList.Items[GetaccountListIndex(SALES)];
  PlanGPRec := PlanDataList.Items[GetaccountListIndex(GROSSPROFIT)];
  PlanBilledRec := PlanDataList.Items[GetaccountListIndex(BILLED)];
  PlanPotentialRec := PlanDataList.Items[GetaccountListIndex(POTENTIAL)];
//    else OvcTable3.RowLimit := DaysinYear + 2;
  if ComboBox1State = 0
    then begin
    if Accountno = SALESUNIT then
      for j := 0 to OvcTable3.Rowlimit - 2 do
        if PlanBilledRec.PlanDetail[j] <> 0 then
          PlanDataRec.PlanDetail[j] := PlanSalesRec.Plandetail[j] / PlanBilledRec.Plandetail[j]
        else
          PlanDataRec.PlanDetail[j] := 0;
    if Accountno = GPUNIT then
      for j := 0 to OvcTable3.Rowlimit - 2 do    // Iterate
        if PlanBilledRec.PlanDetail[j] <> 0 then
          PlanDataRec.PlanDetail[j] := PlanGPRec.Plandetail[j] / PlanBilledRec.Plandetail[j]
        else
          PlanDataRec.PlanDetail[j] := 0;
    if Accountno = GPPC then
      for j := 0 to OvcTable3.Rowlimit - 2 do    // Iterate
        if PlanSalesRec.PlanDetail[j] <> 0 then
          PlanDataRec.PlanDetail[j] := PlanGPRec.Plandetail[j] * 100 / PlanSalesRec.Plandetail[j]
        else
          PlanDataRec.PlanDetail[j] := 0;
    if Accountno = PRODUCTIVITY then
      for j := 0 to OvcTable3.Rowlimit - 2 do    // Iterate
        if PlanPotentialRec.PlanDetail[j] <> 0 then
          PlanDataRec.PlanDetail[j] := PlanBilledRec.Plandetail[j] * 100 / PlanPotentialRec.Plandetail[j]
        else
          PlanDataRec.PlanDetail[j] := 0;
  end
  else begin
    if Accountno = SALESUNIT then
      for j := 0 to OvcTable3.Rowlimit - 2 do    // Iterate
        if PlanBilledRec.PlanSummary[j] <> 0 then
          PlanDataRec.PlanSummary[j] := PlanSalesRec.PlanSummary[j] / PlanBilledRec.PlanSummary[j]
        else
          PlanDataRec.PlanSummary[j] := 0;
    if Accountno = GPUNIT then
      for j := 0 to OvcTable3.Rowlimit - 2 do    // Iterate
        if PlanBilledRec.PlanSummary[j] <> 0 then
          PlanDataRec.PlanSummary[j] := PlanGPRec.PlanSummary[j] / PlanBilledRec.PlanSummary[j]
        else
          PlanDataRec.PlanSummary[j] := 0;
    if Accountno = GPPC then
      for j := 0 to OvcTable3.Rowlimit - 2 do    // Iterate
        if PlanSalesRec.PlanSummary[j] <> 0 then
          PlanDataRec.PlanSummary[j] := PlanGPRec.PlanSummary[j] * 100 / PlanSalesRec.PlanSummary[j]
        else
          PlanDataRec.PlanSummary[j] := 0;
    if Accountno = PRODUCTIVITY then
      for j := 0 to OvcTable3.Rowlimit - 2 do    // Iterate
        if PlanPotentialRec.PlanSummary[j] <> 0 then
          PlanDataRec.PlanSummary[j] := PlanBilledRec.PlanSummary[j] * 100 / PlanPotentialRec.PlanSummary[j]
        else
          PlanDataRec.PlanSummary[j] := 0;
  end;
end;

procedure TPlanningF.CheckListBox1Click(Sender: TObject);
begin
  if CheckListBox1.ItemIndex > -1
    then begin
    DeleteSeries(CheckListBox1.ItemIndex);
    BuildSeries(CheckListBox1.ItemIndex);
  end;
end;

procedure TPlanningF.CheckBox1Click(Sender: TObject);
begin
  if CheckBox1.Checked then
    Chart1.View3D := True
  else
    Chart1.View3D := False;
  Chart1.refresh;
end;

function TPlanningF.GetUnitTitle(AccountNo : Integer): string;
begin
  case AccountNo of    //
    POTENTIAL: Result := 'Potential ' + AComboBox2.Items[AComboBox2.Itemindex];
    BILLED: Result := 'Billed ' + AComboBox2.Items[AComboBox2.Itemindex];
    SALESUNIT: Result := 'Sales per ' + AComboBox1.Items[AComboBox1.Itemindex];
    GPUNIT: Result := 'GP per ' + AComboBox1.Items[AComboBox1.Itemindex];
    GPPC: Result := 'Gross Profit %';
    PRODUCTIVITY: Result := 'Productivity %';
  end;
end;

procedure TPlanningF.CheckBox2Click(Sender: TObject);
var
  j: Integer;
begin
  for j := 0 to DETAILPLANGRAPHLIST - 1 do    // Iterate
    begin
    DeleteSeries(j);
    BuildSeries(j);
  end;    // for
  Chart1.refresh;
end;

procedure TPlanningF.PlanGetInvoicesBtnClick(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Plan get Invoices Help');
  flush(F);
{$ENDIF}
  OvcTable1.AllowRedraw := False;
  LocalInvType := PlanInv;
  LocalStartDate := DataModuleClient.DepartmentsCurrentPlanStart.Value;
  LocalEndDate := DataModuleClient.DepartmentsCurrentPlanEnd.Value;
  Application.CreateForm(TInvoicesF, InvoicesF);
  InvoicesF.setUnitsDesc(AComboBox1.Items[AComboBox1.Itemindex], AComboBox2.Items[AComboBox2.Itemindex]);
  InvoicesF.ShowModal;
  if InvoiceRate > 0 then
    PlanGPUnit.Value := InvoiceRate;
  InvoicesF.free;
//  InvoicesF.Destroy;
//  InvoicesF := Nil;
  CalculatePastActivity(BILLED);
  OvcTable1.AllowRedraw := True;

end;

procedure TPlanningF.PlanWizardPage4Enter(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Enter Page 4');
  flush(F);
{$ENDIF}
  Label1.Caption := 'Pinpointing Activity and Contribution';
  SetPastDateLabels;
  setlabels;
  getpastactivitybalances;
  calculatePastActivity(SALES);
  calculatePlanActivity(SALES);
end;

procedure TPlanningF.PlanWizardPage4Exit(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Exit Page 4');
  flush(F);
{$ENDIF}
  setPastActivityBalances;
end;

procedure TPlanningF.HelpProdFTEBtnClick(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Plan Prod FTE Help');
  flush(F);
{$ENDIF}
  Application.CreateForm(THelpProdFTEF, HelpProdFTEF);
  HelpProdFTEF.showmodal;
  HelpProdFTEF.free;
//  HelpProdFTEF.Destroy;
//  HelpProdFTEF := nil;
end;

procedure TPlanningF.HelpTotalFteBtnClick(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: FTE HElp');
  flush(F);
{$ENDIF}
  Application.CreateForm(THelpTotalFteF, HelpTotalFteF);
  HelpTotalFTEF.showmodal;
  HelpTotalFTEF.free;
//  HelpTotalFTEF.Destroy;
//  HelpTotalFTEF := nil;
end;

procedure TPlanningF.HelpPotentialHoursBtnClick(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Past Potential Hours Help');
  flush(F);
{$ENDIF}
  Application.CreateForm(THelpPotentialHoursF, HelpPotentialHoursF);
  HelpPotentialHoursF.showmodal;
  if HelpPotentialHoursF.UserSelected <> 0 then
    PastPotUnits.value := PastFTEProduction.value * HelpPotentialHoursF.UserSelected;
  if UnitRounding = 0 then PastPotUnits.value := Round(PastPotUnits.value);
  HelpPotentialHoursF.free;
end;

procedure TPlanningF.HelpPotentialUnitsBtnClick(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Past Potential Units Help');
  flush(F);
{$ENDIF}
  Application.CreateForm(THelpPotentialUnitsF, HelpPotentialUnitsF);
  HelpPotentialUnitsF.showmodal;
  HelpPotentialUnitsF.free;
end;

procedure TPlanningF.FormCreate(Sender: TObject);
begin
 DownArrow := False;
 PageChanging := True;
 ActualDateStart.DisplayFormat := GetDateFDE;
 ActualDateEnd.DisplayFormat := GetDateFDE;
 DataModuleClient.DepartmentsFIRSTPLANDATE.DisplayFormat := GetDateFENH;
 DataModuleClient.DepartmentsLATESTPLANDATE.DisplayFormat := GetDateFENH;
 PlanningStartDate.FirstDayOfWeek := TwwCalDayofWeek(DataModuleClient.DepartmentsLastDayOfWeek.value);
 PlanningEndDate.FirstDayOfWeek := TwwCalDayofWeek(DataModuleClient.DepartmentsLastDayOfWeek.value);
end;

procedure TPlanningF.wwDBNavigator1InsertUpdateState(
  Navigator: TwwDBNavigator; Button: TwwNavButton; Cause: TwwUpdateCause);
begin
  if (DataModuleClient.DateRangers.RecordCount = 5) and (wwDBNavigator1Insert.Enabled = True) then
    wwDBNavigator1Insert.Enabled := False;
end;

procedure TPlanningF.OvcTable3EndEdit(Sender: TObject;
  Cell: TOvcTableCellAncestor; RowNum, ColNum: Integer;
  var AllowIt: Boolean);
begin
  if Colnum = 1 then
    Calcdetail(rownum);
end;

procedure TPlanningF.PlanExtBtnClick(Sender: TObject);
begin
    Application.CreateForm(TPlanExtensionF, PlanExtensionF);
    PlanExtensionF.showmodal;
    PlanExtensionF.free;
    Screen.Cursor := crDefault;
end;

procedure TPlanningF.PlanningEndDateChange(Sender: TObject);
begin
 if PlanningEndDate.Date > InitialPlanEnd then
   PlanExtBtn.Enabled := True;
end;

{
procedure TPlanningF.HelpActualHoursBtnClick(Sender: TObject);
var
  j: Integer;
  WBBalances : TPastBalances;
begin
  OvcTable1.AllowRedraw := False;
  WBData[0] := getListPastBalance(getaccountlistindex(SALES));
  WBData[1] := getListPastBalance(getaccountlistindex(GROSSPROFIT));
  for j := 2 to WORKBACKLIST - 1
    do begin   // Iterate
    DataCollect.GetPastBalances(WBBalances, WorkBackAccounts[j]);
    WBData[j] := WBBalances[DataModuleClient.DateRangersD_Index.value];
  end;
  UnitDescSing := AComboBox1.Items[AComboBox1.Itemindex];
  UnitDescPlur := AComboBox2.Items[AComboBox2.Itemindex];

  Application.CreateForm(THelpActualHoursF, HelpActualHoursF);
  HelpActualHoursF.showmodal;

  if (HelpActualReturn = HTWorkback) and (WBData[LABOURHOURS] > 0)
    then begin
    PastUnitsSold.Value := WBData[LABOURHOURS];
    if UnitRounding = 0 then PastUnitsSold.Value := round(PastUnitsSold.value);
    CalculatePastActivity(SALES);
    for j := 2 to WORKBACKLIST - 1
      do begin   // Iterate
      DataCollect.setPastBalance(@WBData[j], WorkBackAccounts[j]);
    end;
  end;
  if (HelpActualReturn = HTInvoices) and (HelpInvoiceRate > 0)
    then begin
    PastGPUnit.Value := HelpInvoiceRate;
    CalculatePastActivity(BILLED);
  end;
  HelpActualHoursF.Release;
//  HelpActualHoursF.Destroy;
//  HelpActualHoursF := Nil;
  OvcTable1.AllowRedraw := True;
end;
}
procedure TPlanningF.BitBtn1Click(Sender: TObject);
var
  j: Integer;
  PlanDataRec : TPlanDataRecPtr;
  SummaryPtr : TPlanDataRecPtr;
  PlanExpDataRec : TPlanDataRecPtr;
  temparray : TDetailedBalArray;
  fromperiod, toperiod : integer;
//  Cm: integer;
  Oldvalues, NewValues : array[0..PDEND - 1] of currency;
  RecordPtr: array[0..PDEND - 1] of TPlanDataRecPtr;
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Apply detailed info (Page 8)');
  flush(F);
{$ENDIF}
  DetailedOK := False;
  OvcTable3.StopEditingState(False);
  DetailedOK := True;
  OvcTable3.AllowRedraw := False;
  PlanDataRec := PlanDataList.Items[getAccountListIndex(DetailedPlan[DETAILEDEDITSTART + Detailedindex])];
  RecordPtr[PDSALES] := PlanDataList.Items[getAccountListIndex(SALES)];
  RecordPtr[PDGROSS] := PlanDataList.Items[getAccountListIndex(GROSSPROFIT)];
  RecordPtr[PDPOTENTIAL] := PlanDataList.Items[getAccountListIndex(POTENTIAL)];
  RecordPtr[PDBILLED] := PlanDataList.Items[getAccountListIndex(BILLED)];
  RecordPtr[PDSALESUNIT] := PlanDataList.Items[getAccountListIndex(SALESUNIT)];
  RecordPtr[PDGPUNIT] := PlanDataList.Items[getAccountListIndex(GPUNIT)];
  RecordPtr[PDGPPC] := PlanDataList.Items[getAccountListIndex(GPPC)];
  RecordPtr[PDPROD] := PlanDataList.Items[getAccountListIndex(PRODUCTIVITY)];
  RecordPtr[PDOTHER] := PlanDataList.Items[getAccountListIndex(OTHERINCOME)];
  PlanExpDataRec := PlanDataList.Items[GetaccountListIndex(TOTALEXPENSES)];
  // Get current values
  for j := 0 to (PDEND - 1) do
    begin
    // Iterate
    Oldvalues[j] := RecordPtr[j].PlanTotal;
  end;
  // copy as New values
  move(Oldvalues, newValues, sizeof(Currency) * PDEND);
  // if the current account is BILLED or POTENTIAL and unitrounding is zero adjust
  if (UnitRounding = 0)
    and ((PlanDataRec.Accountno = BILLED) or (PlanDataRec.Accountno = POTENTIAL))  then
    DetailedTotal.value := round(DetailedTotal.value);
  // place old value
  NewValues[2 + Detailedindex] := DetailedTotal.value;
  // calculate values
  DetailedCalc(newValues, DetailedPlan[DETAILEDEDITSTART + Detailedindex]);
  // set new values
  fromperiod := 0;
  toperiod := trunc(DataModuleClient.DepartmentsCurrentPlanEnd.value) - trunc(DataModuleClient.DepartmentsCurrentPlanStart.value);
  for j := 0 to (PDEND - 1) do    // Iterate
    begin
    if Oldvalues[j] <> Newvalues[j]
      then begin
      RecordPtr[j].PlanTotal := newvalues[j];
      if RecordPtr[j].accountNo < SALESUNIT
        then begin
        UpdateFromSummaryBalances(RecordPtr[j].Plandetail, temparray,
          newvalues[j], fromperiod, toperiod, RecordPtr[j].Accountno);
        SummaryPtr := PlanDataList.Items[GetaccountListIndex(RecordPtr[j].Accountno)];
        BuildSummary(SummaryPtr.Accountno, True, SummaryPtr.PlanDetail, SummaryPtr.PlanSummary);

      end;    // for
    end;
  end;    // for
  CalculateArray(SALESUNIT);
  CalculateArray(GPUNIT);
  CalculateArray(GPPC);
  CalculateArray(PRODUCTIVITY);
//    for j := 0 to daysinyear do    // Iterate
//      PlanNPDataRec.PlanDetail[j] := RecordPtr[PDGROSS].PlanDetail[j] - PlanExpDataRec.PlanDetail[j];
  CalcNetProfit;
  SummaryPtr := PlanDataList.Items[GetaccountListIndex(NETOPERATINGPROFIT)];
  SummaryPtr.PlanTotal := BuildSummary(SummaryPtr.Accountno, True, SummaryPtr.PlanDetail, SummaryPtr.PlanSummary);
  SummaryPtr := PlanDataList.Items[GetaccountListIndex(NETPROFIT)];
  SummaryPtr.PlanTotal := BuildSummary(SummaryPtr.Accountno, True, SummaryPtr.PlanDetail, SummaryPtr.PlanSummary);
//    for j := 0 to (PDEND - 1) do    // Iterate
//      if RecordPtr[j].accountNo >= SALESUNIT then
//        BuildSummary(GetaccountListIndex(RecordPtr[j].Accountno), False);
  if (RecordPtr[PDBILLED].PlanTotal <> 0) then
    RecordPtr[PDSALESUNIT].PlanTotal := RecordPtr[PDSALES].PlanTotal / RecordPtr[PDBILLED].PlanTotal;
  if (RecordPtr[PDBILLED].PlanTotal <> 0) then
    RecordPtr[PDGPUNIT].PlanTotal := RecordPtr[PDGROSS].PlanTotal / RecordPtr[PDBILLED].PlanTotal;
  if (RecordPtr[PDSALES].PlanTotal <> 0)then
    RecordPtr[PDGPPC].PlanTotal := RecordPtr[PDGROSS].PlanTotal * 100 / RecordPtr[PDSALES].PlanTotal;
  if (RecordPtr[PDPOTENTIAL].PlanTotal <> 0)then
    RecordPtr[PDPROD].PlanTotal := RecordPtr[PDBILLED].PlanTotal * 100 / RecordPtr[PDPOTENTIAL].PlanTotal;
  if DetailedOK then
    DetailedTotal.value := PlanDataRec.PlanTotal;
  DetailedSales.value := RecordPtr[PDSALES].PlanTotal;
  DetailedGrossProfit.value := RecordPtr[PDGROSS].PlanTotal;
  DetailedNetProfit.value := RecordPtr[PDGROSS].PlanTotal - PlanExpDataRec.PlanTotal + RecordPtr[PDOTHER].PlanTotal;
  OvcTable3.invalidate; //Row(OvcTable3.activeRow);
  OvcTable3.AllowRedraw := True;
  OvcTable3.StartEditingState;
  DetailedTotal.SetFocus;
  for j := 0 to DETAILPLANGRAPHLIST - 1 do    // Iterate
    begin
    DeleteSeries(j);
    BuildSeries(j);
  end;    // for
  Chart1.refresh;
end;

procedure TPlanningF.RGSceneClick(Sender: TObject);
begin
  CurrentScene := RGScene.itemIndex + 1;
  WhatIfCalc(WISALES);
end;

procedure TPlanningF.getBase;
begin
  if RGBase.itemindex  = 0
    then begin
    SetWIBalance(WIBase, WISales, getListPastBalance(getaccountlistindex(SALES)));
    SetWIBalance(WIBase, WIGP, getListPastBalance(getaccountlistindex(GROSSPROFIT)));
    SetWIBalance(WIBase, WIPotential, getListPastBalance(getaccountlistindex(POTENTIAL)));
    SetWIBalance(WIBase, WIBilled, getListPastBalance(getaccountlistindex(BILLED)));
    WIBaseTotalExp.Value := getListPastBalance(getaccountlistindex(TOTALEXPENSES));
  end
  else begin
    SetWIBalance(WIBase, WISales, getListPlanBalance(getaccountlistindex(SALES)));
    SetWIBalance(WIBase, WIGP, getListPlanBalance(getaccountlistindex(GROSSPROFIT)));
    SetWIBalance(WIBase, WIPotential, getListPlanBalance(getaccountlistindex(POTENTIAL)));
    SetWIBalance(WIBase, WIBilled, getListPlanBalance(getaccountlistindex(BILLED)));
    WIBaseTotalExp.Value := getListPlanBalance(getaccountlistindex(TOTALEXPENSES));
  end;

  WIBaseSales.value := GetWIBalance(WIBase, WISales);
  WIBaseGP.Value := GetWIBalance(WIBase, WIGP);
  WIBasePotential.Value := GetWIBalance(WIBase, WIPotential);
  WIBaseBilled.Value := GetWIBalance(WIBase, WIBilled);

  if GetWIBalance(WIBase, WISales) <> 0 then
    SetWIBalance(WIBASE, WIGPPC, GetWIBalance(WIBase, WIGP) * 100 / GetWIBalance(WIBase, WISales))
  else
    SetWIBalance(WIBASE, WIGPPC, 0);
  if GetWIBalance(WIBase, WIBilled) <> 0 then
    SetWIBalance(WIBASE, WISU, GetWIBalance(WIBase, WISales) / GetWIBalance(WIBase, WIBilled))
  else
    SetWIBalance(WIBASE, WISU, 0);
  if GetWIBalance(WIBase, WIBilled) <> 0 then
    SetWIBalance(WIBASE, WIGPU, GetWIBalance(WIBase, WIGP) / GetWIBalance(WIBase, WIBilled))
  else
    SetWIBalance(WIBASE, WIGPU, 0);
  if GetWIBalance(WIBase, WIPotential) <> 0 then
    SetWIBalance(WIBASE, WIPROD, GetWIBalance(WIBase, WIBilled) * 100 / GetWIBalance(WIBase, WIPotential))
  else
    SetWIBalance(WIBASE, WIPROD, 0);
  WIBaseGPPC.Value := getWIBalance(WIBASE, WIGPPC);
  WIBaseSalesUnit.Value := getWIBalance(WIBASE, WISU);
  WIBaseGPUnit.Value := getWIBalance(WIBASE, WIGPU);
  WIBaseProductivity.Value := getWIBalance(WIBASE, WIPROD);
  WIBaseNetProfit.Value := GetWIBalance(WIBase, WIGP) - WIBaseTotalExp.Value;
end;

procedure TPlanningF.PastProdExit(Sender: TObject);
begin
  CalculatePastActivity(PRODUCTIVITY);
end;

procedure TPlanningF.PastPotUnitsExit(Sender: TObject);
begin
  CalculatePastActivity(BILLED);
end;

procedure TPlanningF.WIChangeProductivityExit(Sender: TObject);
begin
  WIScenGPPC.SetFocus;
end;

procedure TPlanningF.PlanPotUnitsExit(Sender: TObject);
begin
  CalculatePlanActivity(SALES);
end;

procedure TPlanningF.fcImageBtn3Click(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: WI Target Expenses');
  flush(F);
{$ENDIF}
  fcShapeBtn4Click(Sender);
  WIScenTotalExp.Value := getListPlanBalance(getaccountlistindex(TOTALEXPENSES));
  WhatIfCalc(WISALES);
end;

procedure TPlanningF.OvcTable3Exit(Sender: TObject);
begin
  OvcTable3ExitCaught := True;
end;

procedure TPlanningF.PlanHelpPotentialHoursBtnClick(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Plan Potential Hours Help');
  flush(F);
{$ENDIF}
  Application.CreateForm(THelpPotentialHoursF, HelpPotentialHoursF);
  HelpPotentialHoursF.showmodal;
  if HelpPotentialHoursF.UserSelected <> 0 then
    PlanPotUnits.value := PlanFTEProduction.value * HelpPotentialHoursF.UserSelected;
  if UnitRounding = 0 then PlanPotUnits.value := Round(PlanPotUnits.value);
  HelpPotentialHoursF.free;
end;

procedure TPlanningF.PastInvoicesBnClick(Sender: TObject);
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Past Invoices HElp');
  flush(F);
{$ENDIF}
  LocalInvType := AnalysisInv;
  LocalStartDate := DataModuleClient.DateRangersStartDate.Value;
  LocalEndDate := DataModuleClient.DateRangersEndDate.Value;
  Application.CreateForm(TInvoicesF, InvoicesF);

  InvoicesF.setUnitsDesc(AComboBox1.Items[AComboBox1.Itemindex], AComboBox2.Items[AComboBox2.Itemindex]);
  InvoicesF.ShowModal;
  if InvoiceRate > 0 then
    begin
    PastGPUnit.Value := InvoiceRate;
    CalculatePastActivity(BILLED);
    end;
  InvoicesF.free;
end;

procedure TPlanningF.WorkBackBtnClick(Sender: TObject);
var
  j : integer;
  WBBalances : TPastBalances;
begin
{$IFDEF TextDebug}
  writeln(F, 'Plan: Past WB HElp');
  flush(F);
{$ENDIF}
  WBData[0] := getListPastBalance(getaccountlistindex(SALES));
  WBData[1] := getListPastBalance(getaccountlistindex(GROSSPROFIT));
  for j := 2 to WORKBACKLIST - 1
    do begin   // Iterate
    DataCollect.GetPastBalances(WBBalances, WorkBackAccounts[j]);
    WBData[j] := WBBalances[DataModuleClient.DateRangersD_Index.value - 1];
  end;
  Application.CreateForm(TWorkBackF, WorkBackF);
  if WorkBackF.ShowModal = mrOK then
  begin
    if (WBData[LABOURHOURS] > 0) then
    begin
      PastUnitsSold.Value := WBData[LABOURHOURS];
      if UnitRounding = 0 then PastUnitsSold.Value := round(PastUnitsSold.value);
      CalculatePastActivity(SALES);
      for j := 2 to WORKBACKLIST - 1 do
      begin   // Iterate
        DataCollect.setPastBalance(@WBData[j], WorkBackAccounts[j]);
      end;
    end;
  end;
  WorkBackF.free;
end;

procedure TPlanningF.PlanningWizardChanging(Sender: TObject);
//var
//  I : Integer;
//  What : Boolean;
begin
  if (PlanningWizard.activePage = PlanWizardPage1) then
    begin
    // must be advancing and therefore we must have data to play with!!
    screen.Cursor := crHourGlass;
    DataCollect.GetConsolidatedList(False);
    if DataCollect.Planloaded = false then
      Begin
      DataCollect.getPlanningData;
      end;
    end;

  if (PlanningWizard.activePage = PlanWizardPage2) and (not PlanningWizard.Advancing) then
  begin
    if DataCollect.Planloaded = True then
      DataCollect.setPlanningData;
    DataCollect.ClearPlanDataList;
  end;
end;

procedure TPlanningF.DBNavigator1Click(Sender: TObject;
  Button: TNavigateBtn);
begin
  SelectedPastDate := DataModuleClient.DateRangersENDDATE.Value;
  with OvcTable1 do
  begin
    SetPastDateLabels;
    CalculateSummary(ActiveRow, ColPastBal);
    CalculateSummary(ActiveRow, ColPlanBal);
    InvalidateTable;
    StartEditingState;
    AllowRedraw := True;
  end;
  if Planningwizard.ActivePage = PlanWizardPage4 then
  begin
    setlabels;
    getpastactivitybalances;
//    calculatePastActivity(SALES);
  end;
end;

procedure TPlanningF.DBNavigator1BeforeAction(Sender: TObject;
  Button: TNavigateBtn);
begin
  with OvcTable1 do
  begin
    StopEditingState(True);
    AllowRedraw := False;
  end;
  if Planningwizard.ActivePage = PlanWizardPage4 then
    setPastActivityBalances;
end;

procedure TPlanningF.wwDBGrid1ColExit(Sender: TObject);
begin
// If the 1st column see that we have a date.
// If the second column make sure date is different from any other PE date for actual to avoid Invalid data entry
end;

procedure TPlanningF.handlePastDates(var Msg : TMessage);
begin
  if (Msg.WParam < 5) and  (Msg.LParam = DELETION) then
    wwDBNavigator1Insert.Enabled := True;
  if (Msg.WParam = 5) and  (Msg.LParam = POSTING) then
    wwDBNavigator1Insert.Enabled := False;
end;

procedure TPlanningF.wwDBGrid1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  Application.ProcessMessages;
end;

function TPlanningF.EnddateExists(Newdate : TDateTime): Boolean;
var
  varg : Variant;
begin
  varg := VarArraycreate([0,2], VarVariant);
  varg[0] := DatamoduleClient.DepartmentsDEPT_ID.Value;
  Varg[1] := Newdate;
  Result := DatamoduleClient.DateRef.Locate('DEPT_ID;EndDate',varg, []);
end;

procedure TPlanningF.ActualDateStartExit(Sender: TObject);
var
  d, m, y : Word;
  Newdate : TdateTime;
  ChangeYear : Boolean;
begin
  decodeDate(ActualDateStart.DateTime, y, m, d);
  ChangeYear := False;
  // if end of month
  if d = 1 then
  begin
    if m <> 1 then // Different year
      ChangeYear := True;
    if m > 1 then dec(m) else m := 12;
    if ChangeYear then
      d := DaysInMonth(m, Y + 1, 1950)
    else
      d := DaysInMonth(m, Y, 1950);
  end
  else
    begin
    ChangeYear := True;
    dec(d);
    end;
  if ChangeYear then Inc(y);
  Newdate := encodedate(y, m, d);
  // Does this end date already exist??
  while EnddateExists(newdate) do Newdate := Newdate - 1;
  if not (DataModuleClient.DSDateRangers.State in [dsEdit, dsInsert]) then
    DataModuleClient.DateRangers.Edit;
  DatamoduleClient.DateRangersENDDATE.Value := Newdate;
end;

procedure TPlanningF.ActualDateEndExit(Sender: TObject);
var
  d, d1, m, y : Word;
begin
  decodeDate(ActualDateEnd.DateTime, y, m, d);
  d1 := DaysInMonth(m, Y, 1950);
  if (m <> 12) and (d1 = d) then
    dec(y);
  if d = d1 then
  begin
    if m = 12 then m := 1 else inc(m);
    d := 1;
  end
  else
    inc(d);
  if not (DataModuleClient.DSDateRangers.State in [dsEdit, dsInsert]) then
    DataModuleClient.DateRangers.Edit;
  DatamoduleClient.DateRangersSTARTDATE.Value := encodedate(y, m, d);
end;

procedure TPlanningF.ActualDateStartDropDown(Sender: TObject);
begin
  DataModuleClient.DateRangers.Edit;
end;

procedure TPlanningF.DBEdit1Click(Sender: TObject);
begin
//  PlanningStartDate.SetFocus;
end;

procedure TPlanningF.OvcTable3KeyPress(Sender: TObject; var Key: Char);
begin
  if Key = Char(vk_RETURN) then
    Key := char(vk_Tab);
end;

procedure TPlanningF.OvcTable3KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = Word(VK_RETURN) then
    Key := VK_TAB;
    
end;

procedure TPlanningF.PlanningWizardKeyPress(Sender: TObject;
  var Key: Char);
begin
//  if PlanningF.ActiveControl.Name = 'OvcTable3' then
    if Key = Char(VK_RETURN) then
      Key := char(VK_TAB);
end;

procedure TPlanningF.OvcTable1KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = VK_RETURN then
    Key := VK_DOWN;
end;

procedure TPlanningF.PlanWizardPage8DoneQuery(Sender: TObject;
  var Done: Boolean);
begin
  if PlanningF.ActiveControl.Name = 'OvcTable3' then Done := False;
end;

procedure TPlanningF.wwDBNavigator1InsertClick(Sender: TObject);
begin
  wwdbGrid1.SetFocus;
end;

procedure TPlanningF.FormShow(Sender: TObject);
begin
  wwDBgrid1.SetFocus;
  Datacollect.GetDetailedOptions;
end;

procedure TPlanningF.wwDBEdit1Click(Sender: TObject);
begin
  PlanningStartDate.SetFocus;
end;

procedure TPlanningF.wwDBNavigator1FirstUpdateState(
  Navigator: TwwDBNavigator; Button: TwwNavButton; Cause: TwwUpdateCause);
begin
  if (DataModuleClient.DateRangers.RecordCount = 5) and (wwDBNavigator1Insert.Enabled = False) then
    wwDBNavigator1Insert.Enabled := True;
end;

procedure TPlanningF.OvcTable2Exit(Sender: TObject);
begin
  OvcTable2.Invalidate;
end;

procedure TPlanningF.OvcTable2DoneEdit(Sender: TObject; RowNum,
  ColNum: Integer);
begin
  if (RowNum  = 0) then exit;
  case ColNum Of
    colMarker,
    colTitle,
    colSubTitle,
    colPastBalPc,
    colPlanBalPc:  Exit;
    colPastBal,
    colPlanBal: ; //calculateFieldValues(RowNum, ColNum);
  end;

  // Update the grid with the new balances
  with OvcTable2
  do begin
    AllowRedraw := False;
    InvalidateTable;
    AllowRedraw := True;
  end;
end;

end.


