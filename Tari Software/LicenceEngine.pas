 unit LicenceEngine;

interface

uses Windows, Messages, SysUtils, Controls, Classes, auchtypes, ExtCtrls, inifiles,
     DataCollector, dateutils, Registry, LGlobals, DMUsers, DMClient, dialogs,
		 StrUtils, LicenceCalc, IB_Components, TypInfo;

Const
  APPINI = 'Tari.ini';
  BaseChars : array[0..32] of char = ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','J','K','L','M','N','P','Q','R','T','U','V','W','X','Y','Z');
  TRIALKEY = 'Password';

type

	TDateOrder = (doMDY, doDMY, doYMD);

	TFileInfoPtr = ^TWin32FileInfoData; TWin32FileInfoData = Record
    FileAttributes : Dword;
    CreationTime : TFileTime;
    LastAccessTime : TFileTime;
    LastWriteTime : TFileTime;
    FileSizeHigh  : Dword;
    FileSizeLow : DWord;
  end;

  TLicenceEngine = Class(TObject)
  Private
    TmpLicenceRec : TLicenceRecType;
    function getfilesystemname(filepath : string):string;
    function ConvertDate(Olddate : String): TDateTime;
    function getRootDir(src : string) : string;
    function LOScanDate(const S: string; DFormat : TDateOrder; var Pos: Integer;  var Date: TDateTime): Boolean;
		procedure ScanBlanks(const S: string; var Pos: Integer);
    procedure ScanToNumber(const S: string; var Pos: Integer);
    function GetEraYearOffset(const Name: string): Integer;
    function ScanNumber(const S: string; var Pos: Integer; var Number: Word; var CharCount: Byte): Boolean;
    function ScanChar(const S: string; var Pos: Integer; Ch: Char): Boolean;
//    function ScanString(const S: string; var Pos: Integer; const Symbol: string): Boolean;
    function LoadLicencingFile : Boolean;
    procedure LicenceTableCheck;
		function stripDatechars(sformat: string): string;
	Public
    LicenceRec : TLicenceRecType;
    SiteNumber : DWord;
    NoOfUsers : Integer;
    BusinessLicName : String;
    BusinessLicFile : String;
    InvNumber : string;
		LicenceType : string;
		DateConverted : Boolean;
		LastLicenceResult : TLicCheck;
		UseFBMConnection : Boolean;
		Constructor Create;
		Destructor Destroy; Override;
		Procedure LoadLicenceRecord;
		procedure SaveLicenceRecord;
		function GetSiteNumber(BaseFolder : String): DWord;
		function SiteLicenced: TLicCheck;
		function FileLicenced: TLicCheck;
		function CheckLicenceDetails: TLicCheck;
		function isSTDTime(northern : Boolean; timez : TTimeZoneInformation; ldate : TDateTime): Boolean;
		procedure fixdate(var timez: SystemTime; Fdate: _FileTime);
		function GetTrialExpiry: TDateTime;
		function TestTrialDate: Boolean;
		procedure SetTrialExpiryDate(ExDate : TDateTime);
		function BlankSerialNumber(SerNumber: string): Boolean;
		function ValidSerialNumber(SerNumber: String): Boolean;
		function IsSiteSerialNumber(SerialNum: String): Boolean;
		procedure SaveCurrentLicenceRec;
		procedure RestoreLicenceRec;
		function GetCurrentFileName: String;
		function GetCurrentBusinessName: String;
		procedure SetProductRegistry(PSerialNo : String);
	end;
var
	LicEngine : TLicenceEngine;

implementation


{
  The unit FBMLicenceSL_Intf.pas will be generated by the RemObjects preprocessor the first time you
  compile your server application. Make sure to do that before trying to compile the client.

  To invoke your server simply typecast your server to the name of the service interface like this:

      (RORemoteService as IFBMLicence).Sum(1,2)
}

constructor TLicenceEngine.create;
begin
  Inherited Create;
  LicenceRec.UpdateLog := 0;
end;

destructor TLicenceEngine.Destroy;
begin
  inherited destroy;
end;

procedure TLicenceEngine.SaveCurrentLicenceRec;
begin
  Move(LicenceRec, TmpLicenceRec, Sizeof(TLicenceRecType));
end;

procedure TLicenceEngine.RestoreLicenceRec;
begin
  Move(TmpLicenceRec, LicenceRec, Sizeof(TLicenceRecType));
end;

function TLicenceEngine.SiteLicenced: TLicCheck;
begin
  if not DMUserM.FBMADMINDB.connected then
    begin
    Result := LCNotConnected;
    Exit;
    end;
  UseFBMConnection := True;
  LicenceTableCheck;
// if GGlobals.lictemp is true was are licencing via email and we should load the contents of
  LoadLicenceRecord; // get current Licence Details
  // if we have a licence File emailed in, load it.
  GGlobals.TrainingLicence := False;
  If LoadLicencingFile then
    SaveLicenceRecord;
  Result := CheckLicenceDetails;
end;

function TLicenceEngine.FileLicenced: TLicCheck;
begin
  if not DataModuleClient.ClientDatabase.connected then
    begin
    Result := LCNotConnected;
    Exit;
    end;
  UseFBMConnection := False;
  LicenceTableCheck;
// if GGlobals.lictemp is true was are licencing via email and we should load the contents of
  LoadLicenceRecord; // get current Licence Details
  // check LicenceRecord
  GGlobals.TrainingLicence := False;
  if LicenceRec.SerialNumber = '0800-0002-T88E' then
    GGlobals.DemoFileLicenced := True
  else
    begin
    GGlobals.DemoFileLicenced := False;
    if LicenceRec.SerialNumber = '0800-0566-KKAT' then
      GGlobals.TrainingLicence := True;
    if Length(LicenceRec.BusinessFileName) = 0  then
      LicenceRec.BusinessFileName := ExtractFileName(DataModuleClient.ClientDatabase.Path);
    if LicenceRec.BusinessFileName <> ExtractFileName(DataModuleClient.ClientDatabase.Path) then
      begin
      Result := LCFileNameIncorrect;
      Exit;
      end;
    end;
    // if we have a licence File emailed in, load it.
  If (GGlobals.LicTemp) and (LoadLicencingFile) then
    SaveLicenceRecord;
  Result := CheckLicenceDetails;
//  if Not GGlobals.DemoFileLicenced then
//    Result := CheckLicenceDetails
//  else
//    Result := LCLicOK;
end;

procedure TLicenceEngine.LicenceTableCheck;
var
  Varg : Variant;
begin
  Varg := 'LICENCING';
  if UseFBMConnection then
    DmuserM.qryListofTables.IB_Connection := DMUserM.FBMADMINDB
  else
    DmuserM.qryListofTables.IB_Connection := DatamoduleClient.ClientDatabase;
  DMUserM.qryListofTables.Active := True;
  if (Not DMUserM.qryListofTables.Locate('RDB$RELATION_NAME', varg, [])) then
    begin
    DMUserM.CreateLicencingScript.IB_Connection := DmuserM.qryListofTables.IB_Connection;
    DMUserM.CreateLicencingScript.Prepare;
    DMUserM.CreateLicencingScript.Execute;
    DMUserM.CreateLicencingScript.IB_Transaction.Commit;
    DMUserM.CreateLicencingScript.Unprepare;
    end;
end;

procedure TLicenceEngine.SetProductRegistry(PSerialNo : String);
var
  Reg: TRegistry;
  ProductSerialNo : String;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    if Reg.OpenKey('\SOFTWARE\Focus Based Management\Message Service', True) then
      begin
      ProductSerialNo := Reg.ReadString('Product Serial Number');
      if Length(ProductSerialNo) = 0 then  // If it does not exist, add one
        Reg.WriteString('Product Serial Number', PSerialNo);
      Reg.CloseKey;
      end;
  finally
    Reg.Free;
  end;
end;

function TLicenceEngine.GetSiteNumber(BaseFolder: string): DWord;
var
  FileNameC : array [0..200] of char;
  Fname, fsName : String;
  FileHandle : THandle;
  CreationTime, LastAccessTime, WriteTime : TFileTime;
  CrDate, TodayDate, StdDate, DSDate : TDateTime;
  tmpST : SYSTEMTIME;
  tzone : TTimeZoneInformation;
  adjust : longint;
  NorthernHemi, CrisStd, TodayisSTD : Boolean;
  AYear, AMonth, ADay, AHour, AMinute, ASecond, AMilliSecond: Word;
begin
  Fname := Basefolder + '.Serial';
  strPcopy(FileNameC, Fname);
  if Not FileExists(Fname) then
    FileHandle := createfile(FileNameC, DWord(GENERIC_WRITE),
      DWord(FILE_SHARE_WRITE), nil, DWord(CREATE_NEW),DWord(FILE_ATTRIBUTE_HIDDEN), 0)
  else
    FileHandle := createfile(FileNameC, DWord(GENERIC_READ),
      DWord(FILE_SHARE_READ), nil, DWord(OPEN_EXISTING),DWord(FILE_ATTRIBUTE_HIDDEN), 0);

  if FileHandle = INVALID_HANDLE_VALUE then
    begin
    GetLastError;
    Result := 0;
    end
  else
    begin
    if GetFileTime(hfile(FileHandle), @CreationTime, @LastAccessTime, @WriteTime) then
      begin
      fsname := getfilesystemname(fname);
      if CreationTime.dwLowDateTime <> 0 then CreationTime := WriteTime;
      if (fsname = 'FAT') or (fsname = 'FAT32') then
        begin
        getTimeZoneInformation(tZone);
        if tzone.StandardDate.wMonth <> 0 then
          begin
          if tzone.standarddate.wYear = 0 then fixdate(tzone.Standarddate, CreationTime);
          if tzone.Daylightdate.wYear = 0 then fixdate(tzone.DaylightDate, CreationTime);
          todayDate := now();
          fileTimetoSystemtime(CreationTime, tmpST);
          crDate := SystemTimeToDateTime(tmpST);
          STDDate := SystemTimetoDateTime(tzone.StandardDate);
          DSDate := SystemTimetoDateTime(tzone.DayLightDate);
          if (STDDate < DSDate) then  // Southern Hemisphere
            NorthernHemi := False
          else
            NorthernHemi := True;
          crisSTD := isStdTime(NorthernHemi, tzone, crdate);
          todayisSTD := isSTDTime(NorthernHemi, tzone, todayDate);
          if crisSTD <> todayisSTD then
            begin
            if crisSTD then
              adjust := -tzone.DaylightBias
            else
              adjust := tzone.DaylightBias;
            int64(CreationTime) := int64(CreationTime) + (int64(600000000) * (adjust));
            end;
          end;
        end;
      fileTimetoSystemtime(CreationTime, tmpST);
      crDate := SystemTimeToDateTime(tmpST);
      DecodeDateTime(crdate, AYear, AMonth, ADay, AHour, AMinute, ASecond, AMilliSecond);
      ASecond := 0;
      AMillisecond := 0;
      CRDate := EncodeDateTime(AYear, AMonth, ADay, AHour, AMinute, ASecond, AMilliSecond);
      DateTimeToSystemTime(CrDate, tmpST);
      SystemTimeToFileTime(tmpSt, CreationTime);
      if CreationTime.dwLowDateTime <> 0 then
        Result := CreationTime.dwHighDateTime Mod 999999 + CreationTime.dwLowDateTime mod 1000000
      else
        Result := WriteTime.dwHighDateTime Mod 999999 + WriteTime.dwLowDateTime mod 1000000;
      end
    else
      Result := 0;
    CloseHandle(FileHandle);
    end;
//  ONLY WORKS FOR NT, ME and Later versions
//  if GetFileAttributesEx(FileNameC, GetFileExInfoStandard, @FileInfo) then
//    Result := FileInfo.ftCreationTime.dwHighDateTime Mod 999999 + FileInfo.ftCreationTime.dwLowDateTime mod 1000000
//  else
//    result := 0;
  if Result = 0 then Result := 654321;   // A default Value
end;

procedure TLicenceEngine.LoadLicenceRecord;
Var
  Varg : Variant;
begin
  DMuserM.Licencing.Active := False;
  if UseFBMConnection then
    DmuserM.Licencing.IB_Connection := DMUserM.FBMADMINDB
  else
    DmuserM.Licencing.IB_Connection := DatamoduleClient.ClientDatabase;
  DMUserM.Licencing.Active := True;
  FillChar(LicenceRec, sizeof(TLicenceRecType), #0);
  Varg := 1;
  if DMUserM.Licencing.Locate('LIC_ID', varg, []) then
		begin
		LicenceRec.BusinessName := DMUserM.LicencingBUSINESS_NAME.AsString;
		LicenceRec.LastName := ExtractLastName(DMUserM.LicencingCONTACT_NAME.AsString);
		LicenceRec.FirstName := ExtractFirstName(DMUserM.LicencingCONTACT_NAME.AsString);
		LicenceRec.Address1 := DMUserM.LicencingADDRESS1.AsString;
		LicenceRec.Address2 := DMUserM.LicencingADDRESS2.AsString;
		LicenceRec.Suburb := DMUserM.LicencingSUBURB.AsString;
		LicenceRec.State := DMUserM.LicencingSTATE_REGION.AsString;
		LicenceRec.Postcode := DMUserM.LicencingPOST_CODE.AsString;
		LicenceRec.Country := DMUserM.LicencingCOUNTRY.AsString;
		LicenceRec.PhoneNumber := DMUserM.LicencingPHONE_NUMBER.AsString;
		LicenceRec.FaxNumber := DMUserM.LicencingFAX_NUMBER.AsString;
		LicenceRec.EmailAddress := DMUserM.LicencingEMAIL_ADDRESS.AsString;
		LicenceRec.SerialNumber := DMUserM.LicencingSERIALNUMBER.AsString;
    LicenceRec.Channel_ID := DMUserM.LicencingSUPPLIER_ID.Value;
    if not DMUserM.LicencingSITENUMBER.IsNull then
      LicenceRec.SiteNumber := DMUserM.LicencingSITENUMBER.Value
    else
      LicenceRec.SiteNumber := 0;
		LicenceRec.LicenceeName := DMUserM.LicencingLICENCEENAME.AsString;
		LicenceRec.LicenceType := DMUserM.LicencingLICENCETYPE.AsString;
		LicenceRec.BusinessFileName := DMUserM.LicencingBUSINESSFILENAME.AsString;
    if not DMUserM.LicencingEXPIRYDATE.IsNull then
      LicenceRec.ExpiryDate := DMUserM.LicencingEXPIRYDATE.Value
    else
      LicenceRec.ExpiryDate := now + 7;
    LicenceRec.NumberofUsers := DMUserM.LicencingNUMBEROFUSERS.Value;
    LicenceRec.LicenceNumber := DMUserM.LicencingLICENCENUMBER.AsString;
    end;
  DMUserM.Licencing.Active := False;
end;

procedure TLicenceEngine.SaveLicenceRecord;
Var
  Varg : Variant;
begin
  DMuserM.Licencing.Active := False;
  if UseFBMConnection then
    DmuserM.Licencing.IB_Connection := DMUserM.FBMADMINDB
  else
    DmuserM.Licencing.IB_Connection := DatamoduleClient.ClientDatabase;
  DMUserM.Licencing.Active := True;
  Varg := 1;
  if DMUserM.Licencing.Locate('LIC_ID', varg, []) then
    DMUserM.Licencing.Edit
  else
    begin
    DMUserM.Licencing.Insert;
    DMUserM.LicencingLIC_ID.Value := 1;
    end;
	DMUserM.LicencingBUSINESS_NAME.AsString := LicenceRec.BusinessName;
	DMUserM.LicencingCONTACT_NAME.AsString := CreateFullName(LicenceRec.FirstName, LicenceRec.LastName);
	DMUserM.LicencingADDRESS1.AsString := LicenceRec.Address1;
	DMUserM.LicencingADDRESS2.AsString := LicenceRec.Address2;
	DMUserM.LicencingSUBURB.AsString := LicenceRec.Suburb;
	DMUserM.LicencingSTATE_REGION.AsString := LicenceRec.State;
	DMUserM.LicencingPOST_CODE.AsString := LicenceRec.Postcode;
	DMUserM.LicencingCOUNTRY.AsString := LicenceRec.Country;
	DMUserM.LicencingPHONE_NUMBER.AsString := LicenceRec.PhoneNumber;
	DMUserM.LicencingFAX_NUMBER.AsString := LicenceRec.FaxNumber;
	DMUserM.LicencingEMAIL_ADDRESS.AsString := LicenceRec.EmailAddress;
	DMUserM.LicencingSERIALNUMBER.AsString := LicenceRec.SerialNumber;
  DMUserM.LicencingSUPPLIER_ID.Value := LicenceRec.Channel_ID;
  DMUserM.LicencingSITENUMBER.Value := LicenceRec.SiteNumber;
	DMUserM.LicencingLICENCEENAME.AsString := LicenceRec.LicenceeName;
	DMUserM.LicencingLICENCETYPE.AsString := LicenceRec.LicenceType;
	DMUserM.LicencingBUSINESSFILENAME.AsString := LicenceRec.BusinessFileName;
  DMUserM.LicencingEXPIRYDATE.Value := LicenceRec.ExpiryDate;
  DMUserM.LicencingNUMBEROFUSERS.Value := LicenceRec.NumberofUsers;
  DMUserM.LicencingLICENCENUMBER.AsString := LicenceRec.LicenceNumber;
  DMUserM.Licencing.Post;
  DMUserM.Licencing.Active := False;
end;

function TLicenceEngine.IsSiteSerialNumber(SerialNum: String): Boolean;
begin
  if Leftstr(SerialNum, 2) = '07' then
    result := True
  else
    result := False;
end;

Function TLicenceEngine.LoadLicencingFile: Boolean;
var
  DataIni : TIniFile;
begin
  Result := False;
  if fileexists(GGlobals.Licdir + 'TempLic.ini') then
    begin
    DataIni := TiniFile.create(GGlobals.Licdir + 'TempLic.ini');
    GGlobals.DebugOut('Licence ini File = ' + GGlobals.Licdir + 'TempLic.ini');
    LicenceRec.BusinessName := DataIni.ReadString('Licencee Details', 'Business Name', '');
    LicenceRec.FirstName := ExtractFirstName(Dataini.ReadString('Licencee Details', 'Contact',''));
    LicenceRec.LastName := ExtractLastName(Dataini.ReadString('Licencee Details', 'Contact',''));
    LicenceRec.PhoneNumber := Dataini.ReadString('Licencee Details', 'Phone','');
    LicenceRec.FaxNumber := Dataini.ReadString('Licencee Details', 'Fax','');
    LicenceRec.EmailAddress := Dataini.ReadString('Licencee Details', 'Email','');

    LicenceRec.SerialNumber := DataIni.Readstring('Licence', 'Serial Number', '');
    LicenceRec.LicenceType := DataIni.Readstring('Licence', 'Licence Type', 'N');
    LicenceRec.LicenceeName := DataIni.ReadString('Licence', 'Licencee Name', '');
    LicenceRec.LicenceNumber := DataIni.ReadString('Licence', 'Licence Number', '');
    LicenceRec.BusinessName := DataIni.ReadString('Licence', 'Business Name', '');
    LicenceRec.BusinessFileName := DataIni.ReadString('Licence', 'Business File Name', '');
    LicenceRec.Channel_ID := DataIni.ReadInteger('Licence', 'Supplier ID', 0);
    LicenceRec.ExpiryDate := Convertdate(DataIni.ReadString('Licence', 'Expiry Date', ''));
    LicenceRec.NumberofUsers := 1;
    LicenceRec.BusinessID := DataIni.ReadInteger('Licence', 'BusinessID', 0);
    LicenceRec.LicenceMethod := DataIni.ReadInteger('Licence', 'Method', 0);
    Dataini.Free;
    Result := True;
    DeleteFile(GGlobals.Licdir + 'TempLic.ini');
    end;
end;

function TLicenceEngine.CheckLicenceDetails: TLicCheck;
var
  newLicence : string;
  currentLicenceNumber : string;
  CurrentExpiry : TDateTime;
begin
  result := LCLicOk;
  SiteNumber := getSiteNumber(GGlobals.Licdir);
  LicenceRec.SiteNumber := SiteNumber;
  if (Leftstr(LicenceRec.SerialNumber, 2) = '09') then
    licenceRec.ExpiryDate := 0;
  if length(LicenceRec.SerialNumber) < 1 then
    Result := LCNoLic
  else
    if (LicenceRec.ExpiryDate = 0) or ((LicenceRec.ExpiryDate > 0) and (CompareDate(LicenceRec.ExpiryDate, now) < 0)) then
      begin
      // if the licence has been active, we try via internet to update the
      // we start seeing if the date has extended the date after it expires
      LicenceRec.Computername := GGlobals.Servers.CurrentServer.ServerName;
      LicenceRec.OperatingSystemName := GGlobals.GetOperatingSystem;
      LicenceRec.OSVersion := Versioninfo;
      CurrentExpiry := LicenceRec.ExpiryDate;
      CurrentLicenceNumber := LicenceRec.LicenceNumber;
      DMUserM.DMLicrec := @LicenceRec;
      Licengine.LicenceRec.UpdateLog := 0; //set here on user action and reset after trying server
      if ((Leftstr(LicenceRec.SerialNumber, 2) <> '09') and (not DMUserM.DoHttpLicence(False))) then
        begin
        // even if it fails - we can still carryon for a while - 7 days.
        if ((LicenceRec.ExpiryDate > 0) and (CompareDate(LicenceRec.ExpiryDate + 7, now) < 0)) then
          Result := LCExpired
        else
          begin
          LicenceRec.ExpiryDate := CurrentExpiry;
          if CurrentLicenceNumber = checkCalc(LicenceRec.SiteNumber, LicenceRec) then
            Result := LCLicOK
          else
            Result := LCInvalidLic;
          end;
        end
      else
        begin
        Result := LCLicOk;
        NewLicence := checkCalc(LicenceRec.SiteNumber, LicenceRec);
        if (Leftstr(LicenceRec.SerialNumber, 2) = '09') then
          LicenceRec.LicenceNumber := NewLicence; // Whatever the internal calc is, it's OK
        if NewLicence = Licencerec.LicenceNumber then
          begin
          SetProductRegistry(LicenceRec.SerialNumber);
          SaveLicenceRecord;
          end;
        end;
      end
    else
      begin
//      LicenceRec.LicenceNumber := checkCalc(SiteNumber, LicenceRec);
      if ((Leftstr(LicenceRec.SerialNumber, 2) <> '09') and (LicenceRec.LicenceNumber <> checkCalc(SiteNumber, LicenceRec))) then
        Result := LCInvalidLic;
      end;
  if (Result = LCLicOK) and (((Leftstr(LicenceRec.SerialNumber, 2) = '09')) or ((CompareDate(LicenceRec.ExpiryDate, now) >= 0) and (CompareDate(incDay(now, 30 ), LicenceRec.ExpiryDate) > 0))) then
    begin
    // this is where we should ensure the message serial number is set
    SetProductRegistry(LicenceRec.SerialNumber);
    if (Leftstr(LicenceRec.SerialNumber, 2) <> '09') then
      begin
      GGlobals.daystoRun := DaysBetween(IncDay(Licencerec.ExpiryDate, 1), now);
      Result := LCGRace;
      end
    else
      GGlobals.DaysToRun := 365;
    end;
end;

function TLicenceEngine.getfilesystemname(filepath : string):string;
var
  volSerialNo : Cardinal;
  maxCompLen, fsFlags : DWORD;
  rootdir : string;
  fsname : array[0..255] of char;
begin
  rootDir := getRootDir(filepath);
  GetVolumeInformation(PChar(rootDir), nil, 0, @volSerialNo, maxCompLen, fsFlags, fsname, 255);
  Result := strpas(fsname);
end;

function TLicenceEngine.isSTDTime(northern : Boolean; timez : TTimeZoneInformation; ldate : TDateTime): Boolean;
var
  StdDate, DSDate : TDateTime;
begin
  STDDate := SystemTimetoDateTime(timez.StandardDate);
  DSDate := SystemTimetoDateTime(timez.DayLightDate);
  result := True; // set default
  if northern then  // Northern Hemisphere
    begin
    if ((lDate < STDDate) and (lDate > DSDate)) then
       result := False;
  end;
  if Not Northern then
    begin
    if ((lDate < STDDate) or (lDate > DSDate)) then
       result := False;
  end;
end;

procedure TLicenceEngine.fixdate(var timez: SystemTime; Fdate: _FileTime);
var
  sysdate : SYSTEMTIME;
  tmpdate : TDateTime;
begin
  filetimetosystemtime(fDate, Sysdate);
  timez.wYear := sysdate.wYear;
  if timez.wDay < 5 then
  begin
    tmpdate := EncodeDate(timez.wyear, timez.wMonth, word(1));
    while (DayOfWeek(tmpdate)- 1) <> timez.wDayOfWeek do
      tmpdate := tmpdate + 1;
    Tmpdate := TmpDate + (7 * (timez.wDay - 1));
  end
  else
  begin
    tmpdate := EncodeDate(timez.wyear, timez.wMonth, word(MonthDays[IsLeapYear(timez.wyear),timez.wMonth]));
    while (DayOfWeek(tmpdate)- 1) <> timez.wDayOfWeek do
      tmpdate := tmpdate - 1;
  end;
  decodedate(tmpdate,timez.wyear,timez.wmonth,timez.wday);
end;

function TLicenceEngine.stripDatechars(sformat: string): string;
var
	I : integer;
	ch : char;
	changed : String;
begin
	Result := '';
	ch := ' ';
	Changed := UpperCase(sformat);
	for I := 1 to length(Changed) do
		begin
		if ((CharInSet(Changed[i], ['D', 'M', 'Y'])) AND (Changed[i] <> ch )) then
			begin
			RESULT := Result + char(Changed[i]);
			ch := Changed[i];
			end;
		end;
end;

function TLicenceEngine.ConvertDate(Olddate : String): TDateTime;
var
  RDate : TdateTime;
	TestFormat : TDateOrder;
  Firstchar : Integer;
begin
  Result := 0;
  Firstchar := 1;
  TestFormat := doYMD;
  if LOScanDate(Olddate, TestFormat, FirstChar, RDate) then
    Result := Rdate
  else
		begin
		Firstchar := 1;
		TestFormat := TDateOrder(GetEnumValue(TypeInfo(TDateOrder),'do' + stripDatechars(FormatSettings.ShortDateFormat))) ;
  	if LOScanDate(Olddate, TestFormat, FirstChar, RDate) then
      Result := Rdate;
    end;
end;

{ -- getRootDir - Returns the root directory of the passed directory           }
{ ---------------------------------------------------------------------------- }
function TLicenceEngine.getRootDir(src : string) : string;
var
  c, c2 : integer;
begin
  if StrLComp(PChar(src), '\\', 2) = 0 then
  begin
    c := Pos('\', Copy(src, 3, length(src)));
    if c = 0 then
      raise Exception.Create('Unrecognised file name: ' + src);
    c2 := Pos('\', Copy(src, 3+c, length(src)));
    if c2 = 0 then
      result := src + '\'
    else
      result := Copy(src, 1, c+c2+2);
  end
  else
  if src[1] = '\' then
  begin
    result := '\';
  end
  else if src[2] = ':' then
  begin
    result := src[1] + src[2] + '\';
  end
  else
    raise Exception.Create('Unrecognised file name: ' + src);
end;

function TLicenceEngine.LOScanDate(const S: string; DFormat : TDateOrder; var Pos: Integer;  var Date: TDateTime): Boolean;
var
  DateOrder: TDateOrder;
  N1, N2, N3, Y, M, D: Word;
  L1, L2, L3, YearLen: Byte;
  CenturyBase: Integer;
  EraName : string;
  EraYearOffset: Integer;

  function EraToYear(Year: Integer): Integer;
  begin
{$IFDEF MSWINDOWS}
    if SysLocale.PriLangID = LANG_KOREAN then
    begin
      if Year <= 99 then
        Inc(Year, (CurrentYear + Abs(EraYearOffset)) div 100 * 100);
      if EraYearOffset > 0 then
        EraYearOffset := -EraYearOffset;
    end
    else
      Dec(EraYearOffset);
{$ENDIF}
    Result := Year + EraYearOffset;
  end;

begin
  Y := 0;
  M := 0;
  D := 0;
  YearLen := 0;
  Result := False;
  DateOrder := DFormat;
  EraYearOffset := 0;
	if FormatSettings.ShortDateFormat[1] = 'g' then  // skip over prefix text
  begin
    ScanToNumber(S, Pos);
    EraName := Trim(Copy(S, 1, Pos-1));
    EraYearOffset := GetEraYearOffset(EraName);
  end
  else
		if AnsiPos('e', FormatSettings.ShortDateFormat) > 0 then
      EraYearOffset := EraYearOffsets[1];
	if not (ScanNumber(S, Pos, N1, L1) and ScanChar(S, Pos, FormatSettings.DateSeparator) and
    ScanNumber(S, Pos, N2, L2)) then Exit;
	if ScanChar(S, Pos, FormatSettings.DateSeparator) then
  begin
    if not ScanNumber(S, Pos, N3, L3) then Exit;
    case DateOrder of
      doMDY: begin Y := N3; YearLen := L3; M := N1; D := N2; end;
      doDMY: begin Y := N3; YearLen := L3; M := N2; D := N1; end;
      doYMD: begin Y := N1; YearLen := L1; M := N2; D := N3; end;
    end;
    if EraYearOffset > 0 then
      Y := EraToYear(Y)
    else
    if (YearLen <= 2) then
    begin
			CenturyBase := CurrentYear - FormatSettings.TwoDigitYearCenturyWindow;
      Inc(Y, CenturyBase div 100 * 100);
			if (FormatSettings.TwoDigitYearCenturyWindow > 0) and (Y < CenturyBase) then
        Inc(Y, 100);
    end;
  end else
  begin
    Y := CurrentYear;
    if DateOrder = doDMY then
    begin
      D := N1; M := N2;
    end else
    begin
      M := N1; D := N2;
    end;
  end;
	ScanChar(S, Pos, FormatSettings.DateSeparator);
  ScanBlanks(S, Pos);
	if SysLocale.FarEast and (System.Pos('ddd', FormatSettings.ShortDateFormat) <> 0) then
  begin     // ignore trailing text
		if CharinSet(FormatSettings.ShortTimeFormat[1], ['0'..'9']) then  // stop at time digit
      ScanToNumber(S, Pos)
    else  // stop at time prefix
      repeat
        while (Pos <= Length(S)) and (S[Pos] <> ' ') do Inc(Pos);
        ScanBlanks(S, Pos);
      until (Pos > Length(S)) or
				(AnsiCompareText(FormatSettings.TimeAMString, Copy(S, Pos, Length(FormatSettings.TimeAMString))) = 0) or
        (AnsiCompareText(FormatSettings.TimePMString, Copy(S, Pos, Length(FormatSettings.TimePMString))) = 0);
  end;
  Result := TryEncodeDate(Y, M, D, Date);
end;

procedure TLicenceEngine.ScanBlanks(const S: string; var Pos: Integer);
var
  I: Integer;
begin
  I := Pos;
  while (I <= Length(S)) and (S[I] = ' ') do Inc(I);
  Pos := I;
end;

function TLicenceEngine.ScanNumber(const S: string; var Pos: Integer; var Number: Word; var CharCount: Byte): Boolean;
var
  I: Integer;
  N: Word;
begin
  Result := False;
  CharCount := 0;
  ScanBlanks(S, Pos);
  I := Pos;
  N := 0;
	while (I <= Length(S)) and CharInSet(S[I], ['0'..'9']) and (N < 1000) do
  begin
    N := N * 10 + (Ord(S[I]) - Ord('0'));
    Inc(I);
  end;
  if I > Pos then
  begin
    CharCount := I - Pos;
    Pos := I;
    Number := N;
    Result := True;
  end;
end;

{
function TLicenceEngine.ScanString(const S: string; var Pos: Integer; const Symbol: string): Boolean;
begin
  Result := False;
  if Symbol <> '' then
  begin
    ScanBlanks(S, Pos);
    if AnsiCompareText(Symbol, Copy(S, Pos, Length(Symbol))) = 0 then
    begin
      Inc(Pos, Length(Symbol));
      Result := True;
    end;
  end;
end;
}
function TLicenceEngine.ScanChar(const S: string; var Pos: Integer; Ch: Char): Boolean;
begin
  Result := False;
  ScanBlanks(S, Pos);
  if (Pos <= Length(S)) and (S[Pos] = Ch) then
  begin
    Inc(Pos);
    Result := True;
  end;
end;

procedure TLicenceEngine.ScanToNumber(const S: string; var Pos: Integer);
begin
	while (Pos <= Length(S)) and not CharInSet(S[Pos], ['0'..'9']) do
	begin
		if CharInSet(S[Pos], LeadBytes) then
      Pos := NextCharIndex(S, Pos)
    else
      Inc(Pos);
	end;
end;

function TLicenceEngine.GetEraYearOffset(const Name: string): Integer;
var
  I: Integer;
begin
  Result := 0;
  for I := Low(EraNames) to High(EraNames) do
  begin
    if EraNames[I] = '' then Break;
    if AnsiStrPos(PChar(EraNames[I]), PChar(Name)) <> nil then
    begin
      Result := EraYearOffsets[I];
      Exit;
    end;
  end;
end;

function TLicenceEngine.GetTrialExpiry: TDateTime;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  Result := 0;
  try
    Reg.RootKey := HKEY_CLASSES_ROOT;
    if Reg.OpenKey(SYSTEMNAME + '.' + CONFIGURATIONNAME + '.' + ADMINISTRATIONNAME, False)then
    begin
      if reg.ValueExists(TRIALKEY) then
        Result := Reg.ReadDateTime(TRIALKEY);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

function TLicenceEngine.TestTrialDate: Boolean;
begin
  Result := False;
  if GetTrialExpiry = 0 then
    Result := True;
end;

procedure TLicenceEngine.SetTrialExpiryDate(ExDate : TDateTime);
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CLASSES_ROOT;
    if Reg.OpenKey(SYSTEMNAME + '.' + CONFIGURATIONNAME + '.' + ADMINISTRATIONNAME, True)then
    begin
      Reg.WriteDateTime('Password', ExDate);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

function TLicenceEngine.ValidSerialNumber(SerNumber: String): Boolean;
var
  I, NNA, NB : Integer;
  temps : array[0..20] of Char;
  Entered : Boolean;
begin
//Validation of Serial Number
  Result := True;
  strPcopy(temps, Sernumber);
  NNA := 0;
  Entered := False;
  for I := 0 to strlen(temps) - 1 do    // Iterate
  begin
    if (temps[i] <> '-') and (temps[I] <> ' ') then
    begin
      for NB := 0 to 32 do    // Iterate
      begin
        if temps[I] = basechars[NB] then break;
      end;    // for
      Entered := true;
      if NB = 33 then
      begin
        messageDlg('Invalid character has been entered.' + #13#10 + 'Valid characters are [0-9] or [A-Z] excluding ''I'',''O'',''S''.', MtWarning, [MbOK], 0);
        Exit;
      end;

      NNA := NNA + NB;
    end;
  end;
  if ((NNA mod 33) <> 0) or ((Entered = True) and (NNA = 0)) then
  begin
    Result := False;
    messagedlg('Serial Number appears to be incorrect.', MtWarning, [MbOK], 0);
  end;
  if Entered = False then Result := False;
end;

function TLicenceEngine.BlankSerialNumber(SerNumber: string): Boolean;
var
  I, NNA : Integer;
  temps : array[0..20] of Char;
begin
//Validation of Serial Number
  Result := True;
  strPcopy(temps, Sernumber);
  NNA := 0;
  for I := 0 to strlen(temps) - 1 do    // Iterate
    begin
    if (temps[i] <> '-') and (temps[I] <> ' ') then
      NNA := 1;
    end;
  if NNA <> 0 then Result := False;
end;

function TLicenceEngine.GetCurrentFileName: String;
begin
  result := ExtractFileName(DataModuleClient.ClientDatabase.Path);
end;

function TLicenceEngine.GetCurrentBusinessName: String;
begin
	result := DataModuleClient.BusinessDetailsBUSINESS_NAME.AsString;
end;

end.
