{ RRRRRR                  ReportBuilder Class Library                  BBBBB
  RR   RR                                                              BB   BB
  RRRRRR                 Digital Metaphors Corporation                 BB BB
  RR  RR                                                               BB   BB
  RR   RR                   Copyright (c) 1996-2002                    BBBBB   }

unit ppViewr;

interface

{$I ppIfDef.pas}

uses
  Windows, SysUtils, Messages, Classes, Graphics, Controls, Forms, Dialogs, Menus, StdCtrls,
  ExtCtrls, Mask, Buttons,
  ppComm, ppTypes, ppUtils, ppDevice, ppProd, ppDrwCmd, ppPrnDev, ppPrintr,
  ppScrollbox, ppRTTI;

type

  TppViewer = class;
  TppPaintBox = class;

  {@TppScreenDevice
                                                  
    The ScreenDevice is usually used in conjunction with a TppViewer
    component.  The ScreenDevice receives the pages generated by the report
    engine and renders them onto a bitmap based on the viewable area of the
    Viewer and the ZoomSetting of the Viewer.  Once the page is rendered,
    it is copied onto a standard PaintBox control in the Viewer.  The
    Screen Device caches the current page displayed in the Viewer, re-
    rendering it when the ZoomSetting or ZoomPercentage properties are
    modified.  The ScreenDevice requests the first page of the report when
    the Publisher calls the StartJob method.  The EndJob and CancelJob
    methods are not used by the ScreenDevice.}

  TppScreenDevice = class(TppRasterDevice)
    private
      FCalculatedZoom: Integer;
      FCanvas: TCanvas;
      FPage: TppPage;
      FPageImage: TBitmap;
      FOffsetX: Integer;
      FOffsetY: Integer;
      FOnPageRendered: TNotifyEvent;
      FScaledPageHeight: Integer;
      FScaledPageWidth: Integer;
      FScaleX: Double;
      FScaleY: Double;
      FShowStatus: Boolean;
      FViewer: TppViewer;

      procedure CalculateScaledPageSize;
      procedure DoOnPageRendered;
      function GetAbsolutePageNo: Longint;
      function GetAbsolutePageCount: Longint;
      function GetPage: TppPage;
      procedure ResetPageImage;

    protected
      procedure DrawShape(aDrawShape: TppDrawShape);
      procedure DrawLine(aDrawLine: TppDrawLine);
      procedure DrawImage(aDrawImage: TppDrawImage);
      procedure DrawText(aDrawText: TppDrawText);
      procedure DirectDrawImage(aDrawImage: TppDrawImage);
      procedure AddWaterMark(aPage: TppPage);
      procedure SetStatus(const aMessage: String); override;

    public
      constructor Create(aOwner: TComponent); override;
      destructor Destroy; override;

      procedure Notify(aCommunicator: TppCommunicator; aOperation: TppOperationType); override;
      procedure EventNotify(aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList); override;

      class function DeviceName: String; override;

      procedure Cancel;
      procedure CancelJob; override;
      function  Draw(aDrawCommand: TppDrawCommand): Boolean; override;
      function  DrawUpdateable(aDrawCommand: TppDrawCommand): Boolean; override;
      procedure EndJob; override;
      procedure FirstPage;
      procedure GotoPage(aAbsolutePageNo: Longint);
      procedure LastPage;
      function  FinalPagesOnly: Boolean; override;
      function  FindClickableDrawCommand(aX, aY: Integer; var aDrawCommand: TppDrawCommand): Boolean; overload;
      function FindClickableDrawCommand(var aDrawCommand: TppDrawCommand): Boolean; overload;
      procedure ReceivePage(aPage: TppPage); override;
      procedure RenderPage;
      procedure RenderFullBlankPage;
      procedure Reset; override;
      procedure ScaleVertices(aDrawCommand: TppDrawCommand);
      procedure StartJob; override;

      property AbsolutePageNo: Longint read GetAbsolutePageNo;
      property AbsolutePageCount: Longint read GetAbsolutePageCount;
      property CalculatedZoom: Integer read FCalculatedZoom;
      property Canvas: TCanvas read FCanvas;
      property OffsetX: Integer read FOffsetX;
      property OffsetY: Integer read FOffsetY;
      property OnPageRendered: TNotifyEvent read FOnPageRendered write FOnPageRendered;
      property Page: TppPage read GetPage;
      property PageImage: TBitmap read FPageImage;
      property ScaleX: Double read FScaleX;
      property ScaleY: Double read FScaleY;
      property ShowStatus: Boolean read FShowStatus write FShowStatus default True;
      property Viewer: TppViewer read FViewer;

  end; {class, TppScreenDevice}


  {@TppViewer

    This component inherits directly from
    <EXTLINK borland://TCustomPanel_object>TCustomPanel</EXTLINK>
    and provides a surface for displaying a preview of your report. You can use
    a viewer to create a custom print preview form. To do this, drop a TppViewer
    component on a form and assign the Report property to a TppReport component.
    Call the PrintToDevices method at run-time, and the report will be displayed
    in your viewer.

    You can register your own Print Preview form. To see an example of how to do
    so, review the source of the TppPrintPreview class in the ppPrvDlg unit.}
    
  {@TppViewer.OnPageChange

    This event fires each time the TppViewer Page property changes.}

  {@TppViewer.OnPrintStateChange

    This event fires whenever the StartJob, EndJob or CancelJob methods of the
    ScreenDevice embedded in the viewer are called.}

  {@TppViewer.OnStatusChange

    This event fires each time the Status property changes.}

  {@TppViewer.Report

    The report property indicates the TppReport component to which the viewer
    has been assigned.  If the viewer is not assigned to any report, this
    property is nil.}

  {@TppViewer.Status

    Run-time and read-only.  The status property contains a string summarizing
    the current status of the report, such as 'Preview Page 1 of 15.'  The
    built-in Print Preview Form uses the status property to display feedback to
    the user on the status bar.}

  {@TppViewer.ZoomPercentage

    Value between 25 and 250 which indicates the scaling percentage to be used
    when drawing the report page on the viewer panel. This value is only
    applicable when the ZoomSetting is set to zsPercentage.}

  {@TppViewer.ZoomSetting

    Indicates how pages will be displayed in the viewer.

    <Table>
    Value               Meaning
    ---------------------------
    zsWholePage         Entire page is scaled to fit into the viewing area
    zsPageWidth         PageWidth is fitted to width of viewing area, vertical
                        scrollbar is provided to view page height
    zs100Percent        Page is shown at full size, both vertical and horizontal
                        scrollbars are provided as necessary
    zsPercentage        Page is show based on the value of the ZoomPercentage
                        property.
    </Table>}

  TppViewer = class(TCustomPanel)
  private
    FCurrentZoomSetting: TppZoomSettingType;
    FDesignViewer: Boolean;
    FIncrementalPainting: Boolean;
    FNeedToUpdateScrollBars: Boolean;
    FOnReset: TNotifyEvent;
    FPaintBox: TppPaintBox;
    FPageColor: TColor;
    FProducer: TppProducer;
    FSaveCursor: TCursor;
    FScreenDevice: TppScreenDevice;
    FScrollBox: TppScrollBox;
    FSettingCursor: Boolean;
    FZoomPercentage: Integer;
    FZoomSetting: TppZoomSettingType;
    FEnabled: Boolean;
    FResizeCount: Integer;
    FSaveDevice: String;
    FSavePrinterSetup: TppPrinterSetup;
    FSaveShowAutoSearchDialog: Boolean;
    FWalkieTalkie: TppCommunicator;

    {events}
    FOnStatusChange: TNotifyEvent;
    FOnPageChange: TNotifyEvent;
    FOnPrintStateChange: TNotifyEvent;
    FInitialized: Boolean;

    function  GetAbsolutePageNo: Longint;
    function  GetBusy: Boolean;
    function  GetCalculatedZoom: Integer;
    function  GetStatus: String;
    procedure PaintBoxMouseDownEvent(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure PaintBoxMouseMoveEvent(Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure PaintBoxClickEvent(Sender: TObject);
    procedure PaintBoxPaintEvent(Sender: TObject);
    procedure ResetCursor;
    procedure UpdatePageSize;

    procedure StartJobEvent(Sender: TObject);
    procedure CancelJobEvent(Sender: TObject);
    procedure EndJobEvent(Sender: TObject);
    function GetCurrentPage: TppPage;
    procedure WalkieTalkieEventNotifyEvent(Sender: TObject;aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList);
    function GetResizing: Boolean;
    procedure SetResizing(aResizing: Boolean);

  protected
    {property handling routines}
    function  OkayToPaint: Boolean;
    procedure SetProducer(aProducer: TppProducer);
    procedure SetZoomPercentage(Value: Integer);
    procedure SetZoomSetting(Value: TppZoomSettingType);
    procedure SetPageColor(aColor: TColor);
    procedure Resize; override;
    procedure WndProc(var Message: TMessage); override;
    procedure UpdateScrollBars;
    property Resizing: Boolean read GetResizing write SetResizing;

  public
    constructor Create(aOwner: TComponent); override;
    destructor Destroy; override;

    procedure Loaded; override;

    function IsResizing: Boolean;

    procedure Initialize;
    procedure Cancel;

    {triggers}
    procedure DoOnPageChange;
    procedure DoOnStatusChange;
    procedure DoOnReset;
    procedure DoOnPrintStateChange;

    procedure DisplayAutoSearchDialog;
    procedure FirstPage;
    function  GetDevice: TppDevice;
    procedure GotoPage(aAbsolutePageNo: Longint);
    procedure LastPage;
    procedure NextPage;
    procedure Print;
    procedure PriorPage;
    procedure RefreshPage;
    procedure RegenerateReport;
    procedure Reset;
    procedure Scroll(aDirection: TppDirectionType);

    property AbsolutePageNo: Longint read GetAbsolutePageNo;
    property Busy: Boolean read GetBusy;
    property CalculatedZoom: Integer read GetCalculatedZoom;
    property DesignViewer: Boolean read FDesignViewer write FDesignViewer;
    property IncrementalPainting: Boolean read FIncrementalPainting write FIncrementalPainting;
    property OnReset: TNotifyEvent read FOnReset  write FOnReset;
    property PaintBox: TppPaintBox read FPaintBox;
    property ScrollBox: TppScrollbox read FScrollBox;
    property ScreenDevice: TppScreenDevice read FScreenDevice;
    property Status: String read GetStatus;
    property CurrentPage: TppPage read GetCurrentPage;
    property WalkieTalkie: TppCommunicator read FWalkieTalkie;

  published
    property Align;
    property Alignment;
    property Anchors;
    property BevelInner;
    property BevelOuter;
    property BevelWidth;
    property BorderWidth;
    property BorderStyle;
    property Ctl3D;
    property PageColor: TColor read FPageColor write SetPageColor;
    property ParentCtl3D;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property Report: TppProducer read FProducer write SetProducer;
    property Visible;
    property ZoomPercentage: Integer read FZoomPercentage write SetZoomPercentage;
    property ZoomSetting: TppZoomSettingType read FZoomSetting write SetZoomSetting;

    property OnClick;
    property OnDblClick;
    property OnDragDrop;
    property OnDragOver;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property OnPageChange: TNotifyEvent read FOnPageChange  write FOnPageChange;
    property OnPrintStateChange: TNotifyEvent read FOnPrintStateChange write FOnPrintStateChange;
    property OnResize;
    property OnStatusChange: TNotifyEvent read FOnStatusChange  write FOnStatusChange;
  end; {class, TppViewer}


  TppPaintBox = class(TPaintBox)
    private
      FScreenDevice: TppScreenDevice;

    protected

    public
      property ScreenDevice: TppScreenDevice read FScreenDevice write FScreenDevice;
      
  end;


implementation

uses
  ppPlainText;

{******************************************************************************
 *
 ** V I E W E R
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppViewer.Create }

constructor TppViewer.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);

  FInitialized := False;

  {set style for viewer controls}
  Font.Name  := 'MS Sans Serif';
  Font.Size  := 8;
  Font.Style := [];
  Font.Color := clBtnShadow;

  Color   := clBtnShadow;

  Height := 120;
  Width  := 320;

  FCurrentZoomSetting     := zsWholePage;
  FDesignViewer           := False;
  FEnabled                := False;
  FIncrementalPainting    := False;
  FNeedToUpdateScrollBars := True;
  FOnPageChange           := nil;
  FOnStatusChange         := nil;
  FScrollBox              := nil;
  FSettingCursor          := False;
  FPageColor              := clWindow;
  FPaintBox               := nil;
  FZoomSetting            := zsWholePage;
  FZoomPercentage         := 100;

  FScreenDevice            := TppScreenDevice.Create(Self);
  FScreenDevice.OnStartJob  := StartJobEvent;
  FScreenDevice.OnEndJob    := EndJobEvent;
  FScreenDevice.OnCancelJob := CancelJobEvent;

  FWalkieTalkie := TppCommunicator.Create(nil);
  FWalkieTalkie.EventNotifies := [ciProducerAfterPrintToPrinter];
  FWalkieTalkie.OnEventNotify := WalkieTalkieEventNotifyEvent;

end; {constructor, TppViewer}

{------------------------------------------------------------------------------}
{ TppViewer.Destroy }

destructor TppViewer.Destroy;
begin

  FWalkieTalkie.Free;

  {free screen device}
  FScreenDevice.Free;

  {free paintbox}
  FPaintBox.Free;

  {free parent scrollbox last}
  FScrollBox.Free;

  inherited Destroy;

end; {destructor, TppViewer}

{------------------------------------------------------------------------------}
{ TppViewer.SetProducer }

procedure TppViewer.SetProducer(aProducer: TppProducer);
begin
  FProducer := aProducer;

  if (FProducer <> nil) then
    begin
      FScreenDevice.Publisher := FProducer.Publisher;
      FProducer.AddEventNotify(FScreenDevice);
    end
  else
    begin
      FScreenDevice.Publisher := nil;
    end;

  UpdatePageSize;

end; {procedure, SetProducer}

{------------------------------------------------------------------------------}
{ TppViewer.Reset}

procedure TppViewer.Reset;
begin
  UpdatePageSize;
  FScreenDevice.Reset;

  DoOnReset;
end;

{------------------------------------------------------------------------------}
{ TppViewer.UpdatePageSize}

procedure TppViewer.UpdatePageSize;
begin

  if FProducer <> nil then
    begin
      FScreenDevice.Page.PageDef.mmHeight := FProducer.PrinterSetup.PageDef.mmHeight;
      FScreenDevice.Page.PageDef.mmWidth := FProducer.PrinterSetup.PageDef.mmWidth;
    end;
end; {procedure, UpdatePageSize}

{------------------------------------------------------------------------------}
{ TppViewer.Cancel }

procedure TppViewer.Cancel;
begin
  FScreenDevice.Cancel;
end; {procedure, Cancel}

{@TppViewer.DisplayAutoSearchDialog
 Calls the DisplayAutoSearchDialog method of the report.  This method is called
 when the search icon is clicked.}

procedure TppViewer.DisplayAutoSearchDialog;
begin
  if ScreenDevice.Busy then Exit;

  if (FProducer.DisplayAutoSearchDialog) then
    RegenerateReport;

end; {procedure, DisplayAutoSearchDialog}

{@TppViewer.RegenerateReport
 Call this method to regenerate the report pages. Resets the screen device
 and the publisher, and then makes a page request.}

procedure TppViewer.RegenerateReport;
begin

  if ScreenDevice.Busy then Exit;

  FEnabled := False;
  try
    FScreenDevice.Publisher.Reset;
    Reset;
  finally
    FEnabled := True;
  end;

    if Assigned(FOnReset) then FOnReset(Self);

    FScreenDevice.MakePageRequest;


end; {procedure, RegenerateReport}


{@TppViewer.Print
 Call the Print method to display the Print Dialog and print the currently
 previewed report to the printer.}

procedure TppViewer.Print;
begin

  if FScreenDevice.Busy then Exit;

  if (FProducer <> nil) then
    begin

      {detach screen device}
      FScreenDevice.Publisher := nil;

      {set current page}
      if FScreenDevice.AbsolutePageNo = 0 then
        FProducer.CurrentPage := 1
      else
        FProducer.CurrentPage := FScreenDevice.AbsolutePageNo;

      {print the report}
      FSaveDevice := FProducer.DeviceType;
      FSavePrinterSetup := TppPrinterSetup.Create(nil);
      FSavePrinterSetup.Assign(FProducer.PrinterSetup);

      FSaveShowAutoSearchDialog := FProducer.ShowAutoSearchDialog;

      FProducer.AddEventNotify(FWalkieTalkie);

      FProducer.ShowAutoSearchDialog := False;
      FProducer.DeviceType := TppPrinterDevice.DeviceName;
      FProducer.Print;

    end;

end; {procedure, Print}

{------------------------------------------------------------------------------}
{ TppViewer.WalkieTalkieEventNotifyEvent }

procedure TppViewer.WalkieTalkieEventNotifyEvent(Sender: TObject; aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList);
begin

  if (aEventID = ciProducerAfterPrintToPrinter) and (aCommunicator = FProducer) then
    begin
      FProducer.DeviceType := FSaveDevice;
      FProducer.ShowAutoSearchDialog := FSaveShowAutoSearchDialog;

      {re-attach screen device}
      FScreenDevice.Publisher := Report.Publisher;

      {the printer settings have been changed, thus we must regen to
      the viewer}
      if (FSavePrinterSetup <> nil) and not(FSavePrinterSetup.IsEqual(FProducer.PrinterSetup)) then
        FScreenDevice.MakePageRequest;

      FSavePrinterSetup.Free;
      FSavePrinterSetup := nil;
    end;

end;


{------------------------------------------------------------------------------}
{ TppViewer.GetAbsolutePageNo }

function TppViewer.GetAbsolutePageNo: Longint;
begin
  Result := FScreenDevice.AbsolutePageNo;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetDevice }

function  TppViewer.GetDevice: TppDevice;
begin
  Result := FScreenDevice;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetCalculatedZoom }

function  TppViewer.GetCalculatedZoom: Integer;
begin
  Result := FScreenDevice.CalculatedZoom;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetStatus }

function TppViewer.GetStatus: String;
begin
  Result := FScreenDevice.Status;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetBusy }

function TppViewer.GetBusy: Boolean;
begin
  Result := FScreenDevice.Busy;
end;

{------------------------------------------------------------------------------}
{ TppViewer.WndProc }

procedure TppViewer.WndProc(var Message: TMessage);
begin

 if Message.Msg = CM_CURSORCHANGED then
    begin
      if (FPaintBox <> nil) then
        FPaintBox.Cursor := Cursor;

      if not(FSettingCursor) then
        FSaveCursor := Cursor;
    end;

 inherited WndProc(Message);

end;

{------------------------------------------------------------------------------}
{ TppViewer.Initialize }

procedure TppViewer.Initialize;
begin

  if FInitialized then Exit;

  if (csReading in ComponentState) or (csLoading in ComponentState) then Exit;

  FInitialized := True;

  {create paint boxes}
  FScrollBox  := TppScrollBox.Create(Self);
  FPaintBox   := TppPaintBox.Create(Self);
  FPaintBox.ScreenDevice := FScreenDevice;

  {set parent relationships}
  FScrollBox.Parent := Self;
  FScrollBox.VertScrollbar.Tracking := True;
  FScrollBox.HorzScrollbar.Tracking := True;

  FPaintBox.Parent  := FScrollBox;
  FPaintBox.Visible := False;

  {remove page flicker}
  FScrollBox.DoubleBuffered := True;

  {configure zoom & page paintboxes}
  FScrollBox.Visible := False;
  FScrollBox.Align   := alClient;

  FPaintBox.Align  := alClient;
  FPaintBox.Color  := clBtnShadow;

  {assign paint routine to paint boxes}
  FPaintBox.Cursor      := Cursor;
  FPaintBox.OnClick     := PaintBoxClickEvent;
  FPaintBox.OnMouseDown := PaintBoxMouseDownEvent;
  FPaintBox.OnMouseMove := PaintBoxMouseMoveEvent;
  FPaintBox.OnPaint     := PaintBoxPaintEvent;
  FPaintBox.OnDblClick  := OnDblClick;
  FPaintBox.OnDragDrop  := OnDragDrop;
  FPaintBox.OnDragOver  := OnDragOver;
  FPaintBox.OnMouseUp   := OnMouseUp;

  FSaveCursor := Cursor;

  {hide paintbox at design-time}
  if (csDesigning in ComponentState) then
    FPaintBox.Visible := False;

  Invalidate;

end; {procedure, Initialize}

{------------------------------------------------------------------------------}
{ TppViewer.Loaded }

procedure TppViewer.Loaded;
begin

  inherited Loaded;

  Initialize;

end; {procedure, Loaded}


{------------------------------------------------------------------------------}
{ TppViewer.OkayToPaint }

function TppViewer.OkayToPaint: Boolean;
begin

  if not FEnabled then
    Result := False

  else if (csDesigning in ComponentState) or FIncrementalPainting then
    Result := False

  else
    Result := True;

  if not FInitialized then
    Initialize;

end; {procedure, OkayToPaint}

{------------------------------------------------------------------------------}
{ TppViewer.RefreshPage }

procedure TppViewer.RefreshPage;
begin
  PaintBoxPaintEvent(Self);
end; {procedure, RefreshViewer}

{------------------------------------------------------------------------------}
{ TppViewer.DoOnPageChange }

procedure TppViewer.DoOnPageChange;
begin
  if Assigned(FOnPageChange) then FOnPageChange(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerPageChange, nil);
end; {procedure, DoOnPageChange}

{------------------------------------------------------------------------------}
{ TppViewer.DoOnStatusChange }

procedure TppViewer.DoOnStatusChange;
begin
  if Assigned(FOnStatusChange) then FOnStatusChange(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerStatusChange, nil);
end; {procedure, DoOnStatusChange}
          
{------------------------------------------------------------------------------}
{ TppViewer.DoOnPrintStateChange }

procedure TppViewer.DoOnPrintStateChange;
begin
  RefreshPage;

  if Assigned(FOnPrintStateChange) then FOnPrintStateChange(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerPrintStateChange, nil);
end; {procedure, StartJobEvent}

{------------------------------------------------------------------------------}
{ TppViewer.DoOnReset}

procedure TppViewer.DoOnReset;
begin
  if Assigned(FOnReset) then FOnReset(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerReset, nil);
end; {procedure, Reset}

{------------------------------------------------------------------------------}
{ TppViewer.Resize }

procedure TppViewer.Resize;
begin

  inherited Resize;

  {if you remove this, the Design-Time Viewer will GPF}
  if (csDestroying in ComponentState) then Exit;

  {check reading only here, not loading}
  if (csReading in ComponentState) then Exit;

  if not(OkayToPaint) then Exit;

  Resizing := True;

  FScreenDevice.RenderPage;

  UpdateScrollBars;

  {indicate to preview form that page has changed}
  if  not (csLoading in ComponentState) then
    DoOnPageChange;

  PaintBoxPaintEvent(Self);

  Resizing := False;

end; {procedure, Resize}

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxPaintEvent }

procedure TppViewer.PaintBoxPaintEvent(Sender: TObject);
var
  lCanvas: TCanvas;

begin

  if not(OkayToPaint) then Exit;

  lCanvas := FPaintBox.Canvas;

  lCanvas.CopyRect(lCanvas.ClipRect, FScreenDevice.PageImage.Canvas, lCanvas.ClipRect);

end; {procedure, PaintBoxPaintEvent}

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxClickEvent }

procedure TppViewer.PaintBoxClickEvent(Sender: TObject);
var
  lPoint: TPoint;
  lDrawCommand: TppDrawCommand;
begin
  GetCursorPos(lPoint);

  lPoint := FPaintBox.ScreenToClient(lPoint);
  lDrawCommand := nil;
  
  if FScreenDevice.FindClickableDrawCommand(lPoint.X, lPoint.Y, lDrawCommand) then
    begin
      lDrawCommand.DoOnClick;

      if lDrawCommand.RedrawPage then
        begin
          lDrawCommand.RedrawPage := False;

          {tell publisher we just want a single page}
          FScreenDevice.PageRequest.PageSetting := psSinglePage;
          FScreenDevice.PageRequest.PageRequested := AbsolutePageNo;

          FScreenDevice.MakePageRequest;

          {reset cursor}
          ResetCursor;
        end;
    end;

  {trigger panels onclick event}
  Click;

end; {procedure, PaintBoxClickEvent}

{------------------------------------------------------------------------------}
{ TppViewer.ResetCursor }

procedure TppViewer.ResetCursor;
var
  lPoint: TPoint;
begin

  GetCursorPos(lPoint);

  SetCursorPos(lPoint.X - 1, lPoint.Y - 1);
  Application.ProcessMessages;

  SetCursorPos(lPoint.X, lPoint.Y);
  Application.ProcessMessages;

end; {procedure, ResetCursor}

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxMouseDownEvent }

procedure TppViewer.PaintBoxMouseDownEvent(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerMouseDown, nil);

  {trigger panels mouse down event}
  MouseDown(Button, Shift, X, Y);
end;

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxMouseMoveEvent }

procedure TppViewer.PaintBoxMouseMoveEvent(Sender: TObject; Shift: TShiftState; X,Y: Integer);
var
  lPoint: TPoint;
  lDrawCommand: TppDrawCommand;
  lbFound: Boolean;
begin
  GetCursorPos(lPoint);

  lPoint := ScreenToClient(lPoint);

  FSettingCursor := True;

  lbFound := FScreenDevice.FindClickableDrawCommand(X, Y, lDrawCommand);

  {force cursor to change}
  Cursor := FSaveCursor;

  if lbFound then
    Cursor := crHandPoint;

  FSettingCursor := False;

  {trigger panels mouse move event}
  MouseMove(Shift, X, Y);

end; {procedure, PaintBoxMouseMoveEvent}

{------------------------------------------------------------------------------}
{ TppViewer.SetPageColor }

procedure TppViewer.SetPageColor(aColor: TColor);
begin

  FPageColor := aColor;

  Invalidate;

end; {procedure, SetZoomPercentage}

{------------------------------------------------------------------------------}
{ TppViewer.SetZoomSetting }

procedure TppViewer.SetZoomSetting(Value: TppZoomSettingType);
begin

  FZoomSetting := Value;

  {check reading only here, not loading}
  if (csReading in ComponentState) then Exit;

  if not(OkayToPaint) then Exit;

  if not Visible then
    begin
      Invalidate;
      Exit;
    end;

  {paint uses this var to get back in sync}
  FCurrentZoomSetting := Value;

  {set zoom}
  FPaintBox.Visible := False;

  FScreenDevice.RenderPage;

  FNeedToUpdateScrollBars := True;

  UpdateScrollBars;

  PaintBoxPaintEvent(Self);

  FPaintBox.Visible := True;

end; {procedure, SetZoomSetting}

{------------------------------------------------------------------------------}
{ TppViewer.SetZoomPercentage }

procedure TppViewer.SetZoomPercentage(Value: Integer);
begin

  if (Value < 25) then
    FZoomPercentage := 25

  else if (Value > 250) then
    FZoomPercentage := 250
    
  else
    FZoomPercentage := Value;

  SetZoomSetting(zsPercentage);

end; {procedure, SetZoomPercentage}

{------------------------------------------------------------------------------}
{ TppViewer.UpdateScrollBars }

procedure TppViewer.UpdateScrollBars;
begin
  if (csReading in ComponentState) or (csLoading in ComponentState) then Exit;

  if not OkayToPaint then Exit;

  {set horizontal scroll bar}
  if FScreenDevice.PageImage.Width > FScrollBox.Width then
    begin
      FScrollBox.HorzScrollBar.Range := FScreenDevice.PageImage.Width;
      FScrollBox.HorzScrollBar.Visible := True;
    end
  else
   begin
      FScrollBox.HorzScrollBar.Range := ClientWidth;
      FScrollBox.HorzScrollBar.Visible := False;
   end;

  {set vertical scroll bar}
  if FScreenDevice.PageImage.Height > FScrollBox.Height then
    begin
      FScrollBox.VertScrollBar.Range := FScreenDevice.PageImage.Height;
      FScrollBox.VertScrollBar.Visible := True;
    end
  else
   begin
      FScrollBox.VertScrollBar.Range := ClientHeight;
      FScrollBox.VertScrollBar.Visible := False;
   end;

  {reposition thumbs}
  if FNeedToUpdateScrollBars then
    begin
      FScrollBox.HorzScrollBar.Position := 0;
      FScrollBox.VertScrollBar.Position := 0;

      FNeedToUpdateScrollBars := False;
    end;

end; {procedure, UpdateScrollBars}


{@TppViewer.GotoPage
 Call the GotoPage function to request a single page of the report.

 If GotoPage cannot successfully generate the requested page, it returns False.}

procedure TppViewer.GotoPage(aAbsolutePageNo: Longint);
begin
  FScreenDevice.GotoPage(aAbsolutePageNo);
end; {function, GotoPage}


{@TppViewer.NextPage
 Call the NextPage method to send the next page of the report to the current
 Device.  This is usually called when a user is previewing.}

procedure TppViewer.NextPage;
begin

  if (FScreenDevice.FPage.LastPage) then Exit;

  FScreenDevice.GotoPage(FScreenDevice.AbsolutePageNo + 1);

end; {procedure, NextPage}


{@TppViewer.PriorPage
 Call the PriorPage method to send the prior page of the report to the current
 device.  This is usually called when a user is previewing.}

procedure TppViewer.PriorPage;
begin

  if (FScreenDevice.FPage.AbsolutePageNo = 1) then Exit;

  FScreenDevice.GotoPage(FScreenDevice.AbsolutePageNo - 1);

end; {procedure, PriorPage}


{@TppViewer.FirstPage
 Call the FirstPage method to request the first page of the report.}
procedure TppViewer.FirstPage;
begin
  FScreenDevice.FirstPage;
end; {procedure, FirstPage}


{@TppViewer.LastPage
 Call the LastPage method to request the last page of the report.}

procedure TppViewer.LastPage;
begin
  FScreenDevice.LastPage;
end; {procedure, LastPage}

{------------------------------------------------------------------------------}
{ TppViewer.Scroll }

procedure TppViewer.Scroll(aDirection: TppDirectionType);
var
  lScrollBar: TControlScrollBar;
begin

  case aDirection of

    dtUp:
      begin
        lScrollBar := FScrollBox.VertScrollBar;
        lScrollBar.Position := lScrollBar.Position - FScrollBox.Height;
      end;
    dtDown:
      begin
        lScrollBar := FScrollBox.VertScrollBar;
        lScrollBar.Position := lScrollBar.Position + FScrollBox.Height;
      end;
    dtLeft:
      begin
        lScrollBar := FScrollBox.HorzScrollBar;
        lScrollBar.Position := lScrollBar.Position - FScrollBox.Width;
      end;
    dtRight:
      begin
        lScrollBar := FScrollBox.HorzScrollBar;
        lScrollBar.Position := lScrollBar.Position + FScrollBox.Width;
      end;

  end;

end; {procedure, Scroll}

{------------------------------------------------------------------------------}
{ TppViewer.StartJobEvent }

procedure TppViewer.StartJobEvent(Sender: TObject);
begin
  FEnabled := True;

  DoOnPrintStateChange;
end;

{------------------------------------------------------------------------------}
{ TppViewer.EndJobEvent }

procedure TppViewer.EndJobEvent(Sender: TObject);
begin
  DoOnPrintStateChange;
end; {procedure, EndJobEvent}

{------------------------------------------------------------------------------}
{ TppViewer.CancelJobEvent }

procedure TppViewer.CancelJobEvent(Sender: TObject);
begin
  DoOnPrintStateChange;
end; {procedure, CancelJobEvent}

{------------------------------------------------------------------------------}
{ TppViewer.GetCurrentPage }

function TppViewer.GetCurrentPage: TppPage;
begin
  Result := FScreenDevice.Page;
end; {function, GetCurrentPage}
 
{------------------------------------------------------------------------------}
{ TppViewer.IsResizing }

function TppViewer.IsResizing: Boolean;
begin
  Result := Resizing;
end; {function, IsResizing}

{------------------------------------------------------------------------------}
{ TppViewer.GetResizing }

function TppViewer.GetResizing: Boolean;
begin
  Result := (FResizeCount > 0);
end;  {function, GetResizing}

{------------------------------------------------------------------------------}
{ TppViewer.SetResizing }

procedure TppViewer.SetResizing(aResizing: Boolean);
begin

  if aResizing then
    Inc(FResizeCount)
  else
    Dec(FResizeCount);

  if (FResizeCount < 0) then
    FResizeCount := 0;

end;  {procedure, SetResizing}


{******************************************************************************
 *
 ** S C R E E N   D E V I C E
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Create }

constructor TppScreenDevice.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);

  FPageImage := TBitMap.Create;
  FShowStatus := True;
  FPage := TppPage.Create(nil);

  if (aOwner is TppViewer) then
    begin
      FViewer := TppViewer(aOwner);

      FPageImage.Width  := FViewer.Width;
      FPageImage.Height := FViewer.Height;
    end

  else
    FViewer := nil;

  FOnPageRendered := nil;

  {tell publisher we just want the first page}
  PageRequest.PageSetting := psFirstPage;
  PageRequest.PageRequested := 1;

  EventNotifies := EventNotifies + [ciEngineNoData];

end; {constructor, Create}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Destroy }

destructor TppScreenDevice.Destroy;
begin

  FPageImage.Free;

  FPage.Free;

  inherited Destroy;

end; {destructor, Destroy}

{------------------------------------------------------------------------------}
{ TppScreenDevice.DoOnPageRendered }

procedure TppScreenDevice.DoOnPageRendered;
begin
  if Assigned(FOnPageRendered) then FOnPageRendered(Self);
end; {procedure, DoOnPageRendered}

{------------------------------------------------------------------------------}
{ TppScreenDevice.DeviceName }

class function TppScreenDevice.DeviceName: String;
begin
  Result := 'Screen';
end; {class function, DeviceName}

{------------------------------------------------------------------------------}
{ TppScreenDevice.EventNotify}

procedure TppScreenDevice.EventNotify(aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList);
begin
  inherited EventNotify(aCommunicator, aEventID, aParams);

  {if no data, need to explicitly render a blank page image}
  if (aEventID = ciEngineNoData) and (aCommunicator = FViewer.FProducer) then
    RenderPage;

end;  {procedure, EventNotify}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Notify}

procedure TppScreenDevice.Notify(aCommunicator: TppCommunicator; aOperation: TppOperationType);
begin

  {clear report property of viewer}
  if (aCommunicator = Publisher) and (aOperation = ppopRemove) then

    if (FViewer <> nil) then
      begin
        FViewer.FProducer := nil;
        FViewer.Reset;
      end;


  {this clears the publisher property}
  inherited Notify(aCommunicator, aOperation);

end; {procedure, Notify}

{------------------------------------------------------------------------------}
{ TppScreenDevice.StartJob }

procedure TppScreenDevice.StartJob;
begin

  inherited StartJob;

  SetStatus(ppLoadStr(2)); {'Accessing data...'}

  FPage.Clear;

end; {procedure, StartJob}

{------------------------------------------------------------------------------}
{ TppScreenDevice.CancelJob }

procedure TppScreenDevice.CancelJob;
begin

  SetStatus(FPage.PageNoDescription);

  inherited CancelJob;

end; {procedure, CancelJob}

{------------------------------------------------------------------------------}
{ TppScreenDevice.EndJob }

procedure TppScreenDevice.EndJob;
begin

  if (Publisher.ReportCompleted) then
    SetStatus(FPage.PageSetDescription)
  else
    SetStatus(FPage.PageNoDescription);

  inherited EndJob;

end; {procedure, EndJob}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Reset }

procedure TppScreenDevice.Reset;
begin

  inherited Reset;

  if (FViewer <> nil) and FViewer.Enabled then
    ResetPageImage;

  PageRequest.PageSetting := psFirstPage;
  PageRequest.PageRequested := 1;

end;  {procedure, Reset}

{------------------------------------------------------------------------------}
{ TppScreenDevice.ResetPageImage }

procedure TppScreenDevice.ResetPageImage;
begin

  FPage.FreeDrawCommands;
  FPageImage.Free;

  FPageImage := TBitmap.Create;

  if (FViewer <> nil) then
    begin
      if (FViewer.Report <> nil) then
        FPage.PrinterSetup := FViewer.Report.PrinterSetup;

      FPageImage.Width := FViewer.Width;
      FPageImage.Height := FViewer.Height;

      RenderPage;

      FViewer.RefreshPage;
    end;

end; {procedure, ResetPageImage}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Cancel }

procedure TppScreenDevice.Cancel;
begin
  if (FViewer = nil) or (FViewer.Report = nil) then Exit;

  FViewer.Report.Cancel;

end; {procedure, Cancel}

{------------------------------------------------------------------------------}
{ TppScreenDevice.GetAbsolutePageNo }

function TppScreenDevice.GetAbsolutePageNo;
begin
  Result := FPage.AbsolutePageNo;
end; {function, GetPageDef}

{------------------------------------------------------------------------------}
{ TppScreenDevice.GetAbsolutePageCount }

function TppScreenDevice.GetAbsolutePageCount;
begin
  Result := FPage.AbsolutePageCount;
end; {function, GetPageDef}

{------------------------------------------------------------------------------}
{ TppScreenDevice.GetPageDef }

function TppScreenDevice.GetPage: TppPage;
begin
  Result := FPage;
end; {function, GetPageDef}

{------------------------------------------------------------------------------}
{ TppScreenDevice.FinalPagesOnly }

function TppScreenDevice.FinalPagesOnly: Boolean;
begin
  Result := False;
end; {function, FinalPagesOnly}

{------------------------------------------------------------------------------}
{ TppScreenDevice.ReceivePage }

procedure TppScreenDevice.ReceivePage(aPage: TppPage);
var
  lsMessage: String;
begin

  inherited ReceivePage(aPage);

  if (csDesigning in ComponentState) and not(FViewer.DesignViewer) then Exit;


  if IsRequestedPage  then
    begin

      if IsMessagePage then
        begin

          if (Publisher <> nil) and Publisher.ReportCompleted then
            begin
              lsMessage := ppLoadStr(10); {'Drawing page 1 of 15 for <documentname>'}
              lsMessage := ppSetMessageParameters(lsMessage);
              lsMessage := Format(lsMessage, [IntToStr(aPage.AbsolutePageNo), IntToStr(aPage.AbsolutePageCount), aPage.DocumentName]);
            end
          else
            begin
              lsMessage := ppLoadStr(4); {'Calculating page 1 for <documentname>'}
              lsMessage := ppSetMessageParameters(lsMessage);
              lsMessage := Format(lsMessage, [IntToStr(aPage.AbsolutePageNo), aPage.DocumentName]);
            end;

          SetStatus(lsMessage);
        end

      else {if not(IsMessagePage) then}
        begin
          FPage.Assign(aPage);

          AddWaterMark(FPage);

          RenderPage;

          if (FViewer <> nil) then
            begin
              FViewer.UpdateScrollBars;

              {call inherited in order to not broadcast}
              if (Publisher <> nil) and Publisher.ReportCompleted then
                SetStatus(aPage.PageSetDescription)
              else
                SetStatus(aPage.PageNoDescription);

              FViewer.RefreshPage;

              {notify viewer of page change}
              FViewer.DoOnPageChange;

            end;
        end;

    end

  else if (aPage.Calculation) then
    begin
      lsMessage := ppLoadStr(4); {'Calculating Page 1 of 15 for <documentname>'}
      lsMessage := ppSetMessageParameters(lsMessage);
      lsMessage := Format(lsMessage, [IntToStr(aPage.AbsolutePageNo), aPage.DocumentName]);

      SetStatus(lsMessage);

      {update current page}
      if (FPage.AbsolutePageCount <> aPage.AbsolutePageCount) then
        begin
          FPage.AbsolutePageCount := aPage.AbsolutePageCount;

          if (FPage.ControlGroupBreakNo = aPage.ControlGroupBreakNo) then
            FPage.PageCount := aPage.PageCount;

          if FPage.HasUpdateables then
            begin
              FPage.Update(Self);
              {allow page canvas to painted}
              Application.ProcessMessages;
            end;
        end;
    end;


end; {procedure, ReceivePage}

{------------------------------------------------------------------------------}
{ TppScreenDevice.SetStatus }

procedure TppScreenDevice.SetStatus(const aMessage: String);
begin
  if not(FShowStatus) then Exit;

  inherited SetStatus(aMessage);

  if (FViewer <> nil) then
    FViewer.DoOnStatusChange;

  Application.ProcessMessages; {force update}

end; {procedure, SetStatus}

{------------------------------------------------------------------------------}
{ TppScreenDevice.FirstPage }

procedure TppScreenDevice.FirstPage;
begin
  if Busy then Exit;

  if Cancelled then Exit;

  if (FPage.AbsolutePageNo = 1) then Exit;

  {tell publisher we just want a single page}
  PageRequest.PageSetting := psFirstPage;

  MakePageRequest;

end; {function, FirstPage}

{------------------------------------------------------------------------------}
{ TppScreenDevice.LastPage }

procedure TppScreenDevice.LastPage;
begin

  if Busy then Exit;

  if Cancelled then Exit;

  if FPage.LastPage then Exit;

  {tell publisher we just want a single page}
  PageRequest.PageSetting := psLastPage;

  MakePageRequest;

end; {function, LastPage}

{------------------------------------------------------------------------------}
{ TppScreenDevice.GotoPage }

procedure TppScreenDevice.GotoPage(aAbsolutePageNo: Longint);
begin
  if Busy then Exit;

  if (FPage.AbsolutePageNo = aAbsolutePageNo) then Exit;

  {tell publisher we just want a single page}
  PageRequest.PageSetting := psSinglePage;
  PageRequest.PageRequested := aAbsolutePageNo;

  MakePageRequest;
end; {function, GotoPage}

{------------------------------------------------------------------------------}
{ TppScreenDevice.RenderPage }

procedure TppScreenDevice.RenderPage;
var
  lbSuccess: Boolean;
 lRect: TRect;
 lPageDef: TppPageDef;
 
begin

  lPageDef := FPage.PageDef;

  if (lPageDef.mmWidth = 0) or (lPageDef.mmHeight = 0) then Exit;

  if (FViewer <> nil) and not(FViewer.ScrollBox.Visible) then
    begin

      lbSuccess := False;

      try
        if (FViewer.Parent <> nil) then
          lbSuccess := LockWindowUpdate(FViewer.Parent.Handle);

        FViewer.ScrollBox.Visible := True;

        RenderFullBlankPage;

      finally
        if lbSuccess then
          LockWindowUpdate(0);

      end;

      FViewer.Invalidate;
    end
  else
    RenderFullBlankPage;

  {calculate scaled page boundaries}
  lRect.Left   := (FPageImage.Width - FScaledPageWidth) div 2;
  lRect.Top    := (FPageImage.Height - FScaledPageHeight) div 2;
  lRect.Right  := lRect.Left + FScaledPageWidth;
  lRect.Bottom := lRect.Top + FScaledPageHeight;

  {draw page}
  FCanvas.Brush.Style := bsSolid;

  if (FViewer = nil) then
    FCanvas.Brush.Color := clWhite
  else
    FCanvas.Brush.Color := FViewer.PageColor;

  FCanvas.Rectangle(lRect.Left, lRect.Top, lRect.Right, lRect.Bottom);

  {calculate scaling factors for drawing rest of page}
  FScaleX := FScaledPageWidth / lPageDef.spWidth;
  FScaleY := FScaledPageHeight / lPageDef.spHeight;

  {calculate offsets for each printing rect}
  FOffsetY := lRect.Top;
  FOffsetX := lRect.Left;

  SendEventNotify(Self, ciScreenDeviceBeforeDrawPage, nil);

  DrawPage(FPage);

  SendEventNotify(Self, ciScreenDeviceAfterDrawPage, nil);

  if (FViewer <> nil) and not(FViewer.PaintBox.Visible) then
    FViewer.PaintBox.Visible := True;

  DoOnPageRendered;

end;

{ TppScreenDevice.RenderFullBlankPage }

procedure TppScreenDevice.RenderFullBlankPage;
begin

  {clear bitmap of previous drawing}
  if FPageImage <> nil then
    FPageImage.Free;

  FPageImage := TBitmap.Create;

  FCanvas := FPageImage.Canvas;

  {calculate scaled page size}
  CalculateScaledPageSize;

  {draw background}
  FCanvas.Brush.Style := bsSolid;
  FCanvas.Brush.Color := clBtnShadow;
  FCanvas.FillRect(Rect(0, 0, FPageImage.Width, FPageImage.Height));

end;


{------------------------------------------------------------------------------}
{ TppScreenDevice.CalculateScaledPageSize}

procedure TppScreenDevice.CalculateScaledPageSize;
var
 ldRatio: Double;
 liDeadArea: Integer;
 lPageDef: TppPageDef;
 liQuarterInch: Integer;
 liHalfInch: Integer;
 liEighthInch: Integer;
 liScrollBarMargin: Integer;
 ldPercentage: Double;
 liZoomPercentage: Integer;
begin

  liEighthInch := Round(0.125 * Screen.PixelsPerInch);
  liQuarterInch := Round(0.25 * Screen.PixelsPerInch);
  liHalfInch := Round(0.5 * Screen.PixelsPerInch);

  lPageDef := FPage.PageDef;

  if (FViewer = nil) or (FViewer.ZoomSetting in [zs100Percent, zsPercentage]) then
    begin

      if (FViewer = nil) or (FViewer.ZoomSetting = zs100Percent) then
        liZoomPercentage := 100
      else
        liZoomPercentage := FViewer.ZoomPercentage;        

      ldPercentage := liZoomPercentage / 100;

      {compute page rectangle size}
      FScaledPageHeight := Round(lPageDef.spHeight * ldPercentage);
      FScaledPageWidth := Round(lPageDef.spWidth * ldPercentage);

      {set area around page border}
      liDeadArea := liQuarterInch;

      if (FViewer = nil) then
        begin
          {full page size}
          FPageImage.Height := lPageDef.spHeight + (liDeadArea * 2);
          FPageImage.Width  := lPageDef.spWidth + (liDeadArea * 2);
        end
      else
        begin
          {set page image height, greater of scaled page and scrollbox}
          if (FScaledPageHeight + (liDeadArea * 2)) > FViewer.ScrollBox.Height then
            FPageImage.Height := FScaledPageHeight + (liDeadArea * 2)
          else
            FPageImage.Height := FViewer.ScrollBox.Height;

          {set page image width, greater of scaled page and scrollbox}
          if (FScaledPageWidth + (liDeadArea * 2)) > FViewer.ScrollBox.Width then
            FPageImage.Width  := FScaledPageWidth + (liDeadArea * 2)
          else
            FPageImage.Width := FViewer.ScrollBox.Width
        end;

    end

  else if (FViewer.ZoomSetting = zsWholePage) then
    begin
      {get size of viewable area}
      FPageImage.Height := FViewer.ScrollBox.Height;
      FPageImage.Width  := FViewer.ScrollBox.Width;

      {compute page rectangle size}
      ldRatio := lPageDef.spWidth / lPageDef.spHeight;

      FScaledPageHeight := FViewer.ScrollBox.Height - liQuarterInch;
      FScaledPageWidth := Round(ldRatio * FScaledPageHeight);

      {reduce width & height until entire page fits in viewable area}
      if (FPageImage.Width > liHalfInch) and (FPageImage.Height > liHalfInch) then
        while (FScaledPageWidth >= FPageImage.Width) do
          begin
            FScaledPageHeight := FScaledPageHeight - liQuarterInch;
            FScaledPageWidth := Round(ldRatio * FScaledPageHeight);
          end;

    end {if, ZoomSetting = zsWholePage}

  else if (FViewer.ZoomSetting = zsPageWidth) then
    begin
      {compute page rectangle size}
      ldRatio := lPageDef.spWidth / lPageDef.spHeight;

      liDeadArea := liEighthInch;
      liScrollBarMargin := Round(Screen.PixelsPerInch * 0.1458);

      {calculate height as less than viewable area}
      FScaledPageWidth := FViewer.ScrollBox.Width - (liDeadArea * 2) - liScrollBarMargin;
      FScaledPageHeight := Round(FScaledPageWidth / ldRatio);

      {this may or may not force a scroll bar}
      FPageImage.Height := FScaledPageHeight + (liDeadArea * 2);
      FPageImage.Width  := FScaledPageWidth + (liDeadArea * 2);

      {if height ends up less than viewing area, extend height}
      if FPageImage.Height < FViewer.ScrollBox.Height then
        FPageImage.Height := FViewer.ScrollBox.Height;

    end; {if, ZoomSetting = zsPageWidth}

    FCalculatedZoom := Round((FScaledPageHeight / lPageDef.spHeight) * 100);

end; {procedure, CalculateScaledPageSize}



{------------------------------------------------------------------------------}
{ TppScreenDevice.ScaleVertices}

procedure TppScreenDevice.ScaleVertices(aDrawCommand: TppDrawCommand);
var
  liLeft: Integer;
  liTop: Integer;
  liWidth: Integer;
  liHeight: Integer;
begin

  liLeft   := Trunc(ppFromMMThousandths(aDrawCommand.Left,   utScreenPixels, pprtHorizontal, nil));
  liTop    := Trunc(ppFromMMThousandths(aDrawCommand.Top,    utScreenPixels, pprtVertical,   nil));
  liWidth  := Trunc(ppFromMMThousandths(aDrawCommand.Width,  utScreenPixels, pprtHorizontal, nil));
  liHeight := Trunc(ppFromMMThousandths(aDrawCommand.Height, utScreenPixels, pprtVertical,   nil));

  {scale the bounding rectangle}
  aDrawCommand.DrawLeft   := FOffsetX + Round(liLeft * FScaleX);
  aDrawCommand.DrawTop    := FOffsetY + Round(liTop * FScaleY);
  aDrawCommand.DrawRight  := FOffsetX + Round((liLeft + liWidth) * FScaleX);
  aDrawCommand.DrawBottom := FOffsetY + Round((liTop + liHeight) * FScaleY);

end; {procedure, ScaleVertices}

{------------------------------------------------------------------------------}
{ TppScreenDevice.DrawUpdateable }

function TppScreenDevice.DrawUpdateable(aDrawCommand: TppDrawCommand): Boolean;
var
  lCanvas: TCanvas;
  lbTransparent: Boolean;
begin

  if (FCanvas <> nil) then
    begin
      {make drawcommand opaque in order to erase previous version}
      if (aDrawCommand is TppDrawText) then
        lbTransparent := TppDrawText(aDrawCommand).Transparent
      else
        lbTransparent := False;

      if lbTransparent then
        TppDrawText(aDrawCommand).Transparent := False;

      Result := Draw(aDrawCommand);

      if lbTransparent then
        TppDrawText(aDrawCommand).Transparent := True;


      if not Result then Exit;

      if (FViewer <> nil) then
        begin
          lCanvas := FViewer.PaintBox.Canvas;

          FViewer.IncrementalPainting := True;

          try
            lCanvas.CopyRect(aDrawCommand.DrawRect, FPageImage.Canvas, aDrawCommand.DrawRect);
          finally
            FViewer.IncrementalPainting := False;
          end;
        end;
    end

  else
    Result := True;

end; {function, DrawUpdateable}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Draw }

function TppScreenDevice.Draw(aDrawCommand: TppDrawCommand): Boolean;
begin
  Result := True;

  ScaleVertices(aDrawCommand);

  if (aDrawCommand is TppDrawText) then
    DrawText(TppDrawText(aDrawCommand))

  else if (aDrawCommand is TppDrawCalc) then
    DrawText(TppDrawText(aDrawCommand))

  else if (aDrawCommand is TppDrawShape) then
    DrawShape(TppDrawShape(aDrawCommand))

  else if (aDrawCommand is TppDrawLine) then
    DrawLine(TppDrawLine(aDrawCommand))

  else if (aDrawCommand is TppDrawImage) then
    DrawImage(TppDrawImage(aDrawCommand))

  else
    Result := False;

end; {function, Draw}

{------------------------------------------------------------------------------}
{ TppScreenDevice.DrawShape }

procedure TppScreenDevice.DrawShape(aDrawShape: TppDrawShape);
var
  liXCornerRound: Integer;
  liYCornerRound: Integer;
begin


  {assign pen and brush}
  FCanvas.Pen   := aDrawShape.Pen;
  FCanvas.Brush := aDrawShape.Brush;

  {scale pen width}
  FCanvas.Pen.Width := Round(aDrawShape.Pen.Width * FScaleX);

  {draw shape}
  case aDrawShape.ShapeType of

    stRectangle:
      FCanvas.Rectangle(aDrawShape.DrawLeft, aDrawShape.DrawTop, aDrawShape.DrawRight, aDrawShape.DrawBottom);

    stEllipse:
      FCanvas.Ellipse(aDrawShape.DrawLeft, aDrawShape.DrawTop, aDrawShape.DrawRight, aDrawShape.DrawBottom);

    stRoundRect:
      begin
        liXCornerRound := Trunc(ppFromMMThousandths(aDrawShape.XCornerRound, utScreenPixels, pprtHorizontal, nil));
        liYCornerRound := Trunc(ppFromMMThousandths(aDrawShape.YCornerRound, utScreenPixels, pprtVertical, nil));

        liXCornerRound := Round(liXCornerRound * FScaleX);
        liYCornerRound := Round(liYCornerRound * FScaleY);

        FCanvas.RoundRect(aDrawShape.DrawLeft, aDrawShape.DrawTop, aDrawShape.DrawRight, aDrawShape.DrawBottom,
                          liXCornerRound, liYCornerRound);

      end; {case, RoundRect}

  end; {case, ShapeType}

end; {procedure, DrawShape}

{------------------------------------------------------------------------------}
{ TppScreenDevice.DrawLine }

procedure TppScreenDevice.DrawLine(aDrawLine: TppDrawLine);
var
  liPenWidth: Integer;
  liSize: Integer;
  liOffset: Integer;
  liLines: Integer;
  liLine: Integer;
  liPosition: Integer;
begin

  {get pen width}
  liPenWidth := Round( (aDrawLine.Weight * Screen.PixelsPerInch / 72) * FScaleX);

  if (liPenWidth = 0) then
    liSize := 1
  else
    liSize := liPenWidth;

  {how many lines to draw?}
  if aDrawLine.LineStyle = lsSingle then
    liLines := 1
  else
    liLines := 2;

   {when draiwing bottom line, descrease the height by one pixel, otherwise
   the line is drawn outside the bounds of the control}
  if aDrawLine.LinePosition = lpBottom then
    aDrawLine.DrawBottom := aDrawLine.DrawBottom - 1;

  {when draiwing right line, descrease the width by one pixel, otherwise
  the line is drawn outside the bounds of the control}
  if aDrawLine.LinePosition = lpRight then
    aDrawLine.DrawRight := aDrawLine.DrawRight - 1;


  {setting brush to cross causes LineTo to honor the penstyle}
  FCanvas.Brush.Style := bsCross;

  {we're going to draw rectangles, because the pen doesn't work for large pen widths}
  FCanvas.Pen := aDrawLine.Pen;
  FCanvas.Pen.Width := 1;

  for liLine := 1 to liLines do

    begin

      if (liLine = 1) then
        liOffset := 0
      else
        liOffset := liSize * 2;

      for liPosition := 0 to liSize - 1 do

      {set print object moveto/lineto positions}
      case aDrawLine.LinePosition of
        lpTop:
          begin
            FCanvas.MoveTo(aDrawLine.DrawLeft, aDrawLine.DrawTop + liOffset + liPosition);
            FCanvas.LineTo(aDrawLine.DrawRight, aDrawLine.DrawTop + liOffset + liPosition);
          end;

        lpBottom:
          begin
            FCanvas.MoveTo(aDrawLine.DrawLeft, aDrawLine.DrawBottom - liOffset - liPosition);
            FCanvas.LineTo(aDrawLine.DrawRight, aDrawLine.DrawBottom - liOffset - liPosition);
          end;

        lpLeft:
          begin
            FCanvas.MoveTo(aDrawLine.DrawLeft + liOffset + liPosition, aDrawLine.DrawTop);
            FCanvas.LineTo(aDrawLine.DrawLeft + liOffset + liPosition, aDrawLine.DrawBottom);
          end;

        lpRight:
          begin
            FCanvas.MoveTo(aDrawLine.DrawRight - liOffset - liPosition, aDrawLine.DrawTop);
            FCanvas.LineTo(aDrawLine.DrawRight - liOffset - liPosition, aDrawLine.DrawBottom);
          end;

      end; {case, line style}

   end; {for, each line}

end; {procedure, DrawLine}

{------------------------------------------------------------------------------}
{ TppScreenDevice.DrawImage }

procedure TppScreenDevice.DrawImage(aDrawImage: TppDrawImage);
var
  lClipRect: TRect;
  lSavePalette:HPalette;
  lbRestorePalette: Boolean;
  lControlBMP: TBitmap;
  liControlHeight: Integer;
  liControlWidth: Integer;
  lfScale: Single;
  liScaledWidth: Integer;
  liScaledHeight: Integer;

begin

  if (aDrawImage = nil) or (aDrawImage.Picture = nil) or
     (aDrawImage.Picture.Graphic = nil) then Exit;

  if aDrawImage.DirectDraw then
    begin
      DirectDrawImage(aDrawImage);
      Exit;
    end;


  lSavePalette := 0;
  lbRestorePalette := False;


  {realize palette }
  if aDrawImage.Picture.Graphic.Palette <> 0 then
    begin
      lSavePalette := SelectPalette(FCanvas.Handle, aDrawImage.Picture.Graphic.Palette, False);
      RealizePalette(FCanvas.Handle);
      lbRestorePalette := True;
    end;


  {get the unscaled height and width of the object}
  liControlWidth  := Trunc(ppFromMMThousandths(aDrawImage.Width,  utScreenPixels, pprtHorizontal, nil));
  liControlHeight := Trunc(ppFromMMThousandths(aDrawImage.Height, utScreenPixels, pprtVertical,   nil));

  {compute clipping rect based on control size & picture size }
  if aDrawImage.Stretch and aDrawImage.MaintainAspectRatio then
    begin

      lClipRect := Rect(0, 0, liControlWidth, liControlHeight);

      lfScale := ppCalcAspectRatio(aDrawImage.Picture.Width, aDrawImage.Picture.Height, liControlWidth, liControlHeight);

      liScaledWidth  := Trunc(aDrawImage.Picture.Width  * lfScale);
      liScaledHeight := Trunc(aDrawImage.Picture.Height * lfScale);

      if aDrawImage.Center then
        begin
          lClipRect.Left := lClipRect.Left + ((liControlWidth  - liScaledWidth)  div 2);
          lClipRect.Top  := lClipRect.Top  + ((liControlHeight - liScaledHeight) div 2);
        end;

      lClipRect.Right  := lClipRect.Left + liScaledWidth;
      lClipRect.Bottom := lClipRect.Top  + liScaledHeight;

    end

  else if aDrawImage.Stretch then
    lClipRect := Rect(0, 0, liControlWidth, liControlHeight)

  else if aDrawImage.Center then
    lClipRect := Bounds((liControlWidth - aDrawImage.Picture.Width) div 2, (liControlHeight - aDrawImage.Picture.Height) div 2,
                 aDrawImage.Picture.Width, aDrawImage.Picture.Height)
  else
    lClipRect := Rect(0, 0, aDrawImage.Picture.Width, aDrawImage.Picture.Height);


  {create a bitmap with the same dimensions as the picture control}
  lControlBMP := TBitMap.Create;

  lControlBMP.Width   := liControlWidth;
  lControlBMP.Height  := liControlHeight;

  {stretch draw the source bitmap onto the bitmap's canvas
    note: at this point we have mapped the source bmp to the control's picture }
  if aDrawImage.AsBitmap <> nil then
    lControlBMP.Canvas.StretchDraw(lClipRect, aDrawImage.AsBitmap)
  else
    lControlBMP.Canvas.StretchDraw(lClipRect, aDrawImage.Picture.Graphic);

  if aDrawImage.Transparent then
    FCanvas.CopyMode := SrcAnd
  else
    FCanvas.CopyMode := SrcCopy;

  {draw the clipped bmp to the result canvas}
  FCanvas.StretchDraw(aDrawImage.DrawRect, lControlBMP);

  lControlBMP.Free;

  {restore save palette }
  if lbRestorePalette then
    SelectPalette(FCanvas.Handle, lSavePalette, False);


end; {procedure, DrawImage}



{------------------------------------------------------------------------------}
{ TppScreenDevice.DirectDrawImage }

procedure TppScreenDevice.DirectDrawImage(aDrawImage: TppDrawImage);
var
  lSaveClipRgn: HRGN;
  lNewClipRgn: HRGN;
  lDrawRect: TRect;
  liImageWidth: Integer;
  liImageHeight: Integer;
  liControlWidth: Integer;
  liControlHeight: Integer;
  lfScale: Single;
  liScaledWidth: Integer;
  liScaledHeight: Integer;

begin

  if aDrawImage.Transparent then
    FCanvas.CopyMode := cmSrcAnd
  else
    FCanvas.CopyMode := cmSrcCopy;


  {initialize}
  lDrawRect := aDrawImage.DrawRect;

  {compute image dimensions in screen pixels}
  liImageWidth    := aDrawImage.Picture.Graphic.Width;
  liImageHeight   := aDrawImage.Picture.Graphic.Height;


  if aDrawImage.Stretch then
    begin

      {scale the draw rect to maintain aspect ration, if needed }
      if aDrawImage.MaintainAspectRatio then
        begin
          liControlWidth  := lDrawRect.Right  - lDrawRect.Left;
          liControlHeight := lDrawRect.Bottom - lDrawRect.Top;

          lfScale := ppCalcAspectRatio(liImageWidth, liImageHeight, liControlWidth, liControlHeight);

          liScaledWidth  := Trunc(liImageWidth  * lfScale);
          liScaledHeight := Trunc(liImageHeight * lfScale);

          if aDrawImage.Center then
            begin
              lDrawRect.Left:=lDrawRect.Left + (liControlWidth  - liScaledWidth)  div 2;
              lDrawRect.Top:= lDrawRect.Top  + (liControlHeight - liScaledHeight) div 2;
            end;

          lDrawRect.Right  := lDrawRect.Left + liScaledWidth;
          lDrawRect.Bottom := lDrawRect.Top  + liScaledHeight;

        end;

      {draw image}
      FCanvas.StretchDraw(lDrawRect, aDrawImage.Picture.Graphic);


    end

  else
    begin
      lSaveClipRgn := 0;
      GetClipRgn (FCanvas.Handle, lSaveClipRgn);

      {set clipping region}
      lNewClipRgn  := CreateRectRgnIndirect(aDrawImage.DrawRect);
      SelectClipRgn (FCanvas.Handle, lNewClipRgn);

      {compute control dimensions in screen pixels}
      liControlWidth  := Trunc(ppFromMMThousandths(aDrawImage.Width,  utScreenPixels, pprtHorizontal, nil));
      liControlHeight := Trunc(ppFromMMThousandths(aDrawImage.Height, utScreenPixels, pprtVertical,   nil));

      {recompute lef and top, if centered}
      if aDrawImage.Center then
        begin
          lDrawRect.Left := lDrawRect.Left + Trunc( ((liControlWidth  - liImageWidth)  div 2) * FScaleX);
          lDrawRect.Top  := lDrawRect.Top  + Trunc( ((liControlHeight - liImageHeight) div 2) * FScaleY);
        end;

      {compute right and bottom}
      lDrawRect.Right  := lDrawRect.Left + Trunc(liImageWidth  * FScaleX);
      lDrawRect.Bottom := lDrawRect.Top  + Trunc(liImageHeight * FScaleY);

      FCanvas.StretchDraw(lDrawRect, aDrawImage.Picture.Graphic);

      {restore clipping region}
      SelectClipRgn(FCanvas.Handle, lSaveClipRgn);

      DeleteObject(lNewClipRgn);


  end

end; {procedure, DirectDrawImage}


{------------------------------------------------------------------------------}
{ TppScreenDevice.DrawText }

procedure TppScreenDevice.DrawText(aDrawText: TppDrawText);
var
//  liIndex: Integer;
//  liFontHeight: Integer;
//  lParams: TraParamList;
  liLineHeight: Integer;
  liCalcHeight: Integer;
  lbLinesFit: Boolean;
  liLineSpaceUsed: Integer;
  liLines: Integer;
  liLine: Integer;
  lDrawRect: TRect;
  lRect: TRect;
  lCalcRect: TRect;
  liWidthAvailable: Integer;
  liTextWidth: Integer;
  lSourceText: TStringList;
  lsLine: String;
  liStart: Integer;
  liLeading: Integer;

  lLineBuf: PChar;
  lTextMetric: TTextMetric;
  lbTruncTheText: Boolean;

  llRectHeight: Longint;
  llCalcHeight: Longint;

  liTabStopCount: Integer;
  liTabStop: Integer;
  lTabStopArray: TppTabStopPos;
  liTop: Integer;
  liMaxWidth: Integer;
  liPos: Integer;
  lbFullJustification: Boolean;

begin

  liTabStopCount := aDrawText.TabStopPositions.Count;
  
  {convert memo tab stop positions to screen units, if needed }
  if aDrawText.IsMemo and (aDrawText.TabStopPositions.Count > 0) then
    begin
      TppPlainText.ConvertTabStopPos(utScreenPixels, aDrawText.TabStopPositions, lTabStopArray, liTabStopCount, nil);

      for liTabStop := 0 to liTabStopCount - 1 do
        lTabStopArray[liTabStop] := Round(lTabStopArray[liTabStop] * FScaleX);
    end;


  if (FCanvas.Font.CharSet <> aDrawText.Font.CharSet) or
     (FCanvas.Font.Color   <> aDrawText.Font.Color)   or
     (FCanvas.Font.Pitch   <> aDrawText.Font.Pitch)   or
     (FCanvas.Font.Size    <> aDrawText.Font.Size)    or
     (FCanvas.Font.Style   <> aDrawText.Font.Style)   or
     (FCanvas.Font.Name    <> aDrawText.Font.Name) then

    FCanvas.Font := aDrawText.Font;


  {maybe we can't use the selected font}
  FCanvas.Font.Name := TppDeviceSubstitutions.SubstituteFont(aDrawText.Font.Name);

  {set font height}
  FCanvas.Font.Height := Round(aDrawText.Font.Height * FScaleY);

  lbTruncTheText := False;

  {font size must at least be one}
  if (FCanvas.Font.Height = 0) then
    FCanvas.Font.Height := -1;

  GetTextMetrics(FCanvas.Handle, lTextMetric);

  {use default leading for this font}
  if not(aDrawText.IsMemo) then
    liLeading := lTextMetric.tmExternalLeading
  else
    liLeading := Trunc(ppFromMMThousandths(aDrawText.Leading, utScreenPixels, pprtVertical, nil));

  liLineHeight := lTextMetric.tmHeight + liLeading;

  lDrawRect := Rect(aDrawText.DrawLeft, aDrawText.DrawTop, aDrawText.DrawRight, aDrawText.DrawBottom);

  {adjust bounding rect height}
  if aDrawText.AutoSize and not(aDrawText.WordWrap) and (Length(aDrawText.Text) > 0) then
    begin
      llRectHeight := lDrawRect.Bottom - lDrawRect.Top;
      llCalcHeight := liLineHeight;

      if (llCalcHeight > llRectHeight) then
        lDrawRect.Bottom := lDrawRect.Top + llCalcHeight;
    end;

  lbLinesFit := True;
  liLine := 0;
  liLines := aDrawText.WrappedText.Count - 1;
  liWidthAvailable := (lDrawRect.Right - lDrawRect.Left);

  if (aDrawText.IsMemo) and (aDrawText.WrappedText.Count > 1) then
    begin

      while (liLine <= liLines) do
        begin
          lsLine := aDrawText.WrappedText[liLine];

          liPos := Pos(TppTextMarkups.EOP, lsLine);

          if (liPos <> 0) then
            lsLine := TppPlainText.StringStrip(lsLine, TppTextMarkups.EOP);

          liTextWidth := TppPlainText.GetTabbedTextWidth(FCanvas, lsLine, liTabStopCount, lTabStopArray);

          if (liPos <> 0) then
            lsLine := lsLine + TppTextMarkups.EOP;

          if (liTextWidth > liWidthAvailable) and (Abs(FCanvas.Font.Height) > 1) then
            begin
              if (FCanvas.Font.Height > 0) then
                FCanvas.Font.Height := FCanvas.Font.Height - 1
              else
                FCanvas.Font.Height := FCanvas.Font.Height + 1;

              if (Abs(FCanvas.Font.Height) > 1) then
                Inc(liLine)
              else
                liLine := liLines + 1;
            end

          else
            Inc(liLine);

        end;

      GetTextMetrics(FCanvas.Handle, lTextMetric);

      {get leading for this font}
      if not(aDrawText.IsMemo) then
        liLeading := lTextMetric.tmExternalLeading
      else
        liLeading := Trunc(ppFromMMThousandths(aDrawText.Leading, utScreenPixels, pprtVertical, nil));

      liLineHeight := lTextMetric.tmHeight + liLeading;

      liCalcHeight := Round((lDrawRect.Bottom - lDrawRect.Top) / aDrawText.WrappedText.Count);

      if ((Abs(liCalcHeight - liLineHeight) / liLineHeight) <= 0.10) then
        liLineHeight := liCalcHeight

      else
        begin
          lbLinesFit := liLineHeight <= Trunc((lDrawRect.Bottom - lDrawRect.Top) / aDrawText.WrappedText.Count);

          while not(lbLinesFit) and (Abs(FCanvas.Font.Height) > 1) do
            begin
              if liLeading > 0 then
                Dec(liLeading)

              else
                begin
                  {decrease height of font by one pixel }
                  if FCanvas.Font.Height > 0 then

                    FCanvas.Font.Height := FCanvas.Font.Height - 1
                  else
                    FCanvas.Font.Height := FCanvas.Font.Height + 1;

                  GetTextMetrics(FCanvas.Handle, lTextMetric);
                end;

              liLineHeight := lTextMetric.tmHeight + liLeading;

              lbLinesFit := liLineHeight <= Trunc((lDrawRect.Bottom - lDrawRect.Top) / aDrawText.WrappedText.Count);
           end; {while, lines don't fit}

        end; {check to see if lines fit}

    end; {if, memo & linecound > 1) }


  if not(lbLinesFit) then
    liLines := Trunc((lDrawRect.Bottom - lDrawRect.Top) / liLineHeight);


  if Abs(FCanvas.Font.Height) < 1 then
    begin
      if FCanvas.Font.Height > 0 then
        FCanvas.Font.Height := 1

      else
        FCanvas.Font.Height := -1;

      lbTruncTheText := True;
    end;

  lSourceText := TStringList.Create;

  if aDrawText.WordWrap then
    lSourceText.Assign(aDrawText.WrappedText)

  else if (Length(aDrawText.Text) > 0) then
    begin
      lSourceText.Add(aDrawText.Text);

      liLines := 0;
    end;

  {set rectangle to original value}
  lCalcRect := lDrawRect;


  {calculate rectangle width based on longest text}
  if aDrawText.AutoSize then
    begin
      liMaxWidth := 0;

      {calc max line width}
      for liLine := 0 to liLines do
        begin
          lsLine := lSourceText[liLine];

          liPos := Pos(TppTextMarkups.EOP, lsLine);

          if (liPos <> 0) then
            lsLine := TppPlainText.StringStrip(lsLine, TppTextMarkups.EOP);

          liTextWidth  := TppPlainText.GetTabbedTextWidth(FCanvas, lsLine, liTabStopCount, lTabStopArray);

          if (liPos <> 0) then
            lsLine := lsLine + TppTextMarkups.EOP;

          if liTextWidth > liMaxWidth then
            liMaxWidth := liTextWidth;
        end;

      liWidthAvailable := (lCalcRect.Right - lCalcRect.Left);

      {if text wider than rectangle, adjust rectangle}
      if (liMaxWidth <> liWidthAvailable) then
        begin

          {adjust rectangle}
          if aDrawText.Alignment = taLeftJustify then
            lCalcRect.Right := lCalcRect.Left + liMaxWidth

          else if aDrawText.Alignment = taRightJustify then
            lCalcRect.Left := lCalcRect.Right - liMaxWidth

          else if aDrawText.Alignment = taCenter then
            begin
              lCalcRect.Left  := lCalcRect.Left + Round((liWidthAvailable - liMaxWidth) / 2);
              lCalcRect.Right := lCalcRect.Left + liMaxWidth;
            end;

        end; {text wider than rectangle}

    end; {if, AutoSize}


  {fill rectangle with background color}
  if not(aDrawText.Transparent) then
    begin
      FCanvas.Brush.Color := aDrawText.Color;
      FCanvas.Brush.Style := bsSolid;
      FCanvas.FillRect(lCalcRect);
    end;

  FCanvas.Brush.Style := bsClear;

  liLineSpaceUsed := 0;

  lbFullJustification := False;

  for liLine := 0 to liLines do
    begin
      lsLine := lSourceText[liLine];

      liWidthAvailable := (lCalcRect.Right - lCalcRect.Left);

      {reset rectangle to original value}
      lRect := lCalcRect;

      lRect.Top := lRect.Top + liLineSpaceUsed;

      liTop := lRect.Top;

      {justify text}
      if (aDrawText.TextAlignment = taFullJustified) then
        begin
          liStart := lRect.Left;

          if aDrawText.ForceJustifyLastLine or (Pos(TppTextMarkups.EOP, lsLine) = 0) then
            begin
              if (Pos(TppTextMarkups.EOP, lsLine) <> 0) and (Pos(TppTextMarkups.Space, Trim(lsLine)) = 0) then
                begin
                  lbFullJustification := False;
                  SetTextJustification(FCanvas.Handle, 0, 0);
                  lsLine := TppPlainText.StringStrip(lsLine, TppTextMarkups.EOP);
                end
              else
                begin
                  lbFullJustification := True;
                  TppPlainText.SetCanvasToJustify(FCanvas, lRect, lsLine, liTabStopCount, lTabStopArray);
                  lsLine := TppPlainText.StringStrip(lsLine, TppTextMarkups.EOP);
                end;
            end

          else
            begin
              lsLine := TppPlainText.StringStrip(lsLine, TppTextMarkups.EOP);
              SetTextJustification(FCanvas.Handle, 0, 0);
            end;
        end

      else
        begin
          liTextWidth := TppPlainText.GetTabbedTextWidth(FCanvas, lsLine, liTabStopCount, lTabStopArray);

          if aDrawText.TextAlignment = taLeftJustified then
            liStart := lRect.Left

          else if aDrawText.TextAlignment = taRightJustified then
            liStart := lRect.Right - liTextWidth

          else if aDrawText.TextAlignment = taCentered then
            liStart := lRect.Left + Round( ( (liWidthAvailable - liTextWidth) / 2) - 0.5)

          else
            liStart := 0;
        end;

      {draw the text}
      if aDrawText.IsMemo and not(lbTruncTheText) then
        begin
          lLineBuf := StrAlloc(Length(lsLine) + 1);
          StrPCopy(lLineBuf, lsLine);
          TabbedTextOut(FCanvas.Handle, liStart, liTop, lLineBuf, StrLen(lLineBuf), liTabStopCount, lTabStopArray, liStart);
          StrDispose(lLineBuf);
        end

      else
        begin
          if aDrawText.AutoSize and not(aDrawText.IsMemo) then
            FCanvas.TextOut(liStart, liTop, lsLine)
          else
            FCanvas.TextRect(lRect, liStart, liTop, lsLine);
        end;

      {goto next line}
      Inc(liLineSpaceUsed, liLineHeight);
      
    end; {for, each line of text}

  {must clear full justification mode or GetTabbedTextWidth will fail next time.}
  if (lbFullJustification) then
    SetTextJustification(FCanvas.Handle, 0, 0);

  lSourceText.Free;

  {update size of draw rect}
  if aDrawText.AutoSize then
    begin
      aDrawText.DrawLeft   := lCalcRect.Left;
      aDrawText.DrawRight  := lCalcRect.Right;
      aDrawText.DrawBottom := aDrawText.DrawTop + liLineSpaceUsed;
    end;

  {used to support preview form searching}
  aDrawText.DeviceFontHeight := FCanvas.Font.Height;
  aDrawText.DeviceLineHeight := ppToMMThousandths(liLineHeight, utScreenPixels, pprtVertical, nil);
  aDrawText.DeviceLineWidth :=  ppToMMThousandths(liWidthAvailable, utScreenPixels, pprtHorizontal, nil);

end; {procedure, DrawText}

{------------------------------------------------------------------------------}
{ TppScreenDevice.FindClickableDrawCommand }

function TppScreenDevice.FindClickableDrawCommand(var aDrawCommand: TppDrawCommand): Boolean;
var
  lPoint: TPoint;
begin
  GetCursorPos(lPoint);

  lPoint := FViewer.PaintBox.ScreenToClient(lPoint);

  Result := FindClickableDrawCommand(lPoint.X, lPoint.Y, aDrawCommand);
  
end;


{------------------------------------------------------------------------------}
{ TppScreenDevice.FindClickableDrawCommand }

function TppScreenDevice.FindClickableDrawCommand(aX, aY: Integer; var aDrawCommand: TppDrawCommand): Boolean;
var
  liIndex: Integer;
  lDrawCommand: TppDrawCommand;
  lbFound: Boolean;
begin

  liIndex := 0;
  lbFound := False;
  lDrawCommand := nil;

  while (liIndex <= FPage.ClickableCount - 1) and not(lbFound) do
    begin
      lDrawCommand := FPage.Clickables[liIndex];

      lbFound := (aX >= lDrawCommand.DrawLeft) and
                 (aX <= lDrawCommand.DrawRight) and
                 (aY >= lDrawCommand.DrawTop) and
                 (aY <= lDrawCommand.DrawBottom) and
                 (lDrawCommand.Clickable);

      Inc(liIndex);
    end;

  if lbFound then
    aDrawCommand := lDrawCommand;

  Result := lbFound;

end; {procedure, FindClickableDrawCommand}


{------------------------------------------------------------------------------}
{ TppScreenDevice.AddWaterMark }

procedure TppScreenDevice.AddWaterMark(aPage: TppPage);
var
  lWaterMark: TppDrawText;
begin

  if not(ppValidDate) then
    begin
      lWaterMark := TppDrawText.Create(aPage);
      lWaterMark.WrappedText.Add('** ReportBuilder ' + ppEdition + ' ' + ppVersion + #153 + ' ** Demo Copy  ** www.digital-metaphors.com **');
      lWaterMark.Transparent := False;
      lWaterMark.IsMemo      := False;
      lWaterMark.WordWrap    := True;
      lWaterMark.Font.Name   := 'Arial';
      lWaterMark.Font.Size   := 12;
      lWaterMark.Font.Style  := [fsBold];
      lWaterMark.Autosize    := False;
      lWaterMark.TextAlignment := taLeftJustified;

      lWaterMark.Color := clYellow;
      lWaterMark.Font.Color  := clRed;

      lWaterMark.Top  := ppToMMThousandths(1, utScreenPixels, pprtHorizontal, nil);
      lWaterMark.Left := ppToMMThousandths(2, utScreenPixels, pprtHorizontal, nil);

      lWaterMark.Height := ppToMMThousandths(20, utScreenPixels, pprtHorizontal, nil);
      lWaterMark.Width  := aPage.PageDef.mmWidth - ppToMMThousandths(4, utScreenPixels, pprtHorizontal, nil);

      lWaterMark.Page := aPage;

    end;

end; {procedure, AddWaterMark}



{******************************************************************************
 *
 ** I N I T I A L I Z A T I O N   /   F I N A L I Z A T I O N
 *
{******************************************************************************}


initialization

  RegisterClasses([TppViewer, TppScreenDevice]);

  ppRegisterDevice(TppScreenDevice);

finalization

  ppUnRegisterDevice(TppScreenDevice);

  UnRegisterClasses([TppViewer, TppScreenDevice]);

end. 
